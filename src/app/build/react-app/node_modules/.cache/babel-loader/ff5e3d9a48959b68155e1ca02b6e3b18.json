{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _objectWithoutProperties = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _excluded = [\"asset\"],\n    _excluded2 = [\"asset\"],\n    _excluded3 = [\"asset\"],\n    _excluded4 = [\"asset\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Block = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar codec_1 = require(\"./codec\");\n\nvar Block = /*#__PURE__*/function () {\n  function Block(channel, registeredSchema) {\n    _classCallCheck(this, Block);\n\n    this._channel = channel;\n    this._schemas = registeredSchema;\n  }\n\n  _createClass(Block, [{\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(id) {\n        var idString, blockHex, blockBytes;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                idString = Buffer.isBuffer(id) ? id.toString('hex') : id;\n                _context.next = 3;\n                return this._channel.invoke('app:getBlockByID', {\n                  id: idString\n                });\n\n              case 3:\n                blockHex = _context.sent;\n                blockBytes = Buffer.from(blockHex, 'hex');\n                return _context.abrupt(\"return\", codec_1.decodeBlock(blockBytes, this._schemas));\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"getByHeight\",\n    value: function () {\n      var _getByHeight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(height) {\n        var blockHex, blockBytes;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._channel.invoke('app:getBlockByHeight', {\n                  height: height\n                });\n\n              case 2:\n                blockHex = _context2.sent;\n                blockBytes = Buffer.from(blockHex, 'hex');\n                return _context2.abrupt(\"return\", codec_1.decodeBlock(blockBytes, this._schemas));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getByHeight(_x2) {\n        return _getByHeight.apply(this, arguments);\n      }\n\n      return getByHeight;\n    }()\n  }, {\n    key: \"encode\",\n    value: function encode(input) {\n      return codec_1.encodeBlock(input, this._schemas);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(input) {\n      var inputBuffer = Buffer.isBuffer(input) ? input : Buffer.from(input, 'hex');\n      return codec_1.decodeBlock(inputBuffer, this._schemas);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(block) {\n      var _block$header = block.header,\n          asset = _block$header.asset,\n          headerRoot = _objectWithoutProperties(_block$header, _excluded);\n\n      var tmpBlockId = headerRoot.id;\n      delete headerRoot.id;\n\n      var header = _objectSpread(_objectSpread({}, lisk_codec_1.codec.toJSON(this._schemas.blockHeader, headerRoot)), {}, {\n        asset: {},\n        id: tmpBlockId === null || tmpBlockId === void 0 ? void 0 : tmpBlockId.toString('hex')\n      });\n\n      var headerAssetJson = lisk_codec_1.codec.toJSON(this._schemas.blockHeadersAssets[block.header.version], asset);\n      header.asset = headerAssetJson;\n      var payload = [];\n\n      var _iterator = _createForOfIteratorHelper(block.payload),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var tx = _step.value;\n\n          var txAsset = tx.asset,\n              txRoot = _objectWithoutProperties(tx, _excluded2);\n\n          var tmpId = txRoot.id;\n          delete txRoot.id;\n          var schemaAsset = codec_1.getTransactionAssetSchema(tx, this._schemas);\n          var jsonTxAsset = lisk_codec_1.codec.toJSON(schemaAsset, txAsset);\n          var jsonTxRoot = lisk_codec_1.codec.toJSON(this._schemas.transaction, txRoot);\n\n          var jsonTx = _objectSpread(_objectSpread({}, jsonTxRoot), {}, {\n            id: tmpId === null || tmpId === void 0 ? void 0 : tmpId.toString('hex'),\n            asset: jsonTxAsset\n          });\n\n          payload.push(jsonTx);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return {\n        header: header,\n        payload: payload\n      };\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(block) {\n      var _block$header2 = block.header,\n          asset = _block$header2.asset,\n          headerRoot = _objectWithoutProperties(_block$header2, _excluded3);\n\n      var tmpBlockId = headerRoot.id ? Buffer.from(headerRoot.id, 'hex') : Buffer.alloc(0);\n      delete headerRoot.id;\n\n      var header = _objectSpread(_objectSpread({}, lisk_codec_1.codec.fromJSON(this._schemas.blockHeader, headerRoot)), {}, {\n        asset: {},\n        id: tmpBlockId\n      });\n\n      var headerAssetJson = lisk_codec_1.codec.fromJSON(this._schemas.blockHeadersAssets[block.header.version], asset);\n      header.asset = headerAssetJson;\n      var payload = [];\n\n      var _iterator2 = _createForOfIteratorHelper(block.payload),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var tx = _step2.value;\n\n          var txAsset = tx.asset,\n              txRoot = _objectWithoutProperties(tx, _excluded4);\n\n          var tmpId = txRoot.id ? Buffer.from(txRoot.id, 'hex') : Buffer.alloc(0);\n          delete txRoot.id;\n          var schemaAsset = codec_1.getTransactionAssetSchema(tx, this._schemas);\n          var txAssetObject = lisk_codec_1.codec.fromJSON(schemaAsset, txAsset);\n          var txRootObject = lisk_codec_1.codec.fromJSON(this._schemas.transaction, txRoot);\n\n          var txObject = _objectSpread(_objectSpread({}, txRootObject), {}, {\n            id: tmpId,\n            asset: txAssetObject\n          });\n\n          payload.push(txObject);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return {\n        header: header,\n        payload: payload\n      };\n    }\n  }]);\n\n  return Block;\n}();\n\nexports.Block = Block;","map":{"version":3,"sources":["../src/block.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Block = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst codec_1 = require(\"./codec\");\nclass Block {\n    constructor(channel, registeredSchema) {\n        this._channel = channel;\n        this._schemas = registeredSchema;\n    }\n    async get(id) {\n        const idString = Buffer.isBuffer(id) ? id.toString('hex') : id;\n        const blockHex = await this._channel.invoke('app:getBlockByID', {\n            id: idString,\n        });\n        const blockBytes = Buffer.from(blockHex, 'hex');\n        return codec_1.decodeBlock(blockBytes, this._schemas);\n    }\n    async getByHeight(height) {\n        const blockHex = await this._channel.invoke('app:getBlockByHeight', { height });\n        const blockBytes = Buffer.from(blockHex, 'hex');\n        return codec_1.decodeBlock(blockBytes, this._schemas);\n    }\n    encode(input) {\n        return codec_1.encodeBlock(input, this._schemas);\n    }\n    decode(input) {\n        const inputBuffer = Buffer.isBuffer(input) ? input : Buffer.from(input, 'hex');\n        return codec_1.decodeBlock(inputBuffer, this._schemas);\n    }\n    toJSON(block) {\n        const { asset, ...headerRoot } = block.header;\n        const tmpBlockId = headerRoot.id;\n        delete headerRoot.id;\n        const header = {\n            ...lisk_codec_1.codec.toJSON(this._schemas.blockHeader, headerRoot),\n            asset: {},\n            id: tmpBlockId === null || tmpBlockId === void 0 ? void 0 : tmpBlockId.toString('hex'),\n        };\n        const headerAssetJson = lisk_codec_1.codec.toJSON(this._schemas.blockHeadersAssets[block.header.version], asset);\n        header.asset = headerAssetJson;\n        const payload = [];\n        for (const tx of block.payload) {\n            const { asset: txAsset, ...txRoot } = tx;\n            const tmpId = txRoot.id;\n            delete txRoot.id;\n            const schemaAsset = codec_1.getTransactionAssetSchema(tx, this._schemas);\n            const jsonTxAsset = lisk_codec_1.codec.toJSON(schemaAsset, txAsset);\n            const jsonTxRoot = lisk_codec_1.codec.toJSON(this._schemas.transaction, txRoot);\n            const jsonTx = {\n                ...jsonTxRoot,\n                id: tmpId === null || tmpId === void 0 ? void 0 : tmpId.toString('hex'),\n                asset: jsonTxAsset,\n            };\n            payload.push(jsonTx);\n        }\n        return { header, payload };\n    }\n    fromJSON(block) {\n        const { asset, ...headerRoot } = block.header;\n        const tmpBlockId = headerRoot.id ? Buffer.from(headerRoot.id, 'hex') : Buffer.alloc(0);\n        delete headerRoot.id;\n        const header = {\n            ...lisk_codec_1.codec.fromJSON(this._schemas.blockHeader, headerRoot),\n            asset: {},\n            id: tmpBlockId,\n        };\n        const headerAssetJson = lisk_codec_1.codec.fromJSON(this._schemas.blockHeadersAssets[block.header.version], asset);\n        header.asset = headerAssetJson;\n        const payload = [];\n        for (const tx of block.payload) {\n            const { asset: txAsset, ...txRoot } = tx;\n            const tmpId = txRoot.id ? Buffer.from(txRoot.id, 'hex') : Buffer.alloc(0);\n            delete txRoot.id;\n            const schemaAsset = codec_1.getTransactionAssetSchema(tx, this._schemas);\n            const txAssetObject = lisk_codec_1.codec.fromJSON(schemaAsset, txAsset);\n            const txRootObject = lisk_codec_1.codec.fromJSON(this._schemas.transaction, txRoot);\n            const txObject = {\n                ...txRootObject,\n                id: tmpId,\n                asset: txAssetObject,\n            };\n            payload.push(txObject);\n        }\n        return { header, payload };\n    }\n}\nexports.Block = Block;\n//# sourceMappingURL=block.js.map"]},"metadata":{},"sourceType":"script"}