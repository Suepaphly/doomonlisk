{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recursiveTypeCast = exports.iterator = void 0;\nvar mappers = {\n  toJSON: {\n    uint32: function uint32(value) {\n      return value;\n    },\n    sint32: function sint32(value) {\n      return value;\n    },\n    uint64: function uint64(value) {\n      return value.toString();\n    },\n    sint64: function sint64(value) {\n      return value.toString();\n    },\n    string: function string(value) {\n      return value;\n    },\n    bytes: function bytes(value) {\n      return value.toString('hex');\n    },\n    boolean: function boolean(value) {\n      return value;\n    }\n  },\n  fromJSON: {\n    uint32: function uint32(value) {\n      return value;\n    },\n    sint32: function sint32(value) {\n      return value;\n    },\n    uint64: function uint64(value) {\n      return BigInt(value);\n    },\n    sint64: function sint64(value) {\n      return BigInt(value);\n    },\n    string: function string(value) {\n      return value;\n    },\n    bytes: function bytes(value) {\n      return Buffer.from(value, 'hex');\n    },\n    boolean: function boolean(value) {\n      return value;\n    }\n  }\n};\n\nvar findObjectByPath = function findObjectByPath(message, pathArr) {\n  var result = message;\n\n  for (var i = 0; i < pathArr.length; i += 1) {\n    if (!result.properties && !result.items) {\n      return undefined;\n    }\n\n    if (result.properties) {\n      result = result.properties[pathArr[i]];\n    } else if (result.items) {\n      var x = result.items.properties;\n      result = x[pathArr[i]];\n    }\n  }\n\n  return result;\n};\n\nvar isObject = function isObject(item) {\n  return typeof item === 'object' && item !== null && !Array.isArray(item) && !Buffer.isBuffer(item);\n};\n\nvar iterator = function iterator() {\n  var _this = this;\n\n  var index = 0;\n  var properties = Object.keys(this);\n  var Done = false;\n  return {\n    next: function next() {\n      Done = index >= properties.length;\n      var obj = {\n        done: Done,\n        value: {\n          value: _this[properties[index]],\n          key: properties[index]\n        }\n      };\n      index += 1;\n      return obj;\n    }\n  };\n};\n\nexports.iterator = iterator;\n\nvar recursiveTypeCast = function recursiveTypeCast(mode, object, schema, dataPath) {\n  var _a;\n\n  var _iterator = _createForOfIteratorHelper(object),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          key = _step$value.key,\n          value = _step$value.value;\n\n      if (isObject(value)) {\n        dataPath.push(key);\n        value[Symbol.iterator] = exports.iterator;\n        exports.recursiveTypeCast(mode, value, schema, dataPath);\n        dataPath.pop();\n        delete value[Symbol.iterator];\n      } else if (Array.isArray(value)) {\n        dataPath.push(key);\n        var schemaProp = findObjectByPath(schema, dataPath);\n\n        if (((_a = schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) === null || _a === void 0 ? void 0 : _a.type) === 'object') {\n          for (var i = 0; i < value.length; i += 1) {\n            var arrayObject = value[i];\n            arrayObject[Symbol.iterator] = exports.iterator;\n            exports.recursiveTypeCast(mode, arrayObject, schema, dataPath);\n            delete arrayObject[Symbol.iterator];\n          }\n        } else {\n          for (var _i = 0; _i < value.length; _i += 1) {\n            if (schemaProp === undefined || schemaProp.items === undefined) {\n              throw new Error(\"Invalid schema property found. Path: \".concat(dataPath.join(',')));\n            }\n\n            object[key][_i] = mappers[mode][schemaProp.items.dataType](value[_i]);\n          }\n        }\n\n        dataPath.pop();\n      } else {\n        dataPath.push(key);\n\n        var _schemaProp = findObjectByPath(schema, dataPath);\n\n        if (_schemaProp === undefined) {\n          throw new Error(\"Invalid schema property found. Path: \".concat(dataPath.join(',')));\n        }\n\n        object[key] = mappers[mode][_schemaProp.dataType](value);\n        delete object[Symbol.iterator];\n        dataPath.pop();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  delete object[Symbol.iterator];\n};\n\nexports.recursiveTypeCast = recursiveTypeCast;","map":{"version":3,"sources":["../src/json_wrapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.recursiveTypeCast = exports.iterator = void 0;\nconst mappers = {\n    toJSON: {\n        uint32: value => value,\n        sint32: value => value,\n        uint64: value => value.toString(),\n        sint64: value => value.toString(),\n        string: value => value,\n        bytes: value => value.toString('hex'),\n        boolean: value => value,\n    },\n    fromJSON: {\n        uint32: value => value,\n        sint32: value => value,\n        uint64: value => BigInt(value),\n        sint64: value => BigInt(value),\n        string: value => value,\n        bytes: value => Buffer.from(value, 'hex'),\n        boolean: value => value,\n    },\n};\nconst findObjectByPath = (message, pathArr) => {\n    let result = message;\n    for (let i = 0; i < pathArr.length; i += 1) {\n        if (!result.properties && !result.items) {\n            return undefined;\n        }\n        if (result.properties) {\n            result = result.properties[pathArr[i]];\n        }\n        else if (result.items) {\n            const x = result.items.properties;\n            result = x[pathArr[i]];\n        }\n    }\n    return result;\n};\nconst isObject = (item) => typeof item === 'object' && item !== null && !Array.isArray(item) && !Buffer.isBuffer(item);\nconst iterator = function iterator() {\n    let index = 0;\n    const properties = Object.keys(this);\n    let Done = false;\n    return {\n        next: () => {\n            Done = index >= properties.length;\n            const obj = {\n                done: Done,\n                value: { value: this[properties[index]], key: properties[index] },\n            };\n            index += 1;\n            return obj;\n        },\n    };\n};\nexports.iterator = iterator;\nconst recursiveTypeCast = (mode, object, schema, dataPath) => {\n    var _a;\n    for (const { key, value } of object) {\n        if (isObject(value)) {\n            dataPath.push(key);\n            value[Symbol.iterator] = exports.iterator;\n            exports.recursiveTypeCast(mode, value, schema, dataPath);\n            dataPath.pop();\n            delete value[Symbol.iterator];\n        }\n        else if (Array.isArray(value)) {\n            dataPath.push(key);\n            const schemaProp = findObjectByPath(schema, dataPath);\n            if (((_a = schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) === null || _a === void 0 ? void 0 : _a.type) === 'object') {\n                for (let i = 0; i < value.length; i += 1) {\n                    const arrayObject = value[i];\n                    arrayObject[Symbol.iterator] = exports.iterator;\n                    exports.recursiveTypeCast(mode, arrayObject, schema, dataPath);\n                    delete arrayObject[Symbol.iterator];\n                }\n            }\n            else {\n                for (let i = 0; i < value.length; i += 1) {\n                    if (schemaProp === undefined || schemaProp.items === undefined) {\n                        throw new Error(`Invalid schema property found. Path: ${dataPath.join(',')}`);\n                    }\n                    object[key][i] = mappers[mode][schemaProp.items.dataType](value[i]);\n                }\n            }\n            dataPath.pop();\n        }\n        else {\n            dataPath.push(key);\n            const schemaProp = findObjectByPath(schema, dataPath);\n            if (schemaProp === undefined) {\n                throw new Error(`Invalid schema property found. Path: ${dataPath.join(',')}`);\n            }\n            object[key] = mappers[mode][schemaProp.dataType](value);\n            delete object[Symbol.iterator];\n            dataPath.pop();\n        }\n    }\n    delete object[Symbol.iterator];\n};\nexports.recursiveTypeCast = recursiveTypeCast;\n//# sourceMappingURL=json_wrapper.js.map"]},"metadata":{},"sourceType":"script"}