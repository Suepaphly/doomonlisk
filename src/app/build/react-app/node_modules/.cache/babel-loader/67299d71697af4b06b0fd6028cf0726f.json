{"ast":null,"code":"\"use strict\";\n\nvar MemoryStore = require(\"./memory-store\");\n\nfunction RateLimit(options) {\n  options = Object.assign({\n    windowMs: 60 * 1000,\n    // milliseconds - how long to keep records of requests in memory\n    max: 5,\n    // max number of recent connections during `window` milliseconds before sending a 429 response\n    message: \"Too many requests, please try again later.\",\n    statusCode: 429,\n    // 429 status = Too Many Requests (RFC 6585)\n    headers: true,\n    //Send custom rate limit header with limit and remaining\n    draft_polli_ratelimit_headers: false,\n    //Support for the new RateLimit standardization headers\n    skipFailedRequests: false,\n    // Do not count failed requests (status >= 400)\n    skipSuccessfulRequests: false,\n    // Do not count successful requests (status < 400)\n    // allows to create custom keys (by default user IP is used)\n    keyGenerator: function keyGenerator(req\n    /*, res*/\n    ) {\n      return req.ip;\n    },\n    skip: function skip() {\n      return false;\n    },\n    handler: function handler(req, res\n    /*, next*/\n    ) {\n      res.status(options.statusCode).send(options.message);\n    },\n    onLimitReached: function onLimitReached() {}\n  }, options); // store to use for persisting rate limit data\n\n  options.store = options.store || new MemoryStore(options.windowMs); // ensure that the store has the incr method\n\n  if (typeof options.store.incr !== \"function\" || typeof options.store.resetKey !== \"function\" || options.skipFailedRequests && typeof options.store.decrement !== \"function\") {\n    throw new Error(\"The store is not valid.\");\n  }\n\n  [\"global\", \"delayMs\", \"delayAfter\"].forEach(function (key) {\n    // note: this doesn't trigger if delayMs or delayAfter are set to 0, because that essentially disables them\n    if (options[key]) {\n      throw new Error(\"The \".concat(key, \" option was removed from express-rate-limit v3.\"));\n    }\n  });\n\n  function rateLimit(req, res, next) {\n    if (options.skip(req, res)) {\n      return next();\n    }\n\n    var key = options.keyGenerator(req, res);\n    options.store.incr(key, function (err, current, resetTime) {\n      if (err) {\n        return next(err);\n      }\n\n      var maxResult = typeof options.max === \"function\" ? options.max(req, res) : options.max;\n      Promise.resolve(maxResult).then(function (max) {\n        req.rateLimit = {\n          limit: max,\n          current: current,\n          remaining: Math.max(max - current, 0),\n          resetTime: resetTime\n        };\n\n        if (options.headers && !res.headersSent) {\n          res.setHeader(\"X-RateLimit-Limit\", max);\n          res.setHeader(\"X-RateLimit-Remaining\", req.rateLimit.remaining);\n\n          if (resetTime instanceof Date) {\n            // if we have a resetTime, also provide the current date to help avoid issues with incorrect clocks\n            res.setHeader(\"Date\", new Date().toGMTString());\n            res.setHeader(\"X-RateLimit-Reset\", Math.ceil(resetTime.getTime() / 1000));\n          }\n        }\n\n        if (options.draft_polli_ratelimit_headers && !res.headersSent) {\n          res.setHeader(\"RateLimit-Limit\", max);\n          res.setHeader(\"RateLimit-Remaining\", req.rateLimit.remaining);\n\n          if (resetTime) {\n            var deltaSeconds = Math.ceil((resetTime.getTime() - Date.now()) / 1000);\n            res.setHeader(\"RateLimit-Reset\", Math.max(0, deltaSeconds));\n          }\n        }\n\n        if (options.skipFailedRequests || options.skipSuccessfulRequests) {\n          var decremented = false;\n\n          var decrementKey = function decrementKey() {\n            if (!decremented) {\n              options.store.decrement(key);\n              decremented = true;\n            }\n          };\n\n          if (options.skipFailedRequests) {\n            res.on(\"finish\", function () {\n              if (res.statusCode >= 400) {\n                decrementKey();\n              }\n            });\n            res.on(\"close\", function () {\n              if (!res.finished) {\n                decrementKey();\n              }\n            });\n            res.on(\"error\", function () {\n              return decrementKey();\n            });\n          }\n\n          if (options.skipSuccessfulRequests) {\n            res.on(\"finish\", function () {\n              if (res.statusCode < 400) {\n                options.store.decrement(key);\n              }\n            });\n          }\n        }\n\n        if (max && current === max + 1) {\n          options.onLimitReached(req, res, options);\n        }\n\n        if (max && current > max) {\n          if (options.headers && !res.headersSent) {\n            res.setHeader(\"Retry-After\", Math.ceil(options.windowMs / 1000));\n          }\n\n          return options.handler(req, res, next);\n        }\n\n        next();\n      }).catch(next);\n    });\n  }\n\n  rateLimit.resetKey = options.store.resetKey.bind(options.store); // Backward compatibility function\n\n  rateLimit.resetIp = rateLimit.resetKey;\n  return rateLimit;\n}\n\nmodule.exports = RateLimit;","map":{"version":3,"sources":["/home/lisk/doomonlisk/node_modules/express-rate-limit/lib/express-rate-limit.js"],"names":["MemoryStore","require","RateLimit","options","Object","assign","windowMs","max","message","statusCode","headers","draft_polli_ratelimit_headers","skipFailedRequests","skipSuccessfulRequests","keyGenerator","req","ip","skip","handler","res","status","send","onLimitReached","store","incr","resetKey","decrement","Error","forEach","key","rateLimit","next","err","current","resetTime","maxResult","Promise","resolve","then","limit","remaining","Math","headersSent","setHeader","Date","toGMTString","ceil","getTime","deltaSeconds","now","decremented","decrementKey","on","finished","catch","bind","resetIp","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\nconst MemoryStore = require(\"./memory-store\");\n\nfunction RateLimit(options) {\n  options = Object.assign(\n    {\n      windowMs: 60 * 1000, // milliseconds - how long to keep records of requests in memory\n      max: 5, // max number of recent connections during `window` milliseconds before sending a 429 response\n      message: \"Too many requests, please try again later.\",\n      statusCode: 429, // 429 status = Too Many Requests (RFC 6585)\n      headers: true, //Send custom rate limit header with limit and remaining\n      draft_polli_ratelimit_headers: false, //Support for the new RateLimit standardization headers\n      skipFailedRequests: false, // Do not count failed requests (status >= 400)\n      skipSuccessfulRequests: false, // Do not count successful requests (status < 400)\n      // allows to create custom keys (by default user IP is used)\n      keyGenerator: function (req /*, res*/) {\n        return req.ip;\n      },\n      skip: function (/*req, res*/) {\n        return false;\n      },\n      handler: function (req, res /*, next*/) {\n        res.status(options.statusCode).send(options.message);\n      },\n      onLimitReached: function (/*req, res, optionsUsed*/) {},\n    },\n    options\n  );\n\n  // store to use for persisting rate limit data\n  options.store = options.store || new MemoryStore(options.windowMs);\n\n  // ensure that the store has the incr method\n  if (\n    typeof options.store.incr !== \"function\" ||\n    typeof options.store.resetKey !== \"function\" ||\n    (options.skipFailedRequests &&\n      typeof options.store.decrement !== \"function\")\n  ) {\n    throw new Error(\"The store is not valid.\");\n  }\n\n  [\"global\", \"delayMs\", \"delayAfter\"].forEach((key) => {\n    // note: this doesn't trigger if delayMs or delayAfter are set to 0, because that essentially disables them\n    if (options[key]) {\n      throw new Error(\n        `The ${key} option was removed from express-rate-limit v3.`\n      );\n    }\n  });\n\n  function rateLimit(req, res, next) {\n    if (options.skip(req, res)) {\n      return next();\n    }\n\n    const key = options.keyGenerator(req, res);\n\n    options.store.incr(key, function (err, current, resetTime) {\n      if (err) {\n        return next(err);\n      }\n\n      const maxResult =\n        typeof options.max === \"function\" ? options.max(req, res) : options.max;\n\n      Promise.resolve(maxResult)\n        .then((max) => {\n          req.rateLimit = {\n            limit: max,\n            current: current,\n            remaining: Math.max(max - current, 0),\n            resetTime: resetTime,\n          };\n\n          if (options.headers && !res.headersSent) {\n            res.setHeader(\"X-RateLimit-Limit\", max);\n            res.setHeader(\"X-RateLimit-Remaining\", req.rateLimit.remaining);\n            if (resetTime instanceof Date) {\n              // if we have a resetTime, also provide the current date to help avoid issues with incorrect clocks\n              res.setHeader(\"Date\", new Date().toGMTString());\n              res.setHeader(\n                \"X-RateLimit-Reset\",\n                Math.ceil(resetTime.getTime() / 1000)\n              );\n            }\n          }\n          if (options.draft_polli_ratelimit_headers && !res.headersSent) {\n            res.setHeader(\"RateLimit-Limit\", max);\n            res.setHeader(\"RateLimit-Remaining\", req.rateLimit.remaining);\n            if (resetTime) {\n              const deltaSeconds = Math.ceil(\n                (resetTime.getTime() - Date.now()) / 1000\n              );\n              res.setHeader(\"RateLimit-Reset\", Math.max(0, deltaSeconds));\n            }\n          }\n\n          if (options.skipFailedRequests || options.skipSuccessfulRequests) {\n            let decremented = false;\n            const decrementKey = () => {\n              if (!decremented) {\n                options.store.decrement(key);\n                decremented = true;\n              }\n            };\n\n            if (options.skipFailedRequests) {\n              res.on(\"finish\", function () {\n                if (res.statusCode >= 400) {\n                  decrementKey();\n                }\n              });\n\n              res.on(\"close\", () => {\n                if (!res.finished) {\n                  decrementKey();\n                }\n              });\n\n              res.on(\"error\", () => decrementKey());\n            }\n\n            if (options.skipSuccessfulRequests) {\n              res.on(\"finish\", function () {\n                if (res.statusCode < 400) {\n                  options.store.decrement(key);\n                }\n              });\n            }\n          }\n\n          if (max && current === max + 1) {\n            options.onLimitReached(req, res, options);\n          }\n\n          if (max && current > max) {\n            if (options.headers && !res.headersSent) {\n              res.setHeader(\"Retry-After\", Math.ceil(options.windowMs / 1000));\n            }\n            return options.handler(req, res, next);\n          }\n\n          next();\n        })\n        .catch(next);\n    });\n  }\n\n  rateLimit.resetKey = options.store.resetKey.bind(options.store);\n\n  // Backward compatibility function\n  rateLimit.resetIp = rateLimit.resetKey;\n\n  return rateLimit;\n}\n\nmodule.exports = RateLimit;\n"]},"metadata":{},"sourceType":"script"}