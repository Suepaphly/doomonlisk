{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.signMultiSignatureTransactionWithPrivateKey = exports.signTransactionWithPrivateKey = exports.signMultiSignatureTransaction = exports.signTransaction = exports.getBytes = exports.getSigningBytes = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar validate_1 = require(\"./validate\");\n\nvar schema_1 = require(\"./schema\");\n\nvar getSigningBytes = function getSigningBytes(assetSchema, transactionObject) {\n  var validationErrors = validate_1.validateTransaction(assetSchema, transactionObject);\n\n  if (validationErrors) {\n    throw validationErrors;\n  }\n\n  if (typeof transactionObject.asset !== 'object' || transactionObject.asset === null) {\n    throw new Error('Asset must be of type object and not null');\n  }\n\n  var assetBytes = lisk_codec_1.codec.encode(assetSchema, transactionObject.asset);\n  var transactionBytes = lisk_codec_1.codec.encode(schema_1.baseTransactionSchema, _objectSpread(_objectSpread({}, transactionObject), {}, {\n    asset: assetBytes,\n    signatures: []\n  }));\n  return transactionBytes;\n};\n\nexports.getSigningBytes = getSigningBytes;\n\nvar getBytes = function getBytes(assetSchema, transactionObject) {\n  if (typeof transactionObject.asset !== 'object' || transactionObject.asset === null) {\n    throw new Error('Asset must be of type object and not null');\n  }\n\n  var assetBytes = lisk_codec_1.codec.encode(assetSchema, transactionObject.asset);\n  var transactionBytes = lisk_codec_1.codec.encode(schema_1.baseTransactionSchema, _objectSpread(_objectSpread({}, transactionObject), {}, {\n    asset: assetBytes\n  }));\n  return transactionBytes;\n};\n\nexports.getBytes = getBytes;\n\nvar signTransaction = function signTransaction(assetSchema, transactionObject, networkIdentifier, passphrase) {\n  if (!networkIdentifier.length) {\n    throw new Error('Network identifier is required to sign a transaction');\n  }\n\n  if (!passphrase) {\n    throw new Error('Passphrase is required to sign a transaction');\n  }\n\n  var validationErrors = validate_1.validateTransaction(assetSchema, transactionObject);\n\n  if (validationErrors) {\n    throw validationErrors;\n  }\n\n  var _lisk_cryptography_1$ = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase),\n      publicKey = _lisk_cryptography_1$.publicKey;\n\n  if (!Buffer.isBuffer(transactionObject.senderPublicKey) || !transactionObject.senderPublicKey.equals(publicKey)) {\n    throw new Error('Transaction senderPublicKey does not match public key from passphrase');\n  }\n\n  var transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifier, exports.getSigningBytes(assetSchema, transactionObject)]);\n  var signature = lisk_cryptography_1.signData(transactionWithNetworkIdentifierBytes, passphrase);\n  transactionObject.signatures = [signature];\n  return _objectSpread(_objectSpread({}, transactionObject), {}, {\n    id: lisk_cryptography_1.hash(exports.getBytes(assetSchema, transactionObject))\n  });\n};\n\nexports.signTransaction = signTransaction;\n\nvar sanitizeSignaturesArray = function sanitizeSignaturesArray(transactionObject, keys, includeSenderSignature) {\n  var numberOfSignatures = (includeSenderSignature ? 1 : 0) + keys.mandatoryKeys.length + keys.optionalKeys.length;\n\n  for (var i = 0; i < numberOfSignatures; i += 1) {\n    if (Array.isArray(transactionObject.signatures) && transactionObject.signatures[i] === undefined) {\n      transactionObject.signatures[i] = Buffer.alloc(0);\n    }\n  }\n};\n\nvar signMultiSignatureTransaction = function signMultiSignatureTransaction(assetSchema, transactionObject, networkIdentifier, passphrase, keys) {\n  var includeSenderSignature = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  if (!networkIdentifier.length) {\n    throw new Error('Network identifier is required to sign a transaction');\n  }\n\n  if (!passphrase) {\n    throw new Error('Passphrase is required to sign a transaction');\n  }\n\n  if (!Array.isArray(transactionObject.signatures)) {\n    throw new Error('Signatures must be of type array');\n  }\n\n  var validationErrors = validate_1.validateTransaction(assetSchema, transactionObject);\n\n  if (validationErrors) {\n    throw validationErrors;\n  }\n\n  keys.mandatoryKeys.sort(function (publicKeyA, publicKeyB) {\n    return publicKeyA.compare(publicKeyB);\n  });\n  keys.optionalKeys.sort(function (publicKeyA, publicKeyB) {\n    return publicKeyA.compare(publicKeyB);\n  });\n\n  var _lisk_cryptography_1$2 = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase),\n      publicKey = _lisk_cryptography_1$2.publicKey;\n\n  var transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifier, exports.getSigningBytes(assetSchema, transactionObject)]);\n  var signature = lisk_cryptography_1.signData(transactionWithNetworkIdentifierBytes, passphrase);\n\n  if (includeSenderSignature && Buffer.isBuffer(transactionObject.senderPublicKey) && publicKey.equals(transactionObject.senderPublicKey)) {\n    transactionObject.signatures[0] = signature;\n  }\n\n  var mandatoryKeyIndex = keys.mandatoryKeys.findIndex(function (aPublicKey) {\n    return aPublicKey.equals(publicKey);\n  });\n  var optionalKeyIndex = keys.optionalKeys.findIndex(function (aPublicKey) {\n    return aPublicKey.equals(publicKey);\n  });\n\n  if (mandatoryKeyIndex !== -1) {\n    var signatureOffset = includeSenderSignature ? 1 : 0;\n    transactionObject.signatures[mandatoryKeyIndex + signatureOffset] = signature;\n  }\n\n  if (optionalKeyIndex !== -1) {\n    var _signatureOffset = includeSenderSignature ? 1 : 0;\n\n    transactionObject.signatures[keys.mandatoryKeys.length + optionalKeyIndex + _signatureOffset] = signature;\n  }\n\n  sanitizeSignaturesArray(transactionObject, keys, includeSenderSignature);\n  return _objectSpread(_objectSpread({}, transactionObject), {}, {\n    id: lisk_cryptography_1.hash(exports.getBytes(assetSchema, transactionObject))\n  });\n};\n\nexports.signMultiSignatureTransaction = signMultiSignatureTransaction;\n\nvar signTransactionWithPrivateKey = function signTransactionWithPrivateKey(assetSchema, transactionObject, networkIdentifier, privateKey) {\n  if (!networkIdentifier.length) {\n    throw new Error('Network identifier is required to sign a transaction');\n  }\n\n  if (!privateKey.length || privateKey.length !== 64) {\n    throw new Error('Private key must be 64 bytes');\n  }\n\n  var validationErrors = validate_1.validateTransaction(assetSchema, transactionObject);\n\n  if (validationErrors) {\n    throw validationErrors;\n  }\n\n  var transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifier, exports.getSigningBytes(assetSchema, transactionObject)]);\n  var signature = lisk_cryptography_1.signDataWithPrivateKey(transactionWithNetworkIdentifierBytes, privateKey);\n  transactionObject.signatures = [signature];\n  return _objectSpread(_objectSpread({}, transactionObject), {}, {\n    id: lisk_cryptography_1.hash(exports.getBytes(assetSchema, transactionObject))\n  });\n};\n\nexports.signTransactionWithPrivateKey = signTransactionWithPrivateKey;\n\nvar signMultiSignatureTransactionWithPrivateKey = function signMultiSignatureTransactionWithPrivateKey(assetSchema, transactionObject, networkIdentifier, privateKey, keys) {\n  var includeSenderSignature = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n  if (!networkIdentifier.length) {\n    throw new Error('Network identifier is required to sign a transaction');\n  }\n\n  if (!privateKey.length || privateKey.length !== 64) {\n    throw new Error('Private key must be 64 bytes');\n  }\n\n  if (!Array.isArray(transactionObject.signatures)) {\n    throw new Error('Signatures must be of type array');\n  }\n\n  var validationErrors = validate_1.validateTransaction(assetSchema, transactionObject);\n\n  if (validationErrors) {\n    throw validationErrors;\n  }\n\n  var publicKey = transactionObject.senderPublicKey;\n  keys.mandatoryKeys.sort(function (publicKeyA, publicKeyB) {\n    return publicKeyA.compare(publicKeyB);\n  });\n  keys.optionalKeys.sort(function (publicKeyA, publicKeyB) {\n    return publicKeyA.compare(publicKeyB);\n  });\n  var transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifier, exports.getSigningBytes(assetSchema, transactionObject)]);\n  var signature = lisk_cryptography_1.signDataWithPrivateKey(transactionWithNetworkIdentifierBytes, privateKey);\n\n  if (includeSenderSignature && Buffer.isBuffer(transactionObject.senderPublicKey)) {\n    transactionObject.signatures[0] = signature;\n  }\n\n  var mandatoryKeyIndex = keys.mandatoryKeys.findIndex(function (aPublicKey) {\n    return aPublicKey.equals(publicKey);\n  });\n  var optionalKeyIndex = keys.optionalKeys.findIndex(function (aPublicKey) {\n    return aPublicKey.equals(publicKey);\n  });\n\n  if (mandatoryKeyIndex !== -1) {\n    var signatureOffset = includeSenderSignature ? 1 : 0;\n    transactionObject.signatures[mandatoryKeyIndex + signatureOffset] = signature;\n  }\n\n  if (optionalKeyIndex !== -1) {\n    var _signatureOffset2 = includeSenderSignature ? 1 : 0;\n\n    transactionObject.signatures[keys.mandatoryKeys.length + optionalKeyIndex + _signatureOffset2] = signature;\n  }\n\n  sanitizeSignaturesArray(transactionObject, keys, includeSenderSignature);\n  return _objectSpread(_objectSpread({}, transactionObject), {}, {\n    id: lisk_cryptography_1.hash(exports.getBytes(assetSchema, transactionObject))\n  });\n};\n\nexports.signMultiSignatureTransactionWithPrivateKey = signMultiSignatureTransactionWithPrivateKey;","map":{"version":3,"sources":["../src/sign.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.signMultiSignatureTransactionWithPrivateKey = exports.signTransactionWithPrivateKey = exports.signMultiSignatureTransaction = exports.signTransaction = exports.getBytes = exports.getSigningBytes = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst validate_1 = require(\"./validate\");\nconst schema_1 = require(\"./schema\");\nconst getSigningBytes = (assetSchema, transactionObject) => {\n    const validationErrors = validate_1.validateTransaction(assetSchema, transactionObject);\n    if (validationErrors) {\n        throw validationErrors;\n    }\n    if (typeof transactionObject.asset !== 'object' || transactionObject.asset === null) {\n        throw new Error('Asset must be of type object and not null');\n    }\n    const assetBytes = lisk_codec_1.codec.encode(assetSchema, transactionObject.asset);\n    const transactionBytes = lisk_codec_1.codec.encode(schema_1.baseTransactionSchema, {\n        ...transactionObject,\n        asset: assetBytes,\n        signatures: [],\n    });\n    return transactionBytes;\n};\nexports.getSigningBytes = getSigningBytes;\nconst getBytes = (assetSchema, transactionObject) => {\n    if (typeof transactionObject.asset !== 'object' || transactionObject.asset === null) {\n        throw new Error('Asset must be of type object and not null');\n    }\n    const assetBytes = lisk_codec_1.codec.encode(assetSchema, transactionObject.asset);\n    const transactionBytes = lisk_codec_1.codec.encode(schema_1.baseTransactionSchema, {\n        ...transactionObject,\n        asset: assetBytes,\n    });\n    return transactionBytes;\n};\nexports.getBytes = getBytes;\nconst signTransaction = (assetSchema, transactionObject, networkIdentifier, passphrase) => {\n    if (!networkIdentifier.length) {\n        throw new Error('Network identifier is required to sign a transaction');\n    }\n    if (!passphrase) {\n        throw new Error('Passphrase is required to sign a transaction');\n    }\n    const validationErrors = validate_1.validateTransaction(assetSchema, transactionObject);\n    if (validationErrors) {\n        throw validationErrors;\n    }\n    const { publicKey } = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase);\n    if (!Buffer.isBuffer(transactionObject.senderPublicKey) ||\n        !transactionObject.senderPublicKey.equals(publicKey)) {\n        throw new Error('Transaction senderPublicKey does not match public key from passphrase');\n    }\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([\n        networkIdentifier,\n        exports.getSigningBytes(assetSchema, transactionObject),\n    ]);\n    const signature = lisk_cryptography_1.signData(transactionWithNetworkIdentifierBytes, passphrase);\n    transactionObject.signatures = [signature];\n    return { ...transactionObject, id: lisk_cryptography_1.hash(exports.getBytes(assetSchema, transactionObject)) };\n};\nexports.signTransaction = signTransaction;\nconst sanitizeSignaturesArray = (transactionObject, keys, includeSenderSignature) => {\n    const numberOfSignatures = (includeSenderSignature ? 1 : 0) + keys.mandatoryKeys.length + keys.optionalKeys.length;\n    for (let i = 0; i < numberOfSignatures; i += 1) {\n        if (Array.isArray(transactionObject.signatures) &&\n            transactionObject.signatures[i] === undefined) {\n            transactionObject.signatures[i] = Buffer.alloc(0);\n        }\n    }\n};\nconst signMultiSignatureTransaction = (assetSchema, transactionObject, networkIdentifier, passphrase, keys, includeSenderSignature = false) => {\n    if (!networkIdentifier.length) {\n        throw new Error('Network identifier is required to sign a transaction');\n    }\n    if (!passphrase) {\n        throw new Error('Passphrase is required to sign a transaction');\n    }\n    if (!Array.isArray(transactionObject.signatures)) {\n        throw new Error('Signatures must be of type array');\n    }\n    const validationErrors = validate_1.validateTransaction(assetSchema, transactionObject);\n    if (validationErrors) {\n        throw validationErrors;\n    }\n    keys.mandatoryKeys.sort((publicKeyA, publicKeyB) => publicKeyA.compare(publicKeyB));\n    keys.optionalKeys.sort((publicKeyA, publicKeyB) => publicKeyA.compare(publicKeyB));\n    const { publicKey } = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase);\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([\n        networkIdentifier,\n        exports.getSigningBytes(assetSchema, transactionObject),\n    ]);\n    const signature = lisk_cryptography_1.signData(transactionWithNetworkIdentifierBytes, passphrase);\n    if (includeSenderSignature &&\n        Buffer.isBuffer(transactionObject.senderPublicKey) &&\n        publicKey.equals(transactionObject.senderPublicKey)) {\n        transactionObject.signatures[0] = signature;\n    }\n    const mandatoryKeyIndex = keys.mandatoryKeys.findIndex(aPublicKey => aPublicKey.equals(publicKey));\n    const optionalKeyIndex = keys.optionalKeys.findIndex(aPublicKey => aPublicKey.equals(publicKey));\n    if (mandatoryKeyIndex !== -1) {\n        const signatureOffset = includeSenderSignature ? 1 : 0;\n        transactionObject.signatures[mandatoryKeyIndex + signatureOffset] = signature;\n    }\n    if (optionalKeyIndex !== -1) {\n        const signatureOffset = includeSenderSignature ? 1 : 0;\n        transactionObject.signatures[keys.mandatoryKeys.length + optionalKeyIndex + signatureOffset] = signature;\n    }\n    sanitizeSignaturesArray(transactionObject, keys, includeSenderSignature);\n    return { ...transactionObject, id: lisk_cryptography_1.hash(exports.getBytes(assetSchema, transactionObject)) };\n};\nexports.signMultiSignatureTransaction = signMultiSignatureTransaction;\nconst signTransactionWithPrivateKey = (assetSchema, transactionObject, networkIdentifier, privateKey) => {\n    if (!networkIdentifier.length) {\n        throw new Error('Network identifier is required to sign a transaction');\n    }\n    if (!privateKey.length || privateKey.length !== 64) {\n        throw new Error('Private key must be 64 bytes');\n    }\n    const validationErrors = validate_1.validateTransaction(assetSchema, transactionObject);\n    if (validationErrors) {\n        throw validationErrors;\n    }\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([\n        networkIdentifier,\n        exports.getSigningBytes(assetSchema, transactionObject),\n    ]);\n    const signature = lisk_cryptography_1.signDataWithPrivateKey(transactionWithNetworkIdentifierBytes, privateKey);\n    transactionObject.signatures = [signature];\n    return { ...transactionObject, id: lisk_cryptography_1.hash(exports.getBytes(assetSchema, transactionObject)) };\n};\nexports.signTransactionWithPrivateKey = signTransactionWithPrivateKey;\nconst signMultiSignatureTransactionWithPrivateKey = (assetSchema, transactionObject, networkIdentifier, privateKey, keys, includeSenderSignature = false) => {\n    if (!networkIdentifier.length) {\n        throw new Error('Network identifier is required to sign a transaction');\n    }\n    if (!privateKey.length || privateKey.length !== 64) {\n        throw new Error('Private key must be 64 bytes');\n    }\n    if (!Array.isArray(transactionObject.signatures)) {\n        throw new Error('Signatures must be of type array');\n    }\n    const validationErrors = validate_1.validateTransaction(assetSchema, transactionObject);\n    if (validationErrors) {\n        throw validationErrors;\n    }\n    const { senderPublicKey: publicKey } = transactionObject;\n    keys.mandatoryKeys.sort((publicKeyA, publicKeyB) => publicKeyA.compare(publicKeyB));\n    keys.optionalKeys.sort((publicKeyA, publicKeyB) => publicKeyA.compare(publicKeyB));\n    const transactionWithNetworkIdentifierBytes = Buffer.concat([\n        networkIdentifier,\n        exports.getSigningBytes(assetSchema, transactionObject),\n    ]);\n    const signature = lisk_cryptography_1.signDataWithPrivateKey(transactionWithNetworkIdentifierBytes, privateKey);\n    if (includeSenderSignature && Buffer.isBuffer(transactionObject.senderPublicKey)) {\n        transactionObject.signatures[0] = signature;\n    }\n    const mandatoryKeyIndex = keys.mandatoryKeys.findIndex(aPublicKey => aPublicKey.equals(publicKey));\n    const optionalKeyIndex = keys.optionalKeys.findIndex(aPublicKey => aPublicKey.equals(publicKey));\n    if (mandatoryKeyIndex !== -1) {\n        const signatureOffset = includeSenderSignature ? 1 : 0;\n        transactionObject.signatures[mandatoryKeyIndex + signatureOffset] = signature;\n    }\n    if (optionalKeyIndex !== -1) {\n        const signatureOffset = includeSenderSignature ? 1 : 0;\n        transactionObject.signatures[keys.mandatoryKeys.length + optionalKeyIndex + signatureOffset] = signature;\n    }\n    sanitizeSignaturesArray(transactionObject, keys, includeSenderSignature);\n    return { ...transactionObject, id: lisk_cryptography_1.hash(exports.getBytes(assetSchema, transactionObject)) };\n};\nexports.signMultiSignatureTransactionWithPrivateKey = signMultiSignatureTransactionWithPrivateKey;\n//# sourceMappingURL=sign.js.map"]},"metadata":{},"sourceType":"script"}