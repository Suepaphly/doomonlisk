{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar error = {\n  message: function message(_ref) {\n    var _ref$params = _ref.params,\n        min = _ref$params.min,\n        max = _ref$params.max;\n    return max === undefined ? codegen_1.str(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must contain at least \", \" valid item(s)\"])), min) : codegen_1.str(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"must contain at least \", \" and no more than \", \" valid item(s)\"])), min, max);\n  },\n  params: function params(_ref2) {\n    var _ref2$params = _ref2.params,\n        min = _ref2$params.min,\n        max = _ref2$params.max;\n    return max === undefined ? codegen_1._(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"{minContains: \", \"}\"])), min) : codegen_1._(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"{minContains: \", \", maxContains: \", \"}\"])), min, max);\n  }\n};\nvar def = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        schema = cxt.schema,\n        parentSchema = cxt.parentSchema,\n        data = cxt.data,\n        it = cxt.it;\n    var min;\n    var max;\n    var minContains = parentSchema.minContains,\n        maxContains = parentSchema.maxContains;\n\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains;\n      max = maxContains;\n    } else {\n      min = 1;\n    }\n\n    var len = gen.const(\"len\", codegen_1._(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \".length\"])), data));\n    cxt.setParams({\n      min: min,\n      max: max\n    });\n\n    if (max === undefined && min === 0) {\n      util_1.checkStrictMode(it, \"\\\"minContains\\\" == 0 without \\\"maxContains\\\": \\\"contains\\\" keyword ignored\");\n      return;\n    }\n\n    if (max !== undefined && min > max) {\n      util_1.checkStrictMode(it, \"\\\"minContains\\\" > \\\"maxContains\\\" is always invalid\");\n      cxt.fail();\n      return;\n    }\n\n    if (util_1.alwaysValidSchema(it, schema)) {\n      var cond = codegen_1._(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \" >= \", \"\"])), len, min);\n\n      if (max !== undefined) cond = codegen_1._(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \" && \", \" <= \", \"\"])), cond, len, max);\n      cxt.pass(cond);\n      return;\n    }\n\n    it.items = true;\n    var valid = gen.name(\"valid\");\n\n    if (max === undefined && min === 1) {\n      validateItems(valid, function () {\n        return gen.if(valid, function () {\n          return gen.break();\n        });\n      });\n    } else {\n      gen.let(valid, false);\n      var schValid = gen.name(\"_valid\");\n      var count = gen.let(\"count\", 0);\n      validateItems(schValid, function () {\n        return gen.if(schValid, function () {\n          return checkLimits(count);\n        });\n      });\n    }\n\n    cxt.result(valid, function () {\n      return cxt.reset();\n    });\n\n    function validateItems(_valid, block) {\n      gen.forRange(\"i\", 0, len, function (i) {\n        cxt.subschema({\n          keyword: \"contains\",\n          dataProp: i,\n          dataPropType: util_1.Type.Num,\n          compositeRule: true\n        }, _valid);\n        block();\n      });\n    }\n\n    function checkLimits(count) {\n      gen.code(codegen_1._(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \"++\"])), count));\n\n      if (max === undefined) {\n        gen.if(codegen_1._(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \" >= \", \"\"])), count, min), function () {\n          return gen.assign(valid, true).break();\n        });\n      } else {\n        gen.if(codegen_1._(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \" > \", \"\"])), count, max), function () {\n          return gen.assign(valid, false).break();\n        });\n        if (min === 1) gen.assign(valid, true);else gen.if(codegen_1._(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\", \" >= \", \"\"])), count, min), function () {\n          return gen.assign(valid, true);\n        });\n      }\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/contains.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? codegen_1.str `must contain at least ${min} valid item(s)`\n        : codegen_1.str `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? codegen_1._ `{minContains: ${min}}` : codegen_1._ `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const(\"len\", codegen_1._ `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            util_1.checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            util_1.checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if (util_1.alwaysValidSchema(it, schema)) {\n            let cond = codegen_1._ `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = codegen_1._ `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name(\"valid\");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else {\n            gen.let(valid, false);\n            const schValid = gen.name(\"_valid\");\n            const count = gen.let(\"count\", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItems(_valid, block) {\n            gen.forRange(\"i\", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: \"contains\",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code(codegen_1._ `${count}++`);\n            if (max === undefined) {\n                gen.if(codegen_1._ `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if(codegen_1._ `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if(codegen_1._ `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=contains.js.map"]},"metadata":{},"sourceType":"script"}