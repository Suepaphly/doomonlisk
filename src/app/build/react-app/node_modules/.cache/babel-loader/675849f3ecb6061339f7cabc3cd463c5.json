{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Peer = exports.ConnectionState = exports.RATE_NORMALIZATION_FACTOR = exports.socketErrorStatusCodes = void 0;\n\nvar events_1 = require(\"events\");\n\nvar socketClusterClient = require(\"socketcluster-client\");\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar constants_1 = require(\"../constants\");\n\nvar errors_1 = require(\"../errors\");\n\nvar events_2 = require(\"../events\");\n\nvar p2p_request_1 = require(\"../p2p_request\");\n\nvar utils_1 = require(\"../utils\");\n\nvar codec_1 = require(\"../utils/codec\");\n\nexports.socketErrorStatusCodes = _objectSpread(_objectSpread({}, socketClusterClient.SCClientSocket.errorStatuses), {}, {\n  1000: 'Intentionally disconnected'\n});\nexports.RATE_NORMALIZATION_FACTOR = 1000;\nvar PEER_STATUS_MESSAGE_RATE_INTERVAL = 10000;\nvar ConnectionState;\n\n(function (ConnectionState) {\n  ConnectionState[\"CONNECTING\"] = \"connecting\";\n  ConnectionState[\"OPEN\"] = \"open\";\n  ConnectionState[\"CLOSED\"] = \"closed\";\n})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));\n\nvar Peer = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Peer, _events_1$EventEmitte);\n\n  var _super = _createSuper(Peer);\n\n  function Peer(peerInfo, peerConfig) {\n    var _this;\n\n    _classCallCheck(this, Peer);\n\n    _this = _super.call(this);\n    _this._peerConfig = peerConfig;\n    _this._rpcSchemas = peerConfig.rpcSchemas;\n    _this._peerInfo = _this._initializeInternalState(peerInfo);\n    _this._rateInterval = _this._peerConfig.rateCalculationInterval;\n    _this._counterResetInterval = setInterval(function () {\n      _this._resetCounters();\n    }, _this._rateInterval);\n    _this._productivityResetInterval = setInterval(function () {\n      _this._resetProductivity();\n    }, constants_1.DEFAULT_PRODUCTIVITY_RESET_INTERVAL);\n    _this._serverNodeInfo = peerConfig.serverNodeInfo;\n    _this._discoveryMessageCounter = {\n      getPeers: 0,\n      getNodeInfo: 0,\n      postNodeInfo: 0\n    };\n    _this._peerStatusMessageRate = peerConfig.peerStatusMessageRate;\n    _this._peerStatusRateInterval = setInterval(function () {\n      _this._resetStatusMessageRate();\n    }, PEER_STATUS_MESSAGE_RATE_INTERVAL);\n\n    _this._handleRawRPC = function (packet, respond) {\n      try {\n        utils_1.validateRPCRequest(packet);\n      } catch (error) {\n        respond(error);\n\n        _this.emit(events_2.EVENT_INVALID_REQUEST_RECEIVED, {\n          packet: packet,\n          peerId: _this._peerInfo.peerId\n        });\n\n        return;\n      }\n\n      var rawRequestPacket = packet;\n\n      if (rawRequestPacket.procedure === events_2.REMOTE_EVENT_RPC_GET_NODE_INFO) {\n        _this._discoveryMessageCounter.getNodeInfo += 1;\n\n        if (_this._discoveryMessageCounter.getNodeInfo > 1) {\n          _this.applyPenalty(10);\n        }\n      }\n\n      if (rawRequestPacket.procedure === events_2.REMOTE_EVENT_RPC_GET_PEERS_LIST) {\n        _this._discoveryMessageCounter.getPeers += 1;\n\n        if (_this._discoveryMessageCounter.getPeers > 1) {\n          _this.applyPenalty(10);\n        }\n      }\n\n      if (events_2.PROTOCOL_EVENTS_TO_RATE_LIMIT.has(rawRequestPacket.procedure) && _this._peerInfo.internalState.rpcCounter.has(rawRequestPacket.procedure)) {\n        _this._updateRPCCounter(rawRequestPacket);\n\n        return;\n      }\n\n      _this._updateRPCCounter(rawRequestPacket);\n\n      var rate = _this._getRPCRate(rawRequestPacket);\n\n      var request = new p2p_request_1.P2PRequest({\n        procedure: rawRequestPacket.procedure,\n        data: rawRequestPacket.data,\n        id: _this.peerInfo.peerId,\n        rate: rate,\n        productivity: _this.internalState.productivity\n      }, respond);\n\n      _this.emit(events_2.EVENT_REQUEST_RECEIVED, request);\n    };\n\n    _this._handleWSMessage = function () {\n      _this._peerInfo.internalState.wsMessageCount += 1;\n    };\n\n    _this._handleRawMessage = function (packet) {\n      try {\n        utils_1.validateProtocolMessage(packet);\n      } catch (error) {\n        _this.emit(events_2.EVENT_INVALID_MESSAGE_RECEIVED, {\n          packet: packet,\n          peerId: _this._peerInfo.peerId\n        });\n\n        return;\n      }\n\n      var message = packet;\n\n      _this._updateMessageCounter(message);\n\n      var rate = _this._getMessageRate(message);\n\n      var messageBufferData = _this._getBufferData(message.data);\n\n      if (message.event === events_2.REMOTE_EVENT_POST_NODE_INFO) {\n        _this._discoveryMessageCounter.postNodeInfo += 1;\n\n        if (_this._discoveryMessageCounter.postNodeInfo > _this._peerStatusMessageRate) {\n          _this.applyPenalty(10);\n        }\n\n        _this._handleUpdateNodeInfo(_objectSpread(_objectSpread({}, message), {}, {\n          data: messageBufferData\n        }));\n      }\n\n      var messageWithRateInfo = _objectSpread(_objectSpread({}, message), {}, {\n        data: messageBufferData,\n        peerId: _this._peerInfo.peerId,\n        rate: rate\n      });\n\n      _this.emit(events_2.EVENT_MESSAGE_RECEIVED, messageWithRateInfo);\n    };\n\n    return _this;\n  }\n\n  _createClass(Peer, [{\n    key: \"id\",\n    get: function get() {\n      return this._peerInfo.peerId;\n    }\n  }, {\n    key: \"ipAddress\",\n    get: function get() {\n      return this._peerInfo.ipAddress;\n    }\n  }, {\n    key: \"port\",\n    get: function get() {\n      return this._peerInfo.port;\n    }\n  }, {\n    key: \"internalState\",\n    get: function get() {\n      return this.peerInfo.internalState;\n    }\n  }, {\n    key: \"peerInfo\",\n    get: function get() {\n      return this._peerInfo;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      var state = this._socket ? this._socket.state === this._socket.OPEN ? ConnectionState.OPEN : ConnectionState.CLOSED : ConnectionState.CLOSED;\n      return state;\n    }\n  }, {\n    key: \"updateInternalState\",\n    value: function updateInternalState(internalState) {\n      this._peerInfo = _objectSpread(_objectSpread({}, this._peerInfo), {}, {\n        internalState: internalState\n      });\n    }\n  }, {\n    key: \"updatePeerInfo\",\n    value: function updatePeerInfo(newPeerInfo) {\n      this._peerInfo = {\n        sharedState: newPeerInfo.sharedState,\n        internalState: this._peerInfo.internalState,\n        ipAddress: this.ipAddress,\n        port: this.port,\n        peerId: this.id\n      };\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      if (!this._socket) {\n        throw new Error('Peer socket does not exist');\n      }\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : constants_1.INTENTIONAL_DISCONNECT_CODE;\n      var reason = arguments.length > 1 ? arguments[1] : undefined;\n      clearInterval(this._counterResetInterval);\n      clearInterval(this._productivityResetInterval);\n      clearInterval(this._peerStatusRateInterval);\n\n      if (this._socket) {\n        this._socket.destroy(code, reason);\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function send(packet) {\n      if (!this._socket) {\n        throw new Error('Peer socket does not exist');\n      }\n\n      var data = this._getBase64Data(packet.data);\n\n      this._socket.emit(events_2.REMOTE_SC_EVENT_MESSAGE, {\n        event: packet.event,\n        data: data\n      });\n    }\n  }, {\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(packet) {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (!_this2._socket) {\n                    throw new Error('Peer socket does not exist');\n                  }\n\n                  var data = _this2._getBase64Data(packet.data);\n\n                  _this2._socket.emit(events_2.REMOTE_SC_EVENT_RPC_REQUEST, {\n                    procedure: packet.procedure,\n                    data: data\n                  }, function (error, responseData) {\n                    if (error) {\n                      reject(error);\n                      return;\n                    }\n\n                    var response = responseData;\n\n                    if (response) {\n                      var responseBufferData = {\n                        peerId: response.peerId,\n                        data: _this2._getBufferData(response.data)\n                      };\n                      resolve(responseBufferData);\n                      return;\n                    }\n\n                    reject(new errors_1.RPCResponseError(\"Failed to handle response for procedure \".concat(packet.procedure), \"\".concat(_this2.ipAddress, \":\").concat(_this2.port)));\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function request(_x) {\n        return _request.apply(this, arguments);\n      }\n\n      return request;\n    }()\n  }, {\n    key: \"fetchPeers\",\n    value: function () {\n      var _fetchPeers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this3 = this;\n\n        var response, _lisk_codec_1$codec$d, peers, sanitizedPeersList;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this.request({\n                  procedure: events_2.REMOTE_EVENT_RPC_GET_PEERS_LIST\n                });\n\n              case 3:\n                response = _context2.sent;\n\n                if (response.data) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw new errors_1.InvalidPeerInfoListError(constants_1.INVALID_PEER_INFO_LIST_REASON);\n\n              case 6:\n                _lisk_codec_1$codec$d = lisk_codec_1.codec.decode(this._rpcSchemas.peerRequestResponse, response.data), peers = _lisk_codec_1$codec$d.peers;\n                sanitizedPeersList = peers.map(function (peerInfoBuffer) {\n                  var peerInfo = lisk_codec_1.codec.decode(_this3._rpcSchemas.peerInfo, peerInfoBuffer);\n                  return utils_1.sanitizeIncomingPeerInfo(peerInfo);\n                });\n                utils_1.validatePeerInfoList(sanitizedPeersList, this._peerConfig.maxPeerDiscoveryResponseLength, this._peerConfig.maxPeerInfoSize);\n                return _context2.abrupt(\"return\", sanitizedPeersList.map(function (peerInfo) {\n                  return _objectSpread(_objectSpread({}, peerInfo), {}, {\n                    sourceAddress: _this3.ipAddress\n                  });\n                }));\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](0);\n\n                if (_context2.t0 instanceof errors_1.InvalidPeerInfoError || _context2.t0 instanceof errors_1.InvalidPeerInfoListError) {\n                  this.applyPenalty(constants_1.INVALID_PEER_LIST_PENALTY);\n                }\n\n                this.emit(events_2.EVENT_FAILED_TO_FETCH_PEERS, _context2.t0);\n                throw new errors_1.RPCResponseError('Failed to fetch peer list of peer', this.ipAddress);\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 12]]);\n      }));\n\n      function fetchPeers() {\n        return _fetchPeers.apply(this, arguments);\n      }\n\n      return fetchPeers;\n    }()\n  }, {\n    key: \"discoverPeers\",\n    value: function () {\n      var _discoverPeers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this4 = this;\n\n        var discoveredPeerInfoList;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.fetchPeers();\n\n              case 2:\n                discoveredPeerInfoList = _context3.sent;\n                discoveredPeerInfoList.forEach(function (peerInfo) {\n                  _this4.emit(events_2.EVENT_DISCOVERED_PEER, peerInfo);\n                });\n                return _context3.abrupt(\"return\", discoveredPeerInfoList);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function discoverPeers() {\n        return _discoverPeers.apply(this, arguments);\n      }\n\n      return discoverPeers;\n    }()\n  }, {\n    key: \"fetchAndUpdateStatus\",\n    value: function () {\n      var _fetchAndUpdateStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var response, receivedNodeInfo;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                _context4.next = 3;\n                return this.request({\n                  procedure: events_2.REMOTE_EVENT_RPC_GET_NODE_INFO\n                });\n\n              case 3:\n                response = _context4.sent;\n                _context4.next = 10;\n                break;\n\n              case 6:\n                _context4.prev = 6;\n                _context4.t0 = _context4[\"catch\"](0);\n                this.emit(events_2.EVENT_FAILED_TO_FETCH_PEER_INFO, _context4.t0);\n                throw new errors_1.RPCResponseError('Failed to fetch peer info of peer', \"\".concat(this.ipAddress, \":\").concat(this.port));\n\n              case 10:\n                _context4.prev = 10;\n                receivedNodeInfo = codec_1.decodeNodeInfo(this._rpcSchemas.nodeInfo, response.data);\n\n                this._updateFromProtocolPeerInfo(receivedNodeInfo);\n\n                _context4.next = 20;\n                break;\n\n              case 15:\n                _context4.prev = 15;\n                _context4.t1 = _context4[\"catch\"](10);\n                this.emit(events_2.EVENT_FAILED_PEER_INFO_UPDATE, _context4.t1);\n\n                if (_context4.t1 instanceof errors_1.InvalidNodeInfoError) {\n                  this.applyPenalty(constants_1.INVALID_PEER_INFO_PENALTY);\n                }\n\n                throw new errors_1.RPCResponseError('Failed to update peer info of peer due to validation of peer compatibility', \"\".concat(this.ipAddress, \":\").concat(this.port));\n\n              case 20:\n                this.emit(events_2.EVENT_UPDATED_PEER_INFO, this._peerInfo);\n                return _context4.abrupt(\"return\", this._peerInfo);\n\n              case 22:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 6], [10, 15]]);\n      }));\n\n      function fetchAndUpdateStatus() {\n        return _fetchAndUpdateStatus.apply(this, arguments);\n      }\n\n      return fetchAndUpdateStatus;\n    }()\n  }, {\n    key: \"applyPenalty\",\n    value: function applyPenalty(penalty) {\n      this.peerInfo.internalState.reputation -= penalty;\n\n      if (this.internalState.reputation <= 0) {\n        this._banPeer();\n      }\n    }\n  }, {\n    key: \"_resetCounters\",\n    value: function _resetCounters() {\n      var _this5 = this;\n\n      this._peerInfo.internalState.wsMessageRate = this.peerInfo.internalState.wsMessageCount * exports.RATE_NORMALIZATION_FACTOR / this._rateInterval;\n      this._peerInfo.internalState.wsMessageCount = 0;\n\n      if (this.peerInfo.internalState.wsMessageRate > this._peerConfig.wsMaxMessageRate) {\n        var messageRateExceedCoefficient = Math.floor(this.peerInfo.internalState.wsMessageRate / this._peerConfig.wsMaxMessageRate);\n        var penaltyRateMultiplier = messageRateExceedCoefficient > 1 ? messageRateExceedCoefficient : 1;\n        this.applyPenalty(this._peerConfig.wsMaxMessageRatePenalty * penaltyRateMultiplier);\n      }\n\n      this._peerInfo.internalState.rpcRates = new Map(_toConsumableArray(this.internalState.rpcCounter.entries()).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n\n        var rate = value / _this5._rateInterval;\n\n        if (events_2.PROTOCOL_EVENTS_TO_RATE_LIMIT.has(key) && value > 1) {\n          _this5.applyPenalty(_this5._peerConfig.wsMaxMessageRatePenalty);\n        }\n\n        return [key, rate];\n      }));\n      this._peerInfo.internalState.rpcCounter = new Map();\n      this._peerInfo.internalState.messageRates = new Map(_toConsumableArray(this.internalState.messageCounter.entries()).map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            key = _ref4[0],\n            value = _ref4[1];\n\n        var rate = value / _this5._rateInterval;\n        return [key, rate];\n      }));\n      this._peerInfo.internalState.messageCounter = new Map();\n    }\n  }, {\n    key: \"_resetProductivity\",\n    value: function _resetProductivity() {\n      if (this.peerInfo.internalState.productivity.lastResponded < Date.now() - constants_1.DEFAULT_PRODUCTIVITY_RESET_INTERVAL) {\n        this._peerInfo.internalState.productivity = _objectSpread({}, constants_1.DEFAULT_PRODUCTIVITY);\n      }\n    }\n  }, {\n    key: \"_resetStatusMessageRate\",\n    value: function _resetStatusMessageRate() {\n      this._discoveryMessageCounter.postNodeInfo = 0;\n      this._discoveryMessageCounter.getPeers = 0;\n    }\n  }, {\n    key: \"_updateFromProtocolPeerInfo\",\n    value: function _updateFromProtocolPeerInfo(rawPeerInfo) {\n      if (!this._serverNodeInfo) {\n        throw new Error('Missing server node info.');\n      }\n\n      var peerInfo = utils_1.validatePeerInfo(utils_1.sanitizeIncomingPeerInfo(_objectSpread(_objectSpread({}, rawPeerInfo), {}, {\n        ipAddress: this.ipAddress,\n        port: this.port\n      })), this._peerConfig.maxPeerInfoSize);\n      var result = utils_1.validatePeerCompatibility(peerInfo, this._serverNodeInfo);\n\n      if (!result.success && result.error) {\n        throw new Error(\"\".concat(result.error, \" : \").concat(peerInfo.ipAddress, \":\").concat(peerInfo.port));\n      }\n\n      this.updatePeerInfo(peerInfo);\n    }\n  }, {\n    key: \"_handleUpdateNodeInfo\",\n    value: function _handleUpdateNodeInfo(message) {\n      var _a;\n\n      try {\n        utils_1.validatePayloadSize(message.data, this._peerConfig.maxPeerInfoSize);\n        var decodedNodeInfo = codec_1.decodeNodeInfo(this._rpcSchemas.nodeInfo, message.data);\n        var options = decodedNodeInfo.options;\n        this._peerInfo = _objectSpread(_objectSpread({}, this._peerInfo), {}, {\n          sharedState: _objectSpread(_objectSpread({}, this._peerInfo.sharedState), {}, {\n            options: _objectSpread(_objectSpread({}, (_a = this._peerInfo.sharedState) === null || _a === void 0 ? void 0 : _a.options), options)\n          })\n        });\n      } catch (error) {\n        if (error instanceof errors_1.InvalidNodeInfoError) {\n          this.applyPenalty(constants_1.INVALID_PEER_INFO_PENALTY);\n        }\n\n        this.emit(events_2.EVENT_FAILED_PEER_INFO_UPDATE, error);\n        return;\n      }\n\n      this.emit(events_2.EVENT_UPDATED_PEER_INFO, this.peerInfo);\n    }\n  }, {\n    key: \"_banPeer\",\n    value: function _banPeer() {\n      this.emit(events_2.EVENT_BAN_PEER, this.id);\n      this.disconnect(constants_1.FORBIDDEN_CONNECTION, constants_1.FORBIDDEN_CONNECTION_REASON);\n    }\n  }, {\n    key: \"_updateRPCCounter\",\n    value: function _updateRPCCounter(packet) {\n      var _a;\n\n      var key = packet.procedure;\n      var count = ((_a = this.internalState.rpcCounter.get(key)) !== null && _a !== void 0 ? _a : 0) + 1;\n      this.peerInfo.internalState.rpcCounter.set(key, count);\n    }\n  }, {\n    key: \"_getRPCRate\",\n    value: function _getRPCRate(packet) {\n      var _a;\n\n      var rate = (_a = this.peerInfo.internalState.rpcRates.get(packet.procedure)) !== null && _a !== void 0 ? _a : 0;\n      return rate * exports.RATE_NORMALIZATION_FACTOR;\n    }\n  }, {\n    key: \"_updateMessageCounter\",\n    value: function _updateMessageCounter(packet) {\n      var _a;\n\n      var key = packet.event;\n      var count = ((_a = this.internalState.messageCounter.get(key)) !== null && _a !== void 0 ? _a : 0) + 1;\n      this.peerInfo.internalState.messageCounter.set(key, count);\n    }\n  }, {\n    key: \"_getMessageRate\",\n    value: function _getMessageRate(packet) {\n      var _a;\n\n      var rate = (_a = this.internalState.messageRates.get(packet.event)) !== null && _a !== void 0 ? _a : 0;\n      return rate * exports.RATE_NORMALIZATION_FACTOR;\n    }\n  }, {\n    key: \"_initializeInternalState\",\n    value: function _initializeInternalState(peerInfo) {\n      return peerInfo.internalState ? peerInfo : _objectSpread(_objectSpread({}, peerInfo), {}, {\n        internalState: utils_1.assignInternalInfo(peerInfo, this._peerConfig.secret)\n      });\n    }\n  }, {\n    key: \"_getBase64Data\",\n    value: function _getBase64Data(data) {\n      if (data === undefined) {\n        return undefined;\n      }\n\n      if (Buffer.isBuffer(data)) {\n        return data.toString(constants_1.DEFAULT_MESSAGE_ENCODING_FORMAT);\n      }\n\n      return data;\n    }\n  }, {\n    key: \"_getBufferData\",\n    value: function _getBufferData(data) {\n      if (data === undefined) {\n        return undefined;\n      }\n\n      return Buffer.from(data, constants_1.DEFAULT_MESSAGE_ENCODING_FORMAT);\n    }\n  }]);\n\n  return Peer;\n}(events_1.EventEmitter);\n\nexports.Peer = Peer;","map":{"version":3,"sources":["../../src/peer/base.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Peer = exports.ConnectionState = exports.RATE_NORMALIZATION_FACTOR = exports.socketErrorStatusCodes = void 0;\nconst events_1 = require(\"events\");\nconst socketClusterClient = require(\"socketcluster-client\");\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst constants_1 = require(\"../constants\");\nconst errors_1 = require(\"../errors\");\nconst events_2 = require(\"../events\");\nconst p2p_request_1 = require(\"../p2p_request\");\nconst utils_1 = require(\"../utils\");\nconst codec_1 = require(\"../utils/codec\");\nexports.socketErrorStatusCodes = {\n    ...socketClusterClient.SCClientSocket.errorStatuses,\n    1000: 'Intentionally disconnected',\n};\nexports.RATE_NORMALIZATION_FACTOR = 1000;\nconst PEER_STATUS_MESSAGE_RATE_INTERVAL = 10000;\nvar ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[\"CONNECTING\"] = \"connecting\";\n    ConnectionState[\"OPEN\"] = \"open\";\n    ConnectionState[\"CLOSED\"] = \"closed\";\n})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));\nclass Peer extends events_1.EventEmitter {\n    constructor(peerInfo, peerConfig) {\n        super();\n        this._peerConfig = peerConfig;\n        this._rpcSchemas = peerConfig.rpcSchemas;\n        this._peerInfo = this._initializeInternalState(peerInfo);\n        this._rateInterval = this._peerConfig.rateCalculationInterval;\n        this._counterResetInterval = setInterval(() => {\n            this._resetCounters();\n        }, this._rateInterval);\n        this._productivityResetInterval = setInterval(() => {\n            this._resetProductivity();\n        }, constants_1.DEFAULT_PRODUCTIVITY_RESET_INTERVAL);\n        this._serverNodeInfo = peerConfig.serverNodeInfo;\n        this._discoveryMessageCounter = {\n            getPeers: 0,\n            getNodeInfo: 0,\n            postNodeInfo: 0,\n        };\n        this._peerStatusMessageRate = peerConfig.peerStatusMessageRate;\n        this._peerStatusRateInterval = setInterval(() => {\n            this._resetStatusMessageRate();\n        }, PEER_STATUS_MESSAGE_RATE_INTERVAL);\n        this._handleRawRPC = (packet, respond) => {\n            try {\n                utils_1.validateRPCRequest(packet);\n            }\n            catch (error) {\n                respond(error);\n                this.emit(events_2.EVENT_INVALID_REQUEST_RECEIVED, {\n                    packet,\n                    peerId: this._peerInfo.peerId,\n                });\n                return;\n            }\n            const rawRequestPacket = packet;\n            if (rawRequestPacket.procedure === events_2.REMOTE_EVENT_RPC_GET_NODE_INFO) {\n                this._discoveryMessageCounter.getNodeInfo += 1;\n                if (this._discoveryMessageCounter.getNodeInfo > 1) {\n                    this.applyPenalty(10);\n                }\n            }\n            if (rawRequestPacket.procedure === events_2.REMOTE_EVENT_RPC_GET_PEERS_LIST) {\n                this._discoveryMessageCounter.getPeers += 1;\n                if (this._discoveryMessageCounter.getPeers > 1) {\n                    this.applyPenalty(10);\n                }\n            }\n            if (events_2.PROTOCOL_EVENTS_TO_RATE_LIMIT.has(rawRequestPacket.procedure) &&\n                this._peerInfo.internalState.rpcCounter.has(rawRequestPacket.procedure)) {\n                this._updateRPCCounter(rawRequestPacket);\n                return;\n            }\n            this._updateRPCCounter(rawRequestPacket);\n            const rate = this._getRPCRate(rawRequestPacket);\n            const request = new p2p_request_1.P2PRequest({\n                procedure: rawRequestPacket.procedure,\n                data: rawRequestPacket.data,\n                id: this.peerInfo.peerId,\n                rate,\n                productivity: this.internalState.productivity,\n            }, respond);\n            this.emit(events_2.EVENT_REQUEST_RECEIVED, request);\n        };\n        this._handleWSMessage = () => {\n            this._peerInfo.internalState.wsMessageCount += 1;\n        };\n        this._handleRawMessage = (packet) => {\n            try {\n                utils_1.validateProtocolMessage(packet);\n            }\n            catch (error) {\n                this.emit(events_2.EVENT_INVALID_MESSAGE_RECEIVED, {\n                    packet,\n                    peerId: this._peerInfo.peerId,\n                });\n                return;\n            }\n            const message = packet;\n            this._updateMessageCounter(message);\n            const rate = this._getMessageRate(message);\n            const messageBufferData = this._getBufferData(message.data);\n            if (message.event === events_2.REMOTE_EVENT_POST_NODE_INFO) {\n                this._discoveryMessageCounter.postNodeInfo += 1;\n                if (this._discoveryMessageCounter.postNodeInfo > this._peerStatusMessageRate) {\n                    this.applyPenalty(10);\n                }\n                this._handleUpdateNodeInfo({ ...message, data: messageBufferData });\n            }\n            const messageWithRateInfo = {\n                ...message,\n                data: messageBufferData,\n                peerId: this._peerInfo.peerId,\n                rate,\n            };\n            this.emit(events_2.EVENT_MESSAGE_RECEIVED, messageWithRateInfo);\n        };\n    }\n    get id() {\n        return this._peerInfo.peerId;\n    }\n    get ipAddress() {\n        return this._peerInfo.ipAddress;\n    }\n    get port() {\n        return this._peerInfo.port;\n    }\n    get internalState() {\n        return this.peerInfo.internalState;\n    }\n    get peerInfo() {\n        return this._peerInfo;\n    }\n    get state() {\n        const state = this._socket\n            ? this._socket.state === this._socket.OPEN\n                ? ConnectionState.OPEN\n                : ConnectionState.CLOSED\n            : ConnectionState.CLOSED;\n        return state;\n    }\n    updateInternalState(internalState) {\n        this._peerInfo = {\n            ...this._peerInfo,\n            internalState,\n        };\n    }\n    updatePeerInfo(newPeerInfo) {\n        this._peerInfo = {\n            sharedState: newPeerInfo.sharedState,\n            internalState: this._peerInfo.internalState,\n            ipAddress: this.ipAddress,\n            port: this.port,\n            peerId: this.id,\n        };\n    }\n    connect() {\n        if (!this._socket) {\n            throw new Error('Peer socket does not exist');\n        }\n    }\n    disconnect(code = constants_1.INTENTIONAL_DISCONNECT_CODE, reason) {\n        clearInterval(this._counterResetInterval);\n        clearInterval(this._productivityResetInterval);\n        clearInterval(this._peerStatusRateInterval);\n        if (this._socket) {\n            this._socket.destroy(code, reason);\n        }\n    }\n    send(packet) {\n        if (!this._socket) {\n            throw new Error('Peer socket does not exist');\n        }\n        const data = this._getBase64Data(packet.data);\n        this._socket.emit(events_2.REMOTE_SC_EVENT_MESSAGE, {\n            event: packet.event,\n            data,\n        });\n    }\n    async request(packet) {\n        return new Promise((resolve, reject) => {\n            if (!this._socket) {\n                throw new Error('Peer socket does not exist');\n            }\n            const data = this._getBase64Data(packet.data);\n            this._socket.emit(events_2.REMOTE_SC_EVENT_RPC_REQUEST, {\n                procedure: packet.procedure,\n                data,\n            }, (error, responseData) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                const response = responseData;\n                if (response) {\n                    const responseBufferData = {\n                        peerId: response.peerId,\n                        data: this._getBufferData(response.data),\n                    };\n                    resolve(responseBufferData);\n                    return;\n                }\n                reject(new errors_1.RPCResponseError(`Failed to handle response for procedure ${packet.procedure}`, `${this.ipAddress}:${this.port}`));\n            });\n        });\n    }\n    async fetchPeers() {\n        try {\n            const response = await this.request({\n                procedure: events_2.REMOTE_EVENT_RPC_GET_PEERS_LIST,\n            });\n            if (!response.data) {\n                throw new errors_1.InvalidPeerInfoListError(constants_1.INVALID_PEER_INFO_LIST_REASON);\n            }\n            const { peers } = lisk_codec_1.codec.decode(this._rpcSchemas.peerRequestResponse, response.data);\n            const sanitizedPeersList = peers.map((peerInfoBuffer) => {\n                const peerInfo = lisk_codec_1.codec.decode(this._rpcSchemas.peerInfo, peerInfoBuffer);\n                return utils_1.sanitizeIncomingPeerInfo(peerInfo);\n            });\n            utils_1.validatePeerInfoList(sanitizedPeersList, this._peerConfig.maxPeerDiscoveryResponseLength, this._peerConfig.maxPeerInfoSize);\n            return sanitizedPeersList.map(peerInfo => ({\n                ...peerInfo,\n                sourceAddress: this.ipAddress,\n            }));\n        }\n        catch (error) {\n            if (error instanceof errors_1.InvalidPeerInfoError || error instanceof errors_1.InvalidPeerInfoListError) {\n                this.applyPenalty(constants_1.INVALID_PEER_LIST_PENALTY);\n            }\n            this.emit(events_2.EVENT_FAILED_TO_FETCH_PEERS, error);\n            throw new errors_1.RPCResponseError('Failed to fetch peer list of peer', this.ipAddress);\n        }\n    }\n    async discoverPeers() {\n        const discoveredPeerInfoList = await this.fetchPeers();\n        discoveredPeerInfoList.forEach(peerInfo => {\n            this.emit(events_2.EVENT_DISCOVERED_PEER, peerInfo);\n        });\n        return discoveredPeerInfoList;\n    }\n    async fetchAndUpdateStatus() {\n        let response;\n        try {\n            response = await this.request({\n                procedure: events_2.REMOTE_EVENT_RPC_GET_NODE_INFO,\n            });\n        }\n        catch (error) {\n            this.emit(events_2.EVENT_FAILED_TO_FETCH_PEER_INFO, error);\n            throw new errors_1.RPCResponseError('Failed to fetch peer info of peer', `${this.ipAddress}:${this.port}`);\n        }\n        try {\n            const receivedNodeInfo = codec_1.decodeNodeInfo(this._rpcSchemas.nodeInfo, response.data);\n            this._updateFromProtocolPeerInfo(receivedNodeInfo);\n        }\n        catch (error) {\n            this.emit(events_2.EVENT_FAILED_PEER_INFO_UPDATE, error);\n            if (error instanceof errors_1.InvalidNodeInfoError) {\n                this.applyPenalty(constants_1.INVALID_PEER_INFO_PENALTY);\n            }\n            throw new errors_1.RPCResponseError('Failed to update peer info of peer due to validation of peer compatibility', `${this.ipAddress}:${this.port}`);\n        }\n        this.emit(events_2.EVENT_UPDATED_PEER_INFO, this._peerInfo);\n        return this._peerInfo;\n    }\n    applyPenalty(penalty) {\n        this.peerInfo.internalState.reputation -= penalty;\n        if (this.internalState.reputation <= 0) {\n            this._banPeer();\n        }\n    }\n    _resetCounters() {\n        this._peerInfo.internalState.wsMessageRate =\n            (this.peerInfo.internalState.wsMessageCount * exports.RATE_NORMALIZATION_FACTOR) / this._rateInterval;\n        this._peerInfo.internalState.wsMessageCount = 0;\n        if (this.peerInfo.internalState.wsMessageRate > this._peerConfig.wsMaxMessageRate) {\n            const messageRateExceedCoefficient = Math.floor(this.peerInfo.internalState.wsMessageRate / this._peerConfig.wsMaxMessageRate);\n            const penaltyRateMultiplier = messageRateExceedCoefficient > 1 ? messageRateExceedCoefficient : 1;\n            this.applyPenalty(this._peerConfig.wsMaxMessageRatePenalty * penaltyRateMultiplier);\n        }\n        this._peerInfo.internalState.rpcRates = new Map([...this.internalState.rpcCounter.entries()].map(([key, value]) => {\n            const rate = value / this._rateInterval;\n            if (events_2.PROTOCOL_EVENTS_TO_RATE_LIMIT.has(key) && value > 1) {\n                this.applyPenalty(this._peerConfig.wsMaxMessageRatePenalty);\n            }\n            return [key, rate];\n        }));\n        this._peerInfo.internalState.rpcCounter = new Map();\n        this._peerInfo.internalState.messageRates = new Map([...this.internalState.messageCounter.entries()].map(([key, value]) => {\n            const rate = value / this._rateInterval;\n            return [key, rate];\n        }));\n        this._peerInfo.internalState.messageCounter = new Map();\n    }\n    _resetProductivity() {\n        if (this.peerInfo.internalState.productivity.lastResponded <\n            Date.now() - constants_1.DEFAULT_PRODUCTIVITY_RESET_INTERVAL) {\n            this._peerInfo.internalState.productivity = { ...constants_1.DEFAULT_PRODUCTIVITY };\n        }\n    }\n    _resetStatusMessageRate() {\n        this._discoveryMessageCounter.postNodeInfo = 0;\n        this._discoveryMessageCounter.getPeers = 0;\n    }\n    _updateFromProtocolPeerInfo(rawPeerInfo) {\n        if (!this._serverNodeInfo) {\n            throw new Error('Missing server node info.');\n        }\n        const peerInfo = utils_1.validatePeerInfo(utils_1.sanitizeIncomingPeerInfo({\n            ...rawPeerInfo,\n            ipAddress: this.ipAddress,\n            port: this.port,\n        }), this._peerConfig.maxPeerInfoSize);\n        const result = utils_1.validatePeerCompatibility(peerInfo, this._serverNodeInfo);\n        if (!result.success && result.error) {\n            throw new Error(`${result.error} : ${peerInfo.ipAddress}:${peerInfo.port}`);\n        }\n        this.updatePeerInfo(peerInfo);\n    }\n    _handleUpdateNodeInfo(message) {\n        var _a;\n        try {\n            utils_1.validatePayloadSize(message.data, this._peerConfig.maxPeerInfoSize);\n            const decodedNodeInfo = codec_1.decodeNodeInfo(this._rpcSchemas.nodeInfo, message.data);\n            const { options } = decodedNodeInfo;\n            this._peerInfo = {\n                ...this._peerInfo,\n                sharedState: {\n                    ...this._peerInfo.sharedState,\n                    options: { ...(_a = this._peerInfo.sharedState) === null || _a === void 0 ? void 0 : _a.options, ...options },\n                },\n            };\n        }\n        catch (error) {\n            if (error instanceof errors_1.InvalidNodeInfoError) {\n                this.applyPenalty(constants_1.INVALID_PEER_INFO_PENALTY);\n            }\n            this.emit(events_2.EVENT_FAILED_PEER_INFO_UPDATE, error);\n            return;\n        }\n        this.emit(events_2.EVENT_UPDATED_PEER_INFO, this.peerInfo);\n    }\n    _banPeer() {\n        this.emit(events_2.EVENT_BAN_PEER, this.id);\n        this.disconnect(constants_1.FORBIDDEN_CONNECTION, constants_1.FORBIDDEN_CONNECTION_REASON);\n    }\n    _updateRPCCounter(packet) {\n        var _a;\n        const key = packet.procedure;\n        const count = ((_a = this.internalState.rpcCounter.get(key)) !== null && _a !== void 0 ? _a : 0) + 1;\n        this.peerInfo.internalState.rpcCounter.set(key, count);\n    }\n    _getRPCRate(packet) {\n        var _a;\n        const rate = (_a = this.peerInfo.internalState.rpcRates.get(packet.procedure)) !== null && _a !== void 0 ? _a : 0;\n        return rate * exports.RATE_NORMALIZATION_FACTOR;\n    }\n    _updateMessageCounter(packet) {\n        var _a;\n        const key = packet.event;\n        const count = ((_a = this.internalState.messageCounter.get(key)) !== null && _a !== void 0 ? _a : 0) + 1;\n        this.peerInfo.internalState.messageCounter.set(key, count);\n    }\n    _getMessageRate(packet) {\n        var _a;\n        const rate = (_a = this.internalState.messageRates.get(packet.event)) !== null && _a !== void 0 ? _a : 0;\n        return rate * exports.RATE_NORMALIZATION_FACTOR;\n    }\n    _initializeInternalState(peerInfo) {\n        return peerInfo.internalState\n            ? peerInfo\n            : {\n                ...peerInfo,\n                internalState: utils_1.assignInternalInfo(peerInfo, this._peerConfig.secret),\n            };\n    }\n    _getBase64Data(data) {\n        if (data === undefined) {\n            return undefined;\n        }\n        if (Buffer.isBuffer(data)) {\n            return data.toString(constants_1.DEFAULT_MESSAGE_ENCODING_FORMAT);\n        }\n        return data;\n    }\n    _getBufferData(data) {\n        if (data === undefined) {\n            return undefined;\n        }\n        return Buffer.from(data, constants_1.DEFAULT_MESSAGE_ENCODING_FORMAT);\n    }\n}\nexports.Peer = Peer;\n//# sourceMappingURL=base.js.map"]},"metadata":{},"sourceType":"script"}