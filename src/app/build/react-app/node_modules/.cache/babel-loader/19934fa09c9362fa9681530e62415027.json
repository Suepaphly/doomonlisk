{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fieldNumberKeyword = exports.metaSchema = void 0;\n\nvar createDebug = require(\"debug\");\n\nvar errors_1 = require(\"../errors\");\n\nvar debug = createDebug('codec:keyword:fieldNumber');\nexports.metaSchema = {\n  title: 'Lisk Codec Field Number',\n  type: 'number',\n  minimum: 1,\n  maximum: 18999\n};\n\nvar deepValue = function deepValue(obj, path) {\n  var parts = path.split('.');\n  var len = parts.length;\n  var result = obj;\n\n  for (var i = 0; i < len; i += 1) {\n    result = result[parts[i]];\n  }\n\n  return result;\n};\n\nvar compile = function compile(value, parentSchema, it) {\n  debug('compile: schema: %i', value);\n  debug('compile: parent schema: %j', parentSchema);\n  var schemaPath = it.schemaPath,\n      rootSchema = it.schemaEnv.root.schema;\n  var parentPath = schemaPath.str.split('.');\n  parentPath.shift();\n  parentPath.pop();\n  var parentSchemaObject = deepValue(rootSchema, parentPath.join('.'));\n  var fieldNumbers = Object.keys(parentSchemaObject).map(function (key) {\n    return parentSchemaObject[key].fieldNumber;\n  });\n\n  var uniqueFieldNumbers = _toConsumableArray(new Set(fieldNumbers));\n\n  if (fieldNumbers.length !== uniqueFieldNumbers.length) {\n    throw new errors_1.LiskValidationError([{\n      keyword: 'fieldNumber',\n      message: 'Value must be unique across all properties on same level',\n      params: {\n        fieldNumbers: fieldNumbers\n      },\n      dataPath: '',\n      schemaPath: schemaPath.str\n    }]);\n  }\n\n  return function (_data, _dataCxt) {\n    return true;\n  };\n};\n\nexports.fieldNumberKeyword = {\n  keyword: 'fieldNumber',\n  compile: compile,\n  valid: true,\n  errors: false,\n  modifying: false,\n  metaSchema: exports.metaSchema\n};","map":{"version":3,"sources":["../../src/keywords/field_number.ts"],"names":[],"mappings":";;;;;;;;;AAeA,IAAA,WAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAEA,IAAM,KAAK,GAAG,WAAW,CAAC,2BAAD,CAAzB;AAEa,OAAA,CAAA,UAAA,GAAa;AACzB,EAAA,KAAK,EAAE,yBADkB;AAEzB,EAAA,IAAI,EAAE,QAFmB;AAGzB,EAAA,OAAO,EAAE,CAHgB;AAIzB,EAAA,OAAO,EAAE;AAJgB,CAAb;;AAQb,IAAM,SAAS,GAAG,SAAZ,SAAY,CAAC,GAAD,EAAiB,IAAjB,EAAsC;AACvD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAd;AACA,MAAM,GAAG,GAAG,KAAK,CAAC,MAAlB;AAEA,MAAI,MAAM,GAAQ,GAAlB;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,IAAI,CAA9B,EAAiC;AAEhC,IAAA,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,CAAD,CAAN,CAAf;AACA;;AAGD,SAAO,MAAP;AACA,CAbD;;AAeA,IAAM,OAAO,GAAG,SAAV,OAAU,CACf,KADe,EAEf,YAFe,EAGf,EAHe,EAIU;AACzB,EAAA,KAAK,CAAC,qBAAD,EAAwB,KAAxB,CAAL;AACA,EAAA,KAAK,CAAC,4BAAD,EAA+B,YAA/B,CAAL;AAEA,MACC,UADD,GAKI,EALJ,CACC,UADD;AAAA,MAGkB,UAHlB,GAKI,EALJ,CAEC,SAFD,CAGE,IAHF,CAGU,MAHV;AAOA,MAAM,UAAU,GAAa,UAAU,CAAC,GAAX,CAAe,KAAf,CAAqB,GAArB,CAA7B;AACA,EAAA,UAAU,CAAC,KAAX;AACA,EAAA,UAAU,CAAC,GAAX;AAEA,MAAM,kBAAkB,GAEpB,SAAS,CAAC,UAAD,EAAa,UAAU,CAAC,IAAX,CAAgB,GAAhB,CAAb,CAFb;AAIA,MAAM,YAAY,GAAa,MAAM,CAAC,IAAP,CAAY,kBAAZ,EAAgC,GAAhC,CAC9B,UAAC,GAAD;AAAA,WAAiB,kBAAkB,CAAC,GAAD,CAAlB,CAAwB,WAAzC;AAAA,GAD8B,CAA/B;;AAGA,MAAM,kBAAkB,sBAAO,IAAI,GAAJ,CAAQ,YAAR,CAAP,CAAxB;;AAEA,MAAI,YAAY,CAAC,MAAb,KAAwB,kBAAkB,CAAC,MAA/C,EAAuD;AACtD,UAAM,IAAI,QAAA,CAAA,mBAAJ,CAAwB,CAC7B;AACC,MAAA,OAAO,EAAE,aADV;AAEC,MAAA,OAAO,EAAE,0DAFV;AAGC,MAAA,MAAM,EAAE;AAAE,QAAA,YAAY,EAAZ;AAAF,OAHT;AAIC,MAAA,QAAQ,EAAE,EAJX;AAKC,MAAA,UAAU,EAAE,UAAU,CAAC;AALxB,KAD6B,CAAxB,CAAN;AASA;;AAED,SAAO,UAAC,KAAD,EAAgB,QAAhB;AAAA,WAA0D,IAA1D;AAAA,GAAP;AACA,CAzCD;;AA2Ca,OAAA,CAAA,kBAAA,GAA4C;AACxD,EAAA,OAAO,EAAE,aAD+C;AAExD,EAAA,OAAO,EAAP,OAFwD;AAGxD,EAAA,KAAK,EAAE,IAHiD;AAIxD,EAAA,MAAM,EAAE,KAJgD;AAKxD,EAAA,SAAS,EAAE,KAL6C;AAMxD,EAAA,UAAU,EAAV,OAAA,CAAA;AANwD,CAA5C","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fieldNumberKeyword = exports.metaSchema = void 0;\nconst createDebug = require(\"debug\");\nconst errors_1 = require(\"../errors\");\nconst debug = createDebug('codec:keyword:fieldNumber');\nexports.metaSchema = {\n    title: 'Lisk Codec Field Number',\n    type: 'number',\n    minimum: 1,\n    maximum: 18999,\n};\nconst deepValue = (obj, path) => {\n    const parts = path.split('.');\n    const len = parts.length;\n    let result = obj;\n    for (let i = 0; i < len; i += 1) {\n        result = result[parts[i]];\n    }\n    return result;\n};\nconst compile = (value, parentSchema, it) => {\n    debug('compile: schema: %i', value);\n    debug('compile: parent schema: %j', parentSchema);\n    const { schemaPath, schemaEnv: { root: { schema: rootSchema }, }, } = it;\n    const parentPath = schemaPath.str.split('.');\n    parentPath.shift();\n    parentPath.pop();\n    const parentSchemaObject = deepValue(rootSchema, parentPath.join('.'));\n    const fieldNumbers = Object.keys(parentSchemaObject).map((key) => parentSchemaObject[key].fieldNumber);\n    const uniqueFieldNumbers = [...new Set(fieldNumbers)];\n    if (fieldNumbers.length !== uniqueFieldNumbers.length) {\n        throw new errors_1.LiskValidationError([\n            {\n                keyword: 'fieldNumber',\n                message: 'Value must be unique across all properties on same level',\n                params: { fieldNumbers },\n                dataPath: '',\n                schemaPath: schemaPath.str,\n            },\n        ]);\n    }\n    return (_data, _dataCxt) => true;\n};\nexports.fieldNumberKeyword = {\n    keyword: 'fieldNumber',\n    compile,\n    valid: true,\n    errors: false,\n    modifying: false,\n    metaSchema: exports.metaSchema,\n};\n//# sourceMappingURL=field_number.js.map"]},"metadata":{},"sourceType":"script"}