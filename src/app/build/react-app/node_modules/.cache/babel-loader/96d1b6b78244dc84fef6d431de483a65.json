{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateGenesisBlockHeader = exports.validateBlockSlot = exports.validateBlockProperties = exports.validateReward = exports.validateSignature = void 0;\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar lisk_tree_1 = require(\"@liskhq/lisk-tree\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nvar schema_1 = require(\"./schema\");\n\nvar constants_1 = require(\"./constants\");\n\nvar validateSignature = function validateSignature(publicKey, dataWithoutSignature, signature, networkIdentifier) {\n  var blockWithNetworkIdentifierBytes = Buffer.concat([networkIdentifier, dataWithoutSignature]);\n  var verified = lisk_cryptography_1.verifyData(blockWithNetworkIdentifierBytes, signature, publicKey);\n\n  if (!verified) {\n    throw new Error('Invalid block signature');\n  }\n};\n\nexports.validateSignature = validateSignature;\n\nvar validateReward = function validateReward(block, maxReward) {\n  if (block.header.reward > maxReward) {\n    throw new Error(\"Invalid block reward: \".concat(block.header.reward.toString(), \" maximum allowed: \").concat(maxReward.toString()));\n  }\n};\n\nexports.validateReward = validateReward;\n\nvar getTransactionRoot = function getTransactionRoot(ids) {\n  var tree = new lisk_tree_1.MerkleTree(ids);\n  return tree.root;\n};\n\nvar validateBlockProperties = function validateBlockProperties(block, encodedPayload, maxPayloadLength) {\n  if (block.header.previousBlockID.length === 0) {\n    throw new Error('Previous block id must not be empty');\n  }\n\n  if (encodedPayload.length > maxPayloadLength) {\n    throw new Error('Payload length is too long');\n  }\n\n  var transactionIds = [];\n\n  var _iterator = _createForOfIteratorHelper(block.payload),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var transaction = _step.value;\n      transactionIds.push(transaction.id);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var transactionRoot = getTransactionRoot(transactionIds);\n\n  if (!transactionRoot.equals(block.header.transactionRoot)) {\n    throw new Error('Invalid transaction root');\n  }\n};\n\nexports.validateBlockProperties = validateBlockProperties;\n\nvar validateBlockSlot = function validateBlockSlot(block, lastBlock, slots) {\n  var blockSlotNumber = slots.getSlotNumber(block.header.timestamp);\n  var lastBlockSlotNumber = slots.getSlotNumber(lastBlock.header.timestamp);\n\n  if (blockSlotNumber > slots.getSlotNumber() || blockSlotNumber <= lastBlockSlotNumber) {\n    throw new Error('Invalid block timestamp');\n  }\n};\n\nexports.validateBlockSlot = validateBlockSlot;\n\nvar validateGenesisBlockHeader = function validateGenesisBlockHeader(block, accountSchema) {\n  var header = block.header,\n      payload = block.payload;\n  var errors = [];\n  var headerErrors = lisk_validator_1.validator.validate(lisk_utils_1.objects.mergeDeep({}, schema_1.blockHeaderSchema, {\n    properties: {\n      version: {\n        const: 0\n      }\n    }\n  }), _objectSpread(_objectSpread({}, header), {}, {\n    asset: constants_1.EMPTY_BUFFER\n  }));\n\n  if (headerErrors.length) {\n    errors.push.apply(errors, _toConsumableArray(headerErrors));\n  }\n\n  var assetErrors = lisk_validator_1.validator.validate(schema_1.getGenesisBlockHeaderAssetSchema(accountSchema), header.asset);\n\n  if (assetErrors.length) {\n    errors.push.apply(errors, _toConsumableArray(assetErrors));\n  }\n\n  if (!header.generatorPublicKey.equals(constants_1.GENESIS_BLOCK_GENERATOR_PUBLIC_KEY)) {\n    errors.push({\n      message: 'should be equal to constant',\n      keyword: 'const',\n      dataPath: 'header.generatorPublicKey',\n      schemaPath: 'properties.generatorPublicKey',\n      params: {\n        allowedValue: constants_1.GENESIS_BLOCK_GENERATOR_PUBLIC_KEY\n      }\n    });\n  }\n\n  if (header.reward !== constants_1.GENESIS_BLOCK_REWARD) {\n    errors.push({\n      message: 'should be equal to constant',\n      keyword: 'const',\n      dataPath: 'header.reward',\n      schemaPath: 'properties.reward',\n      params: {\n        allowedValue: constants_1.GENESIS_BLOCK_REWARD\n      }\n    });\n  }\n\n  if (!header.signature.equals(constants_1.GENESIS_BLOCK_SIGNATURE)) {\n    errors.push({\n      message: 'should be equal to constant',\n      keyword: 'const',\n      dataPath: 'header.signature',\n      schemaPath: 'properties.signature',\n      params: {\n        allowedValue: constants_1.GENESIS_BLOCK_SIGNATURE\n      }\n    });\n  }\n\n  if (!header.transactionRoot.equals(constants_1.GENESIS_BLOCK_TRANSACTION_ROOT)) {\n    errors.push({\n      message: 'should be equal to constant',\n      keyword: 'const',\n      dataPath: 'header.transactionRoot',\n      schemaPath: 'properties.transactionRoot',\n      params: {\n        allowedValue: constants_1.GENESIS_BLOCK_TRANSACTION_ROOT\n      }\n    });\n  }\n\n  if (payload.length !== 0) {\n    errors.push({\n      message: 'Payload length must be zero',\n      keyword: 'const',\n      dataPath: 'payload',\n      schemaPath: 'properties.payload',\n      params: {\n        allowedValue: []\n      }\n    });\n  }\n\n  if (!lisk_utils_1.objects.bufferArrayUniqueItems(header.asset.initDelegates)) {\n    errors.push({\n      dataPath: '.initDelegates',\n      keyword: 'uniqueItems',\n      message: 'must NOT have duplicate items',\n      params: {},\n      schemaPath: '#/properties/initDelegates/uniqueItems'\n    });\n  }\n\n  if (!lisk_utils_1.objects.bufferArrayOrderByLex(header.asset.initDelegates)) {\n    errors.push({\n      message: 'should be lexicographically ordered',\n      keyword: 'initDelegates',\n      dataPath: 'header.asset.initDelegates',\n      schemaPath: 'properties.initDelegates',\n      params: {\n        initDelegates: header.asset.initDelegates\n      }\n    });\n  }\n\n  var accountAddresses = header.asset.accounts.map(function (a) {\n    return a.address;\n  });\n\n  var copiedAddresses = _toConsumableArray(accountAddresses);\n\n  copiedAddresses.sort(function (a, b) {\n    if (a.length > b.length) {\n      return 1;\n    }\n\n    if (a.length < b.length) {\n      return -1;\n    }\n\n    return a.compare(b);\n  });\n\n  if (!lisk_utils_1.objects.bufferArrayEqual(accountAddresses, copiedAddresses)) {\n    errors.push({\n      message: 'should be length and lexicographically ordered',\n      keyword: 'accounts',\n      dataPath: 'header.asset.accounts',\n      schemaPath: 'properties.accounts',\n      params: {\n        orderKey: 'address'\n      }\n    });\n  }\n\n  if (!lisk_utils_1.objects.bufferArrayUniqueItems(accountAddresses)) {\n    errors.push({\n      dataPath: '.accounts',\n      keyword: 'uniqueItems',\n      message: 'must NOT have duplicate items',\n      params: {},\n      schemaPath: '#/properties/accounts/uniqueItems'\n    });\n  }\n\n  if (errors.length) {\n    throw new lisk_validator_1.LiskValidationError(errors);\n  }\n};\n\nexports.validateGenesisBlockHeader = validateGenesisBlockHeader;","map":{"version":3,"sources":["../src/validate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateGenesisBlockHeader = exports.validateBlockSlot = exports.validateBlockProperties = exports.validateReward = exports.validateSignature = void 0;\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_tree_1 = require(\"@liskhq/lisk-tree\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst schema_1 = require(\"./schema\");\nconst constants_1 = require(\"./constants\");\nconst validateSignature = (publicKey, dataWithoutSignature, signature, networkIdentifier) => {\n    const blockWithNetworkIdentifierBytes = Buffer.concat([networkIdentifier, dataWithoutSignature]);\n    const verified = lisk_cryptography_1.verifyData(blockWithNetworkIdentifierBytes, signature, publicKey);\n    if (!verified) {\n        throw new Error('Invalid block signature');\n    }\n};\nexports.validateSignature = validateSignature;\nconst validateReward = (block, maxReward) => {\n    if (block.header.reward > maxReward) {\n        throw new Error(`Invalid block reward: ${block.header.reward.toString()} maximum allowed: ${maxReward.toString()}`);\n    }\n};\nexports.validateReward = validateReward;\nconst getTransactionRoot = (ids) => {\n    const tree = new lisk_tree_1.MerkleTree(ids);\n    return tree.root;\n};\nconst validateBlockProperties = (block, encodedPayload, maxPayloadLength) => {\n    if (block.header.previousBlockID.length === 0) {\n        throw new Error('Previous block id must not be empty');\n    }\n    if (encodedPayload.length > maxPayloadLength) {\n        throw new Error('Payload length is too long');\n    }\n    const transactionIds = [];\n    for (const transaction of block.payload) {\n        transactionIds.push(transaction.id);\n    }\n    const transactionRoot = getTransactionRoot(transactionIds);\n    if (!transactionRoot.equals(block.header.transactionRoot)) {\n        throw new Error('Invalid transaction root');\n    }\n};\nexports.validateBlockProperties = validateBlockProperties;\nconst validateBlockSlot = (block, lastBlock, slots) => {\n    const blockSlotNumber = slots.getSlotNumber(block.header.timestamp);\n    const lastBlockSlotNumber = slots.getSlotNumber(lastBlock.header.timestamp);\n    if (blockSlotNumber > slots.getSlotNumber() || blockSlotNumber <= lastBlockSlotNumber) {\n        throw new Error('Invalid block timestamp');\n    }\n};\nexports.validateBlockSlot = validateBlockSlot;\nconst validateGenesisBlockHeader = (block, accountSchema) => {\n    const { header, payload } = block;\n    const errors = [];\n    const headerErrors = lisk_validator_1.validator.validate(lisk_utils_1.objects.mergeDeep({}, schema_1.blockHeaderSchema, {\n        properties: {\n            version: {\n                const: 0,\n            },\n        },\n    }), { ...header, asset: constants_1.EMPTY_BUFFER });\n    if (headerErrors.length) {\n        errors.push(...headerErrors);\n    }\n    const assetErrors = lisk_validator_1.validator.validate(schema_1.getGenesisBlockHeaderAssetSchema(accountSchema), header.asset);\n    if (assetErrors.length) {\n        errors.push(...assetErrors);\n    }\n    if (!header.generatorPublicKey.equals(constants_1.GENESIS_BLOCK_GENERATOR_PUBLIC_KEY)) {\n        errors.push({\n            message: 'should be equal to constant',\n            keyword: 'const',\n            dataPath: 'header.generatorPublicKey',\n            schemaPath: 'properties.generatorPublicKey',\n            params: { allowedValue: constants_1.GENESIS_BLOCK_GENERATOR_PUBLIC_KEY },\n        });\n    }\n    if (header.reward !== constants_1.GENESIS_BLOCK_REWARD) {\n        errors.push({\n            message: 'should be equal to constant',\n            keyword: 'const',\n            dataPath: 'header.reward',\n            schemaPath: 'properties.reward',\n            params: { allowedValue: constants_1.GENESIS_BLOCK_REWARD },\n        });\n    }\n    if (!header.signature.equals(constants_1.GENESIS_BLOCK_SIGNATURE)) {\n        errors.push({\n            message: 'should be equal to constant',\n            keyword: 'const',\n            dataPath: 'header.signature',\n            schemaPath: 'properties.signature',\n            params: { allowedValue: constants_1.GENESIS_BLOCK_SIGNATURE },\n        });\n    }\n    if (!header.transactionRoot.equals(constants_1.GENESIS_BLOCK_TRANSACTION_ROOT)) {\n        errors.push({\n            message: 'should be equal to constant',\n            keyword: 'const',\n            dataPath: 'header.transactionRoot',\n            schemaPath: 'properties.transactionRoot',\n            params: { allowedValue: constants_1.GENESIS_BLOCK_TRANSACTION_ROOT },\n        });\n    }\n    if (payload.length !== 0) {\n        errors.push({\n            message: 'Payload length must be zero',\n            keyword: 'const',\n            dataPath: 'payload',\n            schemaPath: 'properties.payload',\n            params: { allowedValue: [] },\n        });\n    }\n    if (!lisk_utils_1.objects.bufferArrayUniqueItems(header.asset.initDelegates)) {\n        errors.push({\n            dataPath: '.initDelegates',\n            keyword: 'uniqueItems',\n            message: 'must NOT have duplicate items',\n            params: {},\n            schemaPath: '#/properties/initDelegates/uniqueItems',\n        });\n    }\n    if (!lisk_utils_1.objects.bufferArrayOrderByLex(header.asset.initDelegates)) {\n        errors.push({\n            message: 'should be lexicographically ordered',\n            keyword: 'initDelegates',\n            dataPath: 'header.asset.initDelegates',\n            schemaPath: 'properties.initDelegates',\n            params: { initDelegates: header.asset.initDelegates },\n        });\n    }\n    const accountAddresses = header.asset.accounts.map(a => a.address);\n    const copiedAddresses = [...accountAddresses];\n    copiedAddresses.sort((a, b) => {\n        if (a.length > b.length) {\n            return 1;\n        }\n        if (a.length < b.length) {\n            return -1;\n        }\n        return a.compare(b);\n    });\n    if (!lisk_utils_1.objects.bufferArrayEqual(accountAddresses, copiedAddresses)) {\n        errors.push({\n            message: 'should be length and lexicographically ordered',\n            keyword: 'accounts',\n            dataPath: 'header.asset.accounts',\n            schemaPath: 'properties.accounts',\n            params: { orderKey: 'address' },\n        });\n    }\n    if (!lisk_utils_1.objects.bufferArrayUniqueItems(accountAddresses)) {\n        errors.push({\n            dataPath: '.accounts',\n            keyword: 'uniqueItems',\n            message: 'must NOT have duplicate items',\n            params: {},\n            schemaPath: '#/properties/accounts/uniqueItems',\n        });\n    }\n    if (errors.length) {\n        throw new lisk_validator_1.LiskValidationError(errors);\n    }\n};\nexports.validateGenesisBlockHeader = validateGenesisBlockHeader;\n//# sourceMappingURL=validate.js.map"]},"metadata":{},"sourceType":"script"}