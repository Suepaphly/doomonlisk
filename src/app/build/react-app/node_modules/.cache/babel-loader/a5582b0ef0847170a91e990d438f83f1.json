{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clearBlockHeaders = exports.getContradictingBlockHeader = exports.saveBlockHeaders = exports.decodeBlockHeader = exports.getBlockHeaders = exports.getDBInstance = exports.blockHeadersSchema = void 0;\n\nvar lisk_db_1 = require(\"@liskhq/lisk-db\");\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_bft_1 = require(\"@liskhq/lisk-bft\");\n\nvar os = require(\"os\");\n\nvar path_1 = require(\"path\");\n\nvar fs_extra_1 = require(\"fs-extra\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nexports.blockHeadersSchema = {\n  $id: 'lisk/reportMisbehavior/blockHeaders',\n  type: 'object',\n  required: ['blockHeaders'],\n  properties: {\n    blockHeaders: {\n      type: 'array',\n      fieldNumber: 1,\n      items: {\n        dataType: 'bytes'\n      }\n    }\n  }\n};\n\nvar getDBInstance = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dataPath) {\n    var dbName,\n        dirPath,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            dbName = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'lisk-framework-report-misbehavior-plugin.db';\n            dirPath = path_1.join(dataPath.replace('~', os.homedir()), 'plugins/data', dbName);\n            _context.next = 4;\n            return fs_extra_1.ensureDir(dirPath);\n\n          case 4:\n            return _context.abrupt(\"return\", new lisk_db_1.KVStore(dirPath));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getDBInstance(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.getDBInstance = getDBInstance;\n\nvar getBlockHeaders = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(db, dbKeyBlockHeader) {\n    var encodedBlockHeaders;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return db.get(dbKeyBlockHeader);\n\n          case 3:\n            encodedBlockHeaders = _context2.sent;\n            return _context2.abrupt(\"return\", lisk_codec_1.codec.decode(exports.blockHeadersSchema, encodedBlockHeaders));\n\n          case 7:\n            _context2.prev = 7;\n            _context2.t0 = _context2[\"catch\"](0);\n            return _context2.abrupt(\"return\", {\n              blockHeaders: []\n            });\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 7]]);\n  }));\n\n  return function getBlockHeaders(_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.getBlockHeaders = getBlockHeaders;\n\nvar decodeBlockHeader = function decodeBlockHeader(encodedHeader, schema) {\n  var id = lisk_cryptography_1.hash(encodedHeader);\n  var blockHeader = lisk_codec_1.codec.decode(schema.blockHeader, encodedHeader);\n  var assetSchema = schema.blockHeadersAssets[blockHeader.version];\n  var asset = lisk_codec_1.codec.decode(assetSchema, blockHeader.asset);\n  return _objectSpread(_objectSpread({}, blockHeader), {}, {\n    asset: asset,\n    id: id\n  });\n};\n\nexports.decodeBlockHeader = decodeBlockHeader;\n\nvar saveBlockHeaders = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(db, schemas, header) {\n    var blockId, _lisk_codec_1$codec$d, generatorPublicKey, height, dbKey, _yield$exports$getBlo, blockHeaders;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            blockId = lisk_cryptography_1.hash(header);\n            _lisk_codec_1$codec$d = lisk_codec_1.codec.decode(schemas.blockHeader, header), generatorPublicKey = _lisk_codec_1$codec$d.generatorPublicKey, height = _lisk_codec_1$codec$d.height;\n            dbKey = \"\".concat(generatorPublicKey.toString('binary'), \":\").concat(lisk_db_1.formatInt(height));\n            _context3.next = 5;\n            return exports.getBlockHeaders(db, dbKey);\n\n          case 5:\n            _yield$exports$getBlo = _context3.sent;\n            blockHeaders = _yield$exports$getBlo.blockHeaders;\n\n            if (blockHeaders.find(function (blockHeader) {\n              return lisk_cryptography_1.hash(blockHeader).equals(blockId);\n            })) {\n              _context3.next = 11;\n              break;\n            }\n\n            _context3.next = 10;\n            return db.put(dbKey, lisk_codec_1.codec.encode(exports.blockHeadersSchema, {\n              blockHeaders: [].concat(_toConsumableArray(blockHeaders), [header])\n            }));\n\n          case 10:\n            return _context3.abrupt(\"return\", true);\n\n          case 11:\n            return _context3.abrupt(\"return\", false);\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function saveBlockHeaders(_x4, _x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.saveBlockHeaders = saveBlockHeaders;\n\nvar getContradictingBlockHeader = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(db, blockHeader, schemas) {\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n              var stream = db.createReadStream({\n                gte: lisk_db_1.getFirstPrefix(blockHeader.generatorPublicKey.toString('binary')),\n                lte: lisk_db_1.getLastPrefix(blockHeader.generatorPublicKey.toString('binary'))\n              });\n              stream.on('data', function (_ref5) {\n                var value = _ref5.value;\n\n                var _lisk_codec_1$codec$d2 = lisk_codec_1.codec.decode(exports.blockHeadersSchema, value),\n                    blockHeaders = _lisk_codec_1$codec$d2.blockHeaders;\n\n                var _iterator = _createForOfIteratorHelper(blockHeaders),\n                    _step;\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    var encodedHeader = _step.value;\n                    var decodedBlockHeader = exports.decodeBlockHeader(encodedHeader, schemas);\n\n                    if (lisk_bft_1.areHeadersContradicting(blockHeader, decodedBlockHeader)) {\n                      stream.destroy();\n                      resolve(decodedBlockHeader);\n                    }\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n              }).on('error', function (error) {\n                reject(error);\n              }).on('end', function () {\n                resolve(undefined);\n              });\n            }));\n\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function getContradictingBlockHeader(_x7, _x8, _x9) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.getContradictingBlockHeader = getContradictingBlockHeader;\n\nvar clearBlockHeaders = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(db, schemas, currentHeight) {\n    var keys, batch, _iterator3, _step3, k;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return new Promise(function (resolve, reject) {\n              var stream = db.createReadStream();\n              var res = [];\n              stream.on('data', function (_ref7) {\n                var key = _ref7.key,\n                    value = _ref7.value;\n\n                var _lisk_codec_1$codec$d3 = lisk_codec_1.codec.decode(exports.blockHeadersSchema, value),\n                    blockHeaders = _lisk_codec_1$codec$d3.blockHeaders;\n\n                var _iterator2 = _createForOfIteratorHelper(blockHeaders),\n                    _step2;\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    var encodedHeader = _step2.value;\n                    var decodedBlockHeader = exports.decodeBlockHeader(encodedHeader, schemas);\n\n                    if (decodedBlockHeader.height < currentHeight - 260000) {\n                      res.push(key);\n                    }\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n              }).on('error', function (error) {\n                reject(error);\n              }).on('end', function () {\n                resolve(res);\n              });\n            });\n\n          case 2:\n            keys = _context5.sent;\n            batch = db.batch();\n            _iterator3 = _createForOfIteratorHelper(keys);\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                k = _step3.value;\n                batch.del(k);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            _context5.next = 8;\n            return batch.write();\n\n          case 8:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function clearBlockHeaders(_x10, _x11, _x12) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nexports.clearBlockHeaders = clearBlockHeaders;","map":{"version":3,"sources":["../src/db.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clearBlockHeaders = exports.getContradictingBlockHeader = exports.saveBlockHeaders = exports.decodeBlockHeader = exports.getBlockHeaders = exports.getDBInstance = exports.blockHeadersSchema = void 0;\nconst lisk_db_1 = require(\"@liskhq/lisk-db\");\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_bft_1 = require(\"@liskhq/lisk-bft\");\nconst os = require(\"os\");\nconst path_1 = require(\"path\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nexports.blockHeadersSchema = {\n    $id: 'lisk/reportMisbehavior/blockHeaders',\n    type: 'object',\n    required: ['blockHeaders'],\n    properties: {\n        blockHeaders: {\n            type: 'array',\n            fieldNumber: 1,\n            items: {\n                dataType: 'bytes',\n            },\n        },\n    },\n};\nconst getDBInstance = async (dataPath, dbName = 'lisk-framework-report-misbehavior-plugin.db') => {\n    const dirPath = path_1.join(dataPath.replace('~', os.homedir()), 'plugins/data', dbName);\n    await fs_extra_1.ensureDir(dirPath);\n    return new lisk_db_1.KVStore(dirPath);\n};\nexports.getDBInstance = getDBInstance;\nconst getBlockHeaders = async (db, dbKeyBlockHeader) => {\n    try {\n        const encodedBlockHeaders = await db.get(dbKeyBlockHeader);\n        return lisk_codec_1.codec.decode(exports.blockHeadersSchema, encodedBlockHeaders);\n    }\n    catch (error) {\n        return { blockHeaders: [] };\n    }\n};\nexports.getBlockHeaders = getBlockHeaders;\nconst decodeBlockHeader = (encodedHeader, schema) => {\n    const id = lisk_cryptography_1.hash(encodedHeader);\n    const blockHeader = lisk_codec_1.codec.decode(schema.blockHeader, encodedHeader);\n    const assetSchema = schema.blockHeadersAssets[blockHeader.version];\n    const asset = lisk_codec_1.codec.decode(assetSchema, blockHeader.asset);\n    return {\n        ...blockHeader,\n        asset,\n        id,\n    };\n};\nexports.decodeBlockHeader = decodeBlockHeader;\nconst saveBlockHeaders = async (db, schemas, header) => {\n    const blockId = lisk_cryptography_1.hash(header);\n    const { generatorPublicKey, height } = lisk_codec_1.codec.decode(schemas.blockHeader, header);\n    const dbKey = `${generatorPublicKey.toString('binary')}:${lisk_db_1.formatInt(height)}`;\n    const { blockHeaders } = await exports.getBlockHeaders(db, dbKey);\n    if (!blockHeaders.find(blockHeader => lisk_cryptography_1.hash(blockHeader).equals(blockId))) {\n        await db.put(dbKey, lisk_codec_1.codec.encode(exports.blockHeadersSchema, {\n            blockHeaders: [...blockHeaders, header],\n        }));\n        return true;\n    }\n    return false;\n};\nexports.saveBlockHeaders = saveBlockHeaders;\nconst getContradictingBlockHeader = async (db, blockHeader, schemas) => new Promise((resolve, reject) => {\n    const stream = db.createReadStream({\n        gte: lisk_db_1.getFirstPrefix(blockHeader.generatorPublicKey.toString('binary')),\n        lte: lisk_db_1.getLastPrefix(blockHeader.generatorPublicKey.toString('binary')),\n    });\n    stream\n        .on('data', ({ value }) => {\n        const { blockHeaders } = lisk_codec_1.codec.decode(exports.blockHeadersSchema, value);\n        for (const encodedHeader of blockHeaders) {\n            const decodedBlockHeader = exports.decodeBlockHeader(encodedHeader, schemas);\n            if (lisk_bft_1.areHeadersContradicting(blockHeader, decodedBlockHeader)) {\n                stream.destroy();\n                resolve(decodedBlockHeader);\n            }\n        }\n    })\n        .on('error', error => {\n        reject(error);\n    })\n        .on('end', () => {\n        resolve(undefined);\n    });\n});\nexports.getContradictingBlockHeader = getContradictingBlockHeader;\nconst clearBlockHeaders = async (db, schemas, currentHeight) => {\n    const keys = await new Promise((resolve, reject) => {\n        const stream = db.createReadStream();\n        const res = [];\n        stream\n            .on('data', ({ key, value }) => {\n            const { blockHeaders } = lisk_codec_1.codec.decode(exports.blockHeadersSchema, value);\n            for (const encodedHeader of blockHeaders) {\n                const decodedBlockHeader = exports.decodeBlockHeader(encodedHeader, schemas);\n                if (decodedBlockHeader.height < currentHeight - 260000) {\n                    res.push(key);\n                }\n            }\n        })\n            .on('error', error => {\n            reject(error);\n        })\n            .on('end', () => {\n            resolve(res);\n        });\n    });\n    const batch = db.batch();\n    for (const k of keys) {\n        batch.del(k);\n    }\n    await batch.write();\n};\nexports.clearBlockHeaders = clearBlockHeaders;\n//# sourceMappingURL=db.js.map"]},"metadata":{},"sourceType":"script"}