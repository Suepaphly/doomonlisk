{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTransactions = exports.getNodeInfo = void 0;\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nvar getNodeInfo = function getNodeInfo(channel) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_req, res, next) {\n      var nodeStatusAndInfo;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return channel.invoke('app:getNodeInfo');\n\n            case 3:\n              nodeStatusAndInfo = _context.sent;\n              res.status(200).send({\n                data: nodeStatusAndInfo,\n                meta: {}\n              });\n              _context.next = 10;\n              break;\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](0);\n              next(_context.t0);\n\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 7]]);\n    }));\n\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n\nexports.getNodeInfo = getNodeInfo;\n\nvar getTransactions = function getTransactions(channel, codec) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res, next) {\n      var _req$query, limit, offset, limitNumber, offsetNumber, transactionsInPool, totalTransactionsInPool, decodedTransactions, _iterator, _step, transaction;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _req$query = req.query, limit = _req$query.limit, offset = _req$query.offset;\n\n              if (!(limit && !lisk_validator_1.isNumberString(limit))) {\n                _context2.next = 4;\n                break;\n              }\n\n              res.status(400).send({\n                errors: [{\n                  message: 'The limit query parameter should be a number.'\n                }]\n              });\n              return _context2.abrupt(\"return\");\n\n            case 4:\n              limitNumber = Number(limit) || 10;\n\n              if (!(offset && !lisk_validator_1.isNumberString(offset))) {\n                _context2.next = 8;\n                break;\n              }\n\n              res.status(400).send({\n                errors: [{\n                  message: 'The offset query parameter should be a number.'\n                }]\n              });\n              return _context2.abrupt(\"return\");\n\n            case 8:\n              offsetNumber = Number(offset) || 0;\n              _context2.prev = 9;\n              _context2.next = 12;\n              return channel.invoke('app:getTransactionsFromPool');\n\n            case 12:\n              transactionsInPool = _context2.sent;\n              _context2.next = 19;\n              break;\n\n            case 15:\n              _context2.prev = 15;\n              _context2.t0 = _context2[\"catch\"](9);\n              next(_context2.t0);\n              return _context2.abrupt(\"return\");\n\n            case 19:\n              totalTransactionsInPool = transactionsInPool.length;\n              transactionsInPool = transactionsInPool.slice(offsetNumber || 0, Math.min(limitNumber + offsetNumber, transactionsInPool.length));\n              decodedTransactions = [];\n              _iterator = _createForOfIteratorHelper(transactionsInPool);\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  transaction = _step.value;\n                  decodedTransactions.push(codec.decodeTransaction(transaction));\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n              res.status(200).json({\n                data: decodedTransactions,\n                meta: {\n                  limit: limitNumber,\n                  offset: offsetNumber,\n                  total: totalTransactionsInPool\n                }\n              });\n\n            case 25:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[9, 15]]);\n    }));\n\n    return function (_x4, _x5, _x6) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n};\n\nexports.getTransactions = getTransactions;","map":{"version":3,"sources":["../../src/controllers/node.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTransactions = exports.getNodeInfo = void 0;\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst getNodeInfo = (channel) => async (_req, res, next) => {\n    try {\n        const nodeStatusAndInfo = await channel.invoke('app:getNodeInfo');\n        res.status(200).send({ data: nodeStatusAndInfo, meta: {} });\n    }\n    catch (err) {\n        next(err);\n    }\n};\nexports.getNodeInfo = getNodeInfo;\nconst getTransactions = (channel, codec) => async (req, res, next) => {\n    const { limit, offset } = req.query;\n    if (limit && !lisk_validator_1.isNumberString(limit)) {\n        res.status(400).send({\n            errors: [{ message: 'The limit query parameter should be a number.' }],\n        });\n        return;\n    }\n    const limitNumber = Number(limit) || 10;\n    if (offset && !lisk_validator_1.isNumberString(offset)) {\n        res.status(400).send({\n            errors: [{ message: 'The offset query parameter should be a number.' }],\n        });\n        return;\n    }\n    const offsetNumber = Number(offset) || 0;\n    let transactionsInPool;\n    try {\n        transactionsInPool = await channel.invoke('app:getTransactionsFromPool');\n    }\n    catch (err) {\n        next(err);\n        return;\n    }\n    const totalTransactionsInPool = transactionsInPool.length;\n    transactionsInPool = transactionsInPool.slice(offsetNumber || 0, Math.min(limitNumber + offsetNumber, transactionsInPool.length));\n    const decodedTransactions = [];\n    for (const transaction of transactionsInPool) {\n        decodedTransactions.push(codec.decodeTransaction(transaction));\n    }\n    res.status(200).json({\n        data: decodedTransactions,\n        meta: { limit: limitNumber, offset: offsetNumber, total: totalTransactionsInPool },\n    });\n};\nexports.getTransactions = getTransactions;\n//# sourceMappingURL=node.js.map"]},"metadata":{},"sourceType":"script"}