{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyData = exports.signData = exports.signDataWithPassphrase = exports.signDataWithPrivateKey = exports.signAndPrintMessage = exports.printSignedMessage = exports.verifyMessageWithPublicKey = exports.signMessageWithPassphrase = exports.digestMessage = void 0;\n\nvar varuint_bitcoin_1 = require(\"varuint-bitcoin\");\n\nvar constants_1 = require(\"./constants\");\n\nvar hash_1 = require(\"./hash\");\n\nvar keys_1 = require(\"./keys\");\n\nvar nacl_1 = require(\"./nacl\");\n\nvar createHeader = function createHeader(text) {\n  return \"-----\".concat(text, \"-----\");\n};\n\nvar signedMessageHeader = createHeader('BEGIN LISK SIGNED MESSAGE');\nvar messageHeader = createHeader('MESSAGE');\nvar publicKeyHeader = createHeader('PUBLIC KEY');\nvar signatureHeader = createHeader('SIGNATURE');\nvar signatureFooter = createHeader('END LISK SIGNED MESSAGE');\nvar SIGNED_MESSAGE_PREFIX_BYTES = Buffer.from(constants_1.SIGNED_MESSAGE_PREFIX, 'utf8');\nvar SIGNED_MESSAGE_PREFIX_LENGTH = varuint_bitcoin_1.encode(constants_1.SIGNED_MESSAGE_PREFIX.length);\n\nvar digestMessage = function digestMessage(message) {\n  var msgBytes = Buffer.from(message, 'utf8');\n  var msgLenBytes = varuint_bitcoin_1.encode(message.length);\n  var dataBytes = Buffer.concat([SIGNED_MESSAGE_PREFIX_LENGTH, SIGNED_MESSAGE_PREFIX_BYTES, msgLenBytes, msgBytes]);\n  return hash_1.hash(hash_1.hash(dataBytes));\n};\n\nexports.digestMessage = digestMessage;\n\nvar signMessageWithPassphrase = function signMessageWithPassphrase(message, passphrase) {\n  var msgBytes = exports.digestMessage(message);\n\n  var _keys_1$getPrivateAnd = keys_1.getPrivateAndPublicKeyFromPassphrase(passphrase),\n      privateKey = _keys_1$getPrivateAnd.privateKey,\n      publicKey = _keys_1$getPrivateAnd.publicKey;\n\n  var signature = nacl_1.signDetached(msgBytes, privateKey);\n  return {\n    message: message,\n    publicKey: publicKey,\n    signature: signature\n  };\n};\n\nexports.signMessageWithPassphrase = signMessageWithPassphrase;\n\nvar verifyMessageWithPublicKey = function verifyMessageWithPublicKey(_ref) {\n  var message = _ref.message,\n      publicKey = _ref.publicKey,\n      signature = _ref.signature;\n  var msgBytes = exports.digestMessage(message);\n\n  if (publicKey.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n    throw new Error(\"Invalid publicKey, expected \".concat(nacl_1.NACL_SIGN_PUBLICKEY_LENGTH.toString(), \"-byte publicKey\"));\n  }\n\n  if (signature.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n    throw new Error(\"Invalid signature length, expected \".concat(nacl_1.NACL_SIGN_SIGNATURE_LENGTH.toString(), \"-byte signature\"));\n  }\n\n  return nacl_1.verifyDetached(msgBytes, signature, publicKey);\n};\n\nexports.verifyMessageWithPublicKey = verifyMessageWithPublicKey;\n\nvar printSignedMessage = function printSignedMessage(_ref2) {\n  var message = _ref2.message,\n      signature = _ref2.signature,\n      publicKey = _ref2.publicKey;\n  return [signedMessageHeader, messageHeader, message, publicKeyHeader, publicKey.toString('hex'), signatureHeader, signature.toString('hex'), signatureFooter].filter(Boolean).join('\\n');\n};\n\nexports.printSignedMessage = printSignedMessage;\n\nvar signAndPrintMessage = function signAndPrintMessage(message, passphrase) {\n  var signedMessage = exports.signMessageWithPassphrase(message, passphrase);\n  return exports.printSignedMessage(signedMessage);\n};\n\nexports.signAndPrintMessage = signAndPrintMessage;\n\nvar signDataWithPrivateKey = function signDataWithPrivateKey(data, privateKey) {\n  return nacl_1.signDetached(data, privateKey);\n};\n\nexports.signDataWithPrivateKey = signDataWithPrivateKey;\n\nvar signDataWithPassphrase = function signDataWithPassphrase(data, passphrase) {\n  var _keys_1$getPrivateAnd2 = keys_1.getPrivateAndPublicKeyFromPassphrase(passphrase),\n      privateKey = _keys_1$getPrivateAnd2.privateKey;\n\n  return exports.signDataWithPrivateKey(data, privateKey);\n};\n\nexports.signDataWithPassphrase = signDataWithPassphrase;\nexports.signData = exports.signDataWithPassphrase;\n\nvar verifyData = function verifyData(data, signature, publicKey) {\n  return nacl_1.verifyDetached(data, signature, publicKey);\n};\n\nexports.verifyData = verifyData;","map":{"version":3,"sources":["../src/sign.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifyData = exports.signData = exports.signDataWithPassphrase = exports.signDataWithPrivateKey = exports.signAndPrintMessage = exports.printSignedMessage = exports.verifyMessageWithPublicKey = exports.signMessageWithPassphrase = exports.digestMessage = void 0;\nconst varuint_bitcoin_1 = require(\"varuint-bitcoin\");\nconst constants_1 = require(\"./constants\");\nconst hash_1 = require(\"./hash\");\nconst keys_1 = require(\"./keys\");\nconst nacl_1 = require(\"./nacl\");\nconst createHeader = (text) => `-----${text}-----`;\nconst signedMessageHeader = createHeader('BEGIN LISK SIGNED MESSAGE');\nconst messageHeader = createHeader('MESSAGE');\nconst publicKeyHeader = createHeader('PUBLIC KEY');\nconst signatureHeader = createHeader('SIGNATURE');\nconst signatureFooter = createHeader('END LISK SIGNED MESSAGE');\nconst SIGNED_MESSAGE_PREFIX_BYTES = Buffer.from(constants_1.SIGNED_MESSAGE_PREFIX, 'utf8');\nconst SIGNED_MESSAGE_PREFIX_LENGTH = varuint_bitcoin_1.encode(constants_1.SIGNED_MESSAGE_PREFIX.length);\nconst digestMessage = (message) => {\n    const msgBytes = Buffer.from(message, 'utf8');\n    const msgLenBytes = varuint_bitcoin_1.encode(message.length);\n    const dataBytes = Buffer.concat([\n        SIGNED_MESSAGE_PREFIX_LENGTH,\n        SIGNED_MESSAGE_PREFIX_BYTES,\n        msgLenBytes,\n        msgBytes,\n    ]);\n    return hash_1.hash(hash_1.hash(dataBytes));\n};\nexports.digestMessage = digestMessage;\nconst signMessageWithPassphrase = (message, passphrase) => {\n    const msgBytes = exports.digestMessage(message);\n    const { privateKey, publicKey } = keys_1.getPrivateAndPublicKeyFromPassphrase(passphrase);\n    const signature = nacl_1.signDetached(msgBytes, privateKey);\n    return {\n        message,\n        publicKey,\n        signature,\n    };\n};\nexports.signMessageWithPassphrase = signMessageWithPassphrase;\nconst verifyMessageWithPublicKey = ({ message, publicKey, signature, }) => {\n    const msgBytes = exports.digestMessage(message);\n    if (publicKey.length !== nacl_1.NACL_SIGN_PUBLICKEY_LENGTH) {\n        throw new Error(`Invalid publicKey, expected ${nacl_1.NACL_SIGN_PUBLICKEY_LENGTH.toString()}-byte publicKey`);\n    }\n    if (signature.length !== nacl_1.NACL_SIGN_SIGNATURE_LENGTH) {\n        throw new Error(`Invalid signature length, expected ${nacl_1.NACL_SIGN_SIGNATURE_LENGTH.toString()}-byte signature`);\n    }\n    return nacl_1.verifyDetached(msgBytes, signature, publicKey);\n};\nexports.verifyMessageWithPublicKey = verifyMessageWithPublicKey;\nconst printSignedMessage = ({ message, signature, publicKey }) => [\n    signedMessageHeader,\n    messageHeader,\n    message,\n    publicKeyHeader,\n    publicKey.toString('hex'),\n    signatureHeader,\n    signature.toString('hex'),\n    signatureFooter,\n]\n    .filter(Boolean)\n    .join('\\n');\nexports.printSignedMessage = printSignedMessage;\nconst signAndPrintMessage = (message, passphrase) => {\n    const signedMessage = exports.signMessageWithPassphrase(message, passphrase);\n    return exports.printSignedMessage(signedMessage);\n};\nexports.signAndPrintMessage = signAndPrintMessage;\nconst signDataWithPrivateKey = (data, privateKey) => nacl_1.signDetached(data, privateKey);\nexports.signDataWithPrivateKey = signDataWithPrivateKey;\nconst signDataWithPassphrase = (data, passphrase) => {\n    const { privateKey } = keys_1.getPrivateAndPublicKeyFromPassphrase(passphrase);\n    return exports.signDataWithPrivateKey(data, privateKey);\n};\nexports.signDataWithPassphrase = signDataWithPassphrase;\nexports.signData = exports.signDataWithPassphrase;\nconst verifyData = (data, signature, publicKey) => nacl_1.verifyDetached(data, signature, publicKey);\nexports.verifyData = verifyData;\n//# sourceMappingURL=sign.js.map"]},"metadata":{},"sourceType":"script"}