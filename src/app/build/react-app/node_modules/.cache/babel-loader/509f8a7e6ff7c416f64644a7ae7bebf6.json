{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dataTypeKeyword = exports.metaSchema = void 0;\n\nvar createDebug = require(\"debug\");\n\nvar errors_1 = require(\"../errors\");\n\nvar validation_1 = require(\"../validation\");\n\nvar debug = createDebug('codec:keyword:dataType');\nexports.metaSchema = {\n  title: 'Lisk Codec Data Type',\n  type: 'string',\n  enum: ['bytes', 'uint32', 'sint32', 'uint64', 'sint64', 'string', 'boolean']\n};\n\nvar compile = function compile(value, parentSchema, it) {\n  var _a;\n\n  debug('compile: value: %s', value);\n  debug('compile: parent schema: %j', parentSchema);\n  var typePropertyPresent = Object.keys(parentSchema).includes('type');\n\n  if (typePropertyPresent) {\n    throw new errors_1.LiskValidationError([{\n      keyword: 'dataType',\n      message: 'Either \"dataType\" or \"type\" can be presented in schema',\n      params: {\n        dataType: value\n      },\n      dataPath: '',\n      schemaPath: (_a = it.schemaPath.str) !== null && _a !== void 0 ? _a : ''\n    }]);\n  }\n\n  var validate = function validate(data, _dataCxt) {\n    if (value === 'boolean') {\n      return validation_1.isBoolean(data);\n    }\n\n    if (value === 'bytes') {\n      if (!validation_1.isBytes(data)) {\n        return false;\n      }\n\n      var parent = parentSchema;\n\n      if (typeof parent.minLength === 'number') {\n        var length = data.length;\n\n        if (length < parent.minLength) {\n          validate.errors = [{\n            keyword: 'dataType',\n            message: 'minLength not satisfied',\n            params: {\n              dataType: value,\n              minLength: parent.minLength,\n              length: length\n            }\n          }];\n          return false;\n        }\n      }\n\n      if (typeof parent.maxLength === 'number') {\n        var _length = data.length;\n\n        if (_length > parent.maxLength) {\n          validate.errors = [{\n            keyword: 'dataType',\n            message: 'maxLength exceeded',\n            params: {\n              dataType: value,\n              maxLength: parent.maxLength,\n              length: _length\n            }\n          }];\n          return false;\n        }\n      }\n    }\n\n    if (value === 'string') {\n      return validation_1.isString(data);\n    }\n\n    if (value === 'uint32') {\n      return validation_1.isUInt32(data);\n    }\n\n    if (value === 'uint64') {\n      return validation_1.isUInt64(data);\n    }\n\n    if (value === 'sint32') {\n      return validation_1.isSInt32(data);\n    }\n\n    if (value === 'sint64') {\n      return validation_1.isSInt64(data);\n    }\n\n    return true;\n  };\n\n  return validate;\n};\n\nexports.dataTypeKeyword = {\n  keyword: 'dataType',\n  compile: compile,\n  errors: 'full',\n  modifying: false,\n  metaSchema: exports.metaSchema\n};","map":{"version":3,"sources":["../../src/keywords/data_type.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dataTypeKeyword = exports.metaSchema = void 0;\nconst createDebug = require(\"debug\");\nconst errors_1 = require(\"../errors\");\nconst validation_1 = require(\"../validation\");\nconst debug = createDebug('codec:keyword:dataType');\nexports.metaSchema = {\n    title: 'Lisk Codec Data Type',\n    type: 'string',\n    enum: ['bytes', 'uint32', 'sint32', 'uint64', 'sint64', 'string', 'boolean'],\n};\nconst compile = (value, parentSchema, it) => {\n    var _a;\n    debug('compile: value: %s', value);\n    debug('compile: parent schema: %j', parentSchema);\n    const typePropertyPresent = Object.keys(parentSchema).includes('type');\n    if (typePropertyPresent) {\n        throw new errors_1.LiskValidationError([\n            {\n                keyword: 'dataType',\n                message: 'Either \"dataType\" or \"type\" can be presented in schema',\n                params: { dataType: value },\n                dataPath: '',\n                schemaPath: (_a = it.schemaPath.str) !== null && _a !== void 0 ? _a : '',\n            },\n        ]);\n    }\n    const validate = (data, _dataCxt) => {\n        if (value === 'boolean') {\n            return validation_1.isBoolean(data);\n        }\n        if (value === 'bytes') {\n            if (!validation_1.isBytes(data)) {\n                return false;\n            }\n            const parent = parentSchema;\n            if (typeof parent.minLength === 'number') {\n                const { length } = data;\n                if (length < parent.minLength) {\n                    validate.errors = [\n                        {\n                            keyword: 'dataType',\n                            message: 'minLength not satisfied',\n                            params: { dataType: value, minLength: parent.minLength, length },\n                        },\n                    ];\n                    return false;\n                }\n            }\n            if (typeof parent.maxLength === 'number') {\n                const { length } = data;\n                if (length > parent.maxLength) {\n                    validate.errors = [\n                        {\n                            keyword: 'dataType',\n                            message: 'maxLength exceeded',\n                            params: { dataType: value, maxLength: parent.maxLength, length },\n                        },\n                    ];\n                    return false;\n                }\n            }\n        }\n        if (value === 'string') {\n            return validation_1.isString(data);\n        }\n        if (value === 'uint32') {\n            return validation_1.isUInt32(data);\n        }\n        if (value === 'uint64') {\n            return validation_1.isUInt64(data);\n        }\n        if (value === 'sint32') {\n            return validation_1.isSInt32(data);\n        }\n        if (value === 'sint64') {\n            return validation_1.isSInt64(data);\n        }\n        return true;\n    };\n    return validate;\n};\nexports.dataTypeKeyword = {\n    keyword: 'dataType',\n    compile,\n    errors: 'full',\n    modifying: false,\n    metaSchema: exports.metaSchema,\n};\n//# sourceMappingURL=data_type.js.map"]},"metadata":{},"sourceType":"script"}