{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Network = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar lisk_db_1 = require(\"@liskhq/lisk-db\");\n\nvar events_1 = require(\"events\");\n\nvar liskP2P = require(\"@liskhq/lisk-p2p\");\n\nvar constants_1 = require(\"../../constants\");\n\nvar utils_1 = require(\"./utils\");\n\nvar schema_1 = require(\"./schema\");\n\nvar P2P = liskP2P.P2P,\n    _liskP2P$events = liskP2P.events,\n    EVENT_NETWORK_READY = _liskP2P$events.EVENT_NETWORK_READY,\n    EVENT_NEW_INBOUND_PEER = _liskP2P$events.EVENT_NEW_INBOUND_PEER,\n    EVENT_CLOSE_INBOUND = _liskP2P$events.EVENT_CLOSE_INBOUND,\n    EVENT_CLOSE_OUTBOUND = _liskP2P$events.EVENT_CLOSE_OUTBOUND,\n    EVENT_CONNECT_OUTBOUND = _liskP2P$events.EVENT_CONNECT_OUTBOUND,\n    EVENT_DISCOVERED_PEER = _liskP2P$events.EVENT_DISCOVERED_PEER,\n    EVENT_FAILED_TO_FETCH_PEER_INFO = _liskP2P$events.EVENT_FAILED_TO_FETCH_PEER_INFO,\n    EVENT_FAILED_TO_PUSH_NODE_INFO = _liskP2P$events.EVENT_FAILED_TO_PUSH_NODE_INFO,\n    EVENT_OUTBOUND_SOCKET_ERROR = _liskP2P$events.EVENT_OUTBOUND_SOCKET_ERROR,\n    EVENT_INBOUND_SOCKET_ERROR = _liskP2P$events.EVENT_INBOUND_SOCKET_ERROR,\n    EVENT_UPDATED_PEER_INFO = _liskP2P$events.EVENT_UPDATED_PEER_INFO,\n    EVENT_FAILED_PEER_INFO_UPDATE = _liskP2P$events.EVENT_FAILED_PEER_INFO_UPDATE,\n    EVENT_REQUEST_RECEIVED = _liskP2P$events.EVENT_REQUEST_RECEIVED,\n    EVENT_MESSAGE_RECEIVED = _liskP2P$events.EVENT_MESSAGE_RECEIVED,\n    EVENT_BAN_PEER = _liskP2P$events.EVENT_BAN_PEER;\nvar DB_KEY_NETWORK_NODE_SECRET = 'network:nodeSecret';\nvar DB_KEY_NETWORK_TRIED_PEERS_LIST = 'network:triedPeersList';\nvar DEFAULT_PEER_SAVE_INTERVAL = 10 * 60 * 1000;\nvar REMOTE_EVENTS_WHITE_LIST = [constants_1.EVENT_POST_BLOCK, constants_1.EVENT_POST_NODE_INFO, constants_1.EVENT_POST_TRANSACTION_ANNOUNCEMENT];\n\nvar Network = /*#__PURE__*/function () {\n  function Network(_ref) {\n    var options = _ref.options,\n        channel = _ref.channel,\n        logger = _ref.logger,\n        nodeDB = _ref.nodeDB,\n        networkVersion = _ref.networkVersion;\n\n    _classCallCheck(this, Network);\n\n    this._options = options;\n    this._channel = channel;\n    this._logger = logger;\n    this._nodeDB = nodeDB;\n    this._networkVersion = networkVersion;\n    this._endpoints = {};\n    this._secret = undefined;\n    this.events = new events_1.EventEmitter();\n  }\n\n  _createClass(Network, [{\n    key: \"bootstrap\",\n    value: function () {\n      var _bootstrap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(networkIdentifier) {\n        var _this = this;\n\n        var _a, _b, previousPeers, previousPeersBuffer, secret, initialNodeInfo, seedPeers, blacklistedIPs, fixedPeers, whitelistedPeers, p2pConfig;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._networkID = networkIdentifier.toString('hex');\n                previousPeers = [];\n                _context3.prev = 2;\n                _context3.next = 5;\n                return this._nodeDB.get(DB_KEY_NETWORK_TRIED_PEERS_LIST);\n\n              case 5:\n                previousPeersBuffer = _context3.sent;\n                previousPeers = JSON.parse(previousPeersBuffer.toString('utf8'));\n                _context3.next = 12;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](2);\n\n                if (!(_context3.t0 instanceof lisk_db_1.NotFoundError)) {\n                  this._logger.error({\n                    err: _context3.t0\n                  }, 'Error while querying nodeDB');\n                }\n\n              case 12:\n                _context3.prev = 12;\n                _context3.next = 15;\n                return this._nodeDB.get(DB_KEY_NETWORK_NODE_SECRET);\n\n              case 15:\n                secret = _context3.sent;\n                _context3.next = 21;\n                break;\n\n              case 18:\n                _context3.prev = 18;\n                _context3.t1 = _context3[\"catch\"](12);\n\n                if (!(_context3.t1 instanceof lisk_db_1.NotFoundError)) {\n                  this._logger.error({\n                    err: _context3.t1\n                  }, 'Error while querying nodeDB');\n                }\n\n              case 21:\n                if (secret) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                secret = lisk_cryptography_1.getRandomBytes(4);\n                _context3.next = 25;\n                return this._nodeDB.put(DB_KEY_NETWORK_NODE_SECRET, secret);\n\n              case 25:\n                this._secret = secret === null || secret === void 0 ? void 0 : secret.readUInt32BE(0);\n                initialNodeInfo = {\n                  networkIdentifier: this._networkID,\n                  networkVersion: this._networkVersion,\n                  nonce: '',\n                  advertiseAddress: (_a = this._options.advertiseAddress) !== null && _a !== void 0 ? _a : true,\n                  options: {\n                    lastBlockID: Buffer.alloc(0),\n                    blockVersion: 0,\n                    height: 0,\n                    maxHeightPrevoted: 0\n                  }\n                };\n                _context3.next = 29;\n                return utils_1.lookupPeersIPs(this._options.seedPeers, true);\n\n              case 29:\n                seedPeers = _context3.sent;\n                blacklistedIPs = (_b = this._options.blacklistedIPs) !== null && _b !== void 0 ? _b : [];\n                fixedPeers = this._options.fixedPeers ? this._options.fixedPeers.map(function (peer) {\n                  return {\n                    ipAddress: peer.ip,\n                    port: peer.port\n                  };\n                }) : [];\n                whitelistedPeers = this._options.whitelistedPeers ? this._options.whitelistedPeers.map(function (peer) {\n                  return {\n                    ipAddress: peer.ip,\n                    port: peer.port\n                  };\n                }) : [];\n                p2pConfig = {\n                  port: this._options.port,\n                  nodeInfo: initialNodeInfo,\n                  hostIp: this._options.hostIp,\n                  blacklistedIPs: blacklistedIPs,\n                  fixedPeers: fixedPeers,\n                  whitelistedPeers: whitelistedPeers,\n                  seedPeers: seedPeers.map(function (peer) {\n                    return {\n                      ipAddress: peer.ip,\n                      port: peer.port\n                    };\n                  }),\n                  previousPeers: previousPeers,\n                  maxOutboundConnections: this._options.maxOutboundConnections,\n                  maxInboundConnections: this._options.maxInboundConnections,\n                  peerBanTime: this._options.peerBanTime,\n                  sendPeerLimit: this._options.sendPeerLimit,\n                  maxPeerDiscoveryResponseLength: this._options.maxPeerDiscoveryResponseLength,\n                  maxPeerInfoSize: this._options.maxPeerInfoSize,\n                  wsMaxPayload: this._options.wsMaxPayload,\n                  secret: this._secret,\n                  customNodeInfoSchema: schema_1.customNodeInfoSchema\n                };\n                this._p2p = new P2P(p2pConfig);\n\n                this._p2p.on(EVENT_NETWORK_READY, function () {\n                  _this._logger.debug('Node connected to the network');\n\n                  _this.events.emit(constants_1.APP_EVENT_NETWORK_READY);\n\n                  _this._channel.publish(constants_1.APP_EVENT_NETWORK_READY);\n                });\n\n                this._p2p.on(EVENT_CLOSE_OUTBOUND, function (_ref2) {\n                  var peerInfo = _ref2.peerInfo,\n                      code = _ref2.code,\n                      reason = _ref2.reason;\n\n                  _this._logger.debug(_objectSpread(_objectSpread({}, peerInfo), {}, {\n                    code: code,\n                    reason: reason\n                  }), 'EVENT_CLOSE_OUTBOUND: Close outbound peer connection');\n                });\n\n                this._p2p.on(EVENT_CLOSE_INBOUND, function (_ref3) {\n                  var peerInfo = _ref3.peerInfo,\n                      code = _ref3.code,\n                      reason = _ref3.reason;\n\n                  _this._logger.debug(_objectSpread(_objectSpread({}, peerInfo), {}, {\n                    code: code,\n                    reason: reason\n                  }), 'EVENT_CLOSE_INBOUND: Close inbound peer connection');\n                });\n\n                this._p2p.on(EVENT_CONNECT_OUTBOUND, function (peerInfo) {\n                  _this._logger.debug(_objectSpread({}, peerInfo), 'EVENT_CONNECT_OUTBOUND: Outbound peer connection');\n                });\n\n                this._p2p.on(EVENT_DISCOVERED_PEER, function (peerInfo) {\n                  _this._logger.trace(_objectSpread({}, peerInfo), 'EVENT_DISCOVERED_PEER: Discovered peer connection');\n                });\n\n                this._p2p.on(EVENT_NEW_INBOUND_PEER, function (peerInfo) {\n                  _this._logger.debug(_objectSpread({}, peerInfo), 'EVENT_NEW_INBOUND_PEER: Inbound peer connection');\n                });\n\n                this._p2p.on(EVENT_FAILED_TO_FETCH_PEER_INFO, function (error) {\n                  _this._logger.error({\n                    err: error\n                  }, 'EVENT_FAILED_TO_FETCH_PEER_INFO: Failed to fetch peer info');\n                });\n\n                this._p2p.on(EVENT_FAILED_TO_PUSH_NODE_INFO, function (error) {\n                  _this._logger.trace({\n                    err: error\n                  }, 'EVENT_FAILED_TO_PUSH_NODE_INFO: Failed to push node info');\n                });\n\n                this._p2p.on(EVENT_OUTBOUND_SOCKET_ERROR, function (error) {\n                  _this._logger.debug({\n                    err: error\n                  }, 'EVENT_OUTBOUND_SOCKET_ERROR: Outbound socket error');\n                });\n\n                this._p2p.on(EVENT_INBOUND_SOCKET_ERROR, function (error) {\n                  _this._logger.debug({\n                    err: error\n                  }, 'EVENT_INBOUND_SOCKET_ERROR: Inbound socket error');\n                });\n\n                this._p2p.on(EVENT_UPDATED_PEER_INFO, function (peerInfo) {\n                  _this._logger.trace(_objectSpread({}, peerInfo), 'EVENT_UPDATED_PEER_INFO: Update peer info');\n                });\n\n                this._p2p.on(EVENT_FAILED_PEER_INFO_UPDATE, function (error) {\n                  _this._logger.error({\n                    err: error\n                  }, 'EVENT_FAILED_PEER_INFO_UPDATE: Failed peer update');\n                });\n\n                this._p2p.on(EVENT_REQUEST_RECEIVED, /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(request) {\n                    var error, result;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _this._logger.trace({\n                              procedure: request.procedure\n                            }, 'EVENT_REQUEST_RECEIVED: Received inbound request for procedure');\n\n                            if (!request.wasResponseSent) {\n                              _context.next = 3;\n                              break;\n                            }\n\n                            return _context.abrupt(\"return\");\n\n                          case 3:\n                            if (Object.keys(_this._endpoints).includes(request.procedure)) {\n                              _context.next = 9;\n                              break;\n                            }\n\n                            error = new Error(\"Requested procedure \\\"\".concat(request.procedure, \"\\\" is not permitted.\"));\n\n                            _this._logger.error({\n                              err: error,\n                              procedure: request.procedure\n                            }, 'Peer request not fulfilled event: Requested procedure is not permitted.');\n\n                            _this._p2p.applyPenalty({\n                              peerId: request.peerId,\n                              penalty: 100\n                            });\n\n                            request.error(error);\n                            return _context.abrupt(\"return\");\n\n                          case 9:\n                            _context.prev = 9;\n                            _context.next = 12;\n                            return _this._endpoints[request.procedure]({\n                              data: request.data,\n                              peerId: request.peerId\n                            });\n\n                          case 12:\n                            result = _context.sent;\n\n                            _this._logger.trace({\n                              procedure: request.procedure\n                            }, 'Peer request fulfilled event: Responded to peer request');\n\n                            request.end(result);\n                            _context.next = 21;\n                            break;\n\n                          case 17:\n                            _context.prev = 17;\n                            _context.t0 = _context[\"catch\"](9);\n\n                            _this._logger.error({\n                              err: _context.t0,\n                              procedure: request.procedure\n                            }, 'Peer request not fulfilled event: Could not respond to peer request');\n\n                            request.error(_context.t0);\n\n                          case 21:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, null, [[9, 17]]);\n                  }));\n\n                  return function (_x2) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }());\n\n                this._p2p.on(EVENT_MESSAGE_RECEIVED, function (packet) {\n                  if (!REMOTE_EVENTS_WHITE_LIST.includes(packet.event)) {\n                    var error = new Error(\"Sent event \\\"\".concat(packet.event, \"\\\" is not permitted.\"));\n\n                    _this._logger.error({\n                      err: error,\n                      event: packet.event\n                    }, 'Peer request not fulfilled. Sent event is not permitted.');\n\n                    _this._p2p.applyPenalty({\n                      peerId: packet.peerId,\n                      penalty: 100\n                    });\n\n                    return;\n                  }\n\n                  _this._logger.trace({\n                    peerId: packet.peerId,\n                    event: packet.event\n                  }, 'EVENT_MESSAGE_RECEIVED: Received inbound message');\n\n                  _this.events.emit(constants_1.APP_EVENT_NETWORK_EVENT, packet);\n                });\n\n                this._p2p.on(EVENT_BAN_PEER, function (peerId) {\n                  _this._logger.error({\n                    peerId: peerId\n                  }, 'EVENT_MESSAGE_RECEIVED: Peer has been banned temporarily');\n                });\n\n                setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                  var triedPeers;\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          triedPeers = _this._p2p.getTriedPeers();\n\n                          if (!triedPeers.length) {\n                            _context2.next = 4;\n                            break;\n                          }\n\n                          _context2.next = 4;\n                          return _this._nodeDB.put(DB_KEY_NETWORK_TRIED_PEERS_LIST, Buffer.from(JSON.stringify(triedPeers), 'utf8'));\n\n                        case 4:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2);\n                })), DEFAULT_PEER_SAVE_INTERVAL);\n                _context3.prev = 51;\n                _context3.next = 54;\n                return this._p2p.start();\n\n              case 54:\n                _context3.next = 60;\n                break;\n\n              case 56:\n                _context3.prev = 56;\n                _context3.t2 = _context3[\"catch\"](51);\n\n                this._logger.fatal({\n                  message: _context3.t2.message,\n                  stack: _context3.t2.stack\n                }, 'Failed to initialize network');\n\n                throw _context3.t2;\n\n              case 60:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 9], [12, 18], [51, 56]]);\n      }));\n\n      function bootstrap(_x) {\n        return _bootstrap.apply(this, arguments);\n      }\n\n      return bootstrap;\n    }()\n  }, {\n    key: \"registerEndpoint\",\n    value: function registerEndpoint(endpoint, handler) {\n      if (this._endpoints[endpoint]) {\n        throw new Error(\"Endpoint \".concat(endpoint, \" has already been registered.\"));\n      }\n\n      this._endpoints[endpoint] = handler;\n    }\n  }, {\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(requestPacket) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this._p2p.request({\n                  procedure: requestPacket.procedure,\n                  data: requestPacket.data\n                }));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function request(_x3) {\n        return _request.apply(this, arguments);\n      }\n\n      return request;\n    }()\n  }, {\n    key: \"send\",\n    value: function send(sendPacket) {\n      return this._p2p.send({\n        event: sendPacket.event,\n        data: sendPacket.data\n      });\n    }\n  }, {\n    key: \"requestFromPeer\",\n    value: function () {\n      var _requestFromPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(requestPacket) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this._p2p.requestFromPeer({\n                  procedure: requestPacket.procedure,\n                  data: requestPacket.data\n                }, requestPacket.peerId));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function requestFromPeer(_x4) {\n        return _requestFromPeer.apply(this, arguments);\n      }\n\n      return requestFromPeer;\n    }()\n  }, {\n    key: \"sendToPeer\",\n    value: function sendToPeer(sendPacket) {\n      return this._p2p.sendToPeer({\n        event: sendPacket.event,\n        data: sendPacket.data\n      }, sendPacket.peerId);\n    }\n  }, {\n    key: \"broadcast\",\n    value: function broadcast(broadcastPacket) {\n      return this._p2p.broadcast({\n        event: broadcastPacket.event,\n        data: broadcastPacket.data\n      });\n    }\n  }, {\n    key: \"getConnectedPeers\",\n    value: function getConnectedPeers() {\n      var peers = this._p2p.getConnectedPeers();\n\n      return peers.map(function (peer) {\n        var parsedPeer = _objectSpread({}, peer);\n\n        if (parsedPeer.options) {\n          parsedPeer.options = lisk_codec_1.codec.toJSON(schema_1.customNodeInfoSchema, parsedPeer.options);\n        }\n\n        return parsedPeer;\n      });\n    }\n  }, {\n    key: \"getNetworkStats\",\n    value: function getNetworkStats() {\n      return this._p2p.getNetworkStats();\n    }\n  }, {\n    key: \"getDisconnectedPeers\",\n    value: function getDisconnectedPeers() {\n      var peers = this._p2p.getDisconnectedPeers();\n\n      return peers.map(function (peer) {\n        var parsedPeer = _objectSpread({}, peer);\n\n        if (parsedPeer.options) {\n          parsedPeer.options = lisk_codec_1.codec.toJSON(schema_1.customNodeInfoSchema, parsedPeer.options);\n        }\n\n        return parsedPeer;\n      });\n    }\n  }, {\n    key: \"applyPenaltyOnPeer\",\n    value: function applyPenaltyOnPeer(penaltyPacket) {\n      return this._p2p.applyPenalty({\n        peerId: penaltyPacket.peerId,\n        penalty: penaltyPacket.penalty\n      });\n    }\n  }, {\n    key: \"applyNodeInfo\",\n    value: function applyNodeInfo(data) {\n      var _a;\n\n      var newNodeInfo = {\n        networkIdentifier: this._networkID,\n        networkVersion: this._networkVersion,\n        advertiseAddress: (_a = this._options.advertiseAddress) !== null && _a !== void 0 ? _a : true,\n        options: data\n      };\n\n      try {\n        this._p2p.applyNodeInfo(newNodeInfo);\n      } catch (error) {\n        this._logger.error({\n          err: error\n        }, 'Applying NodeInfo failed because of error');\n      }\n    }\n  }, {\n    key: \"cleanup\",\n    value: function () {\n      var _cleanup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this._logger.info('Network cleanup started');\n\n                _context6.next = 3;\n                return this._p2p.stop();\n\n              case 3:\n                this._logger.info('Network cleanup completed');\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function cleanup() {\n        return _cleanup.apply(this, arguments);\n      }\n\n      return cleanup;\n    }()\n  }]);\n\n  return Network;\n}();\n\nexports.Network = Network;","map":{"version":3,"sources":["../../../src/node/network/network.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Network = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_db_1 = require(\"@liskhq/lisk-db\");\nconst events_1 = require(\"events\");\nconst liskP2P = require(\"@liskhq/lisk-p2p\");\nconst constants_1 = require(\"../../constants\");\nconst utils_1 = require(\"./utils\");\nconst schema_1 = require(\"./schema\");\nconst { P2P, events: { EVENT_NETWORK_READY, EVENT_NEW_INBOUND_PEER, EVENT_CLOSE_INBOUND, EVENT_CLOSE_OUTBOUND, EVENT_CONNECT_OUTBOUND, EVENT_DISCOVERED_PEER, EVENT_FAILED_TO_FETCH_PEER_INFO, EVENT_FAILED_TO_PUSH_NODE_INFO, EVENT_OUTBOUND_SOCKET_ERROR, EVENT_INBOUND_SOCKET_ERROR, EVENT_UPDATED_PEER_INFO, EVENT_FAILED_PEER_INFO_UPDATE, EVENT_REQUEST_RECEIVED, EVENT_MESSAGE_RECEIVED, EVENT_BAN_PEER, }, } = liskP2P;\nconst DB_KEY_NETWORK_NODE_SECRET = 'network:nodeSecret';\nconst DB_KEY_NETWORK_TRIED_PEERS_LIST = 'network:triedPeersList';\nconst DEFAULT_PEER_SAVE_INTERVAL = 10 * 60 * 1000;\nconst REMOTE_EVENTS_WHITE_LIST = [\n    constants_1.EVENT_POST_BLOCK,\n    constants_1.EVENT_POST_NODE_INFO,\n    constants_1.EVENT_POST_TRANSACTION_ANNOUNCEMENT,\n];\nclass Network {\n    constructor({ options, channel, logger, nodeDB, networkVersion }) {\n        this._options = options;\n        this._channel = channel;\n        this._logger = logger;\n        this._nodeDB = nodeDB;\n        this._networkVersion = networkVersion;\n        this._endpoints = {};\n        this._secret = undefined;\n        this.events = new events_1.EventEmitter();\n    }\n    async bootstrap(networkIdentifier) {\n        var _a, _b;\n        this._networkID = networkIdentifier.toString('hex');\n        let previousPeers = [];\n        try {\n            const previousPeersBuffer = await this._nodeDB.get(DB_KEY_NETWORK_TRIED_PEERS_LIST);\n            previousPeers = JSON.parse(previousPeersBuffer.toString('utf8'));\n        }\n        catch (error) {\n            if (!(error instanceof lisk_db_1.NotFoundError)) {\n                this._logger.error({ err: error }, 'Error while querying nodeDB');\n            }\n        }\n        let secret;\n        try {\n            secret = await this._nodeDB.get(DB_KEY_NETWORK_NODE_SECRET);\n        }\n        catch (error) {\n            if (!(error instanceof lisk_db_1.NotFoundError)) {\n                this._logger.error({ err: error }, 'Error while querying nodeDB');\n            }\n        }\n        if (!secret) {\n            secret = lisk_cryptography_1.getRandomBytes(4);\n            await this._nodeDB.put(DB_KEY_NETWORK_NODE_SECRET, secret);\n        }\n        this._secret = secret === null || secret === void 0 ? void 0 : secret.readUInt32BE(0);\n        const initialNodeInfo = {\n            networkIdentifier: this._networkID,\n            networkVersion: this._networkVersion,\n            nonce: '',\n            advertiseAddress: (_a = this._options.advertiseAddress) !== null && _a !== void 0 ? _a : true,\n            options: {\n                lastBlockID: Buffer.alloc(0),\n                blockVersion: 0,\n                height: 0,\n                maxHeightPrevoted: 0,\n            },\n        };\n        const seedPeers = await utils_1.lookupPeersIPs(this._options.seedPeers, true);\n        const blacklistedIPs = (_b = this._options.blacklistedIPs) !== null && _b !== void 0 ? _b : [];\n        const fixedPeers = this._options.fixedPeers\n            ? this._options.fixedPeers.map(peer => ({\n                ipAddress: peer.ip,\n                port: peer.port,\n            }))\n            : [];\n        const whitelistedPeers = this._options.whitelistedPeers\n            ? this._options.whitelistedPeers.map(peer => ({\n                ipAddress: peer.ip,\n                port: peer.port,\n            }))\n            : [];\n        const p2pConfig = {\n            port: this._options.port,\n            nodeInfo: initialNodeInfo,\n            hostIp: this._options.hostIp,\n            blacklistedIPs,\n            fixedPeers,\n            whitelistedPeers,\n            seedPeers: seedPeers.map(peer => ({\n                ipAddress: peer.ip,\n                port: peer.port,\n            })),\n            previousPeers,\n            maxOutboundConnections: this._options.maxOutboundConnections,\n            maxInboundConnections: this._options.maxInboundConnections,\n            peerBanTime: this._options.peerBanTime,\n            sendPeerLimit: this._options.sendPeerLimit,\n            maxPeerDiscoveryResponseLength: this._options.maxPeerDiscoveryResponseLength,\n            maxPeerInfoSize: this._options.maxPeerInfoSize,\n            wsMaxPayload: this._options.wsMaxPayload,\n            secret: this._secret,\n            customNodeInfoSchema: schema_1.customNodeInfoSchema,\n        };\n        this._p2p = new P2P(p2pConfig);\n        this._p2p.on(EVENT_NETWORK_READY, () => {\n            this._logger.debug('Node connected to the network');\n            this.events.emit(constants_1.APP_EVENT_NETWORK_READY);\n            this._channel.publish(constants_1.APP_EVENT_NETWORK_READY);\n        });\n        this._p2p.on(EVENT_CLOSE_OUTBOUND, ({ peerInfo, code, reason }) => {\n            this._logger.debug({\n                ...peerInfo,\n                code,\n                reason,\n            }, 'EVENT_CLOSE_OUTBOUND: Close outbound peer connection');\n        });\n        this._p2p.on(EVENT_CLOSE_INBOUND, ({ peerInfo, code, reason }) => {\n            this._logger.debug({\n                ...peerInfo,\n                code,\n                reason,\n            }, 'EVENT_CLOSE_INBOUND: Close inbound peer connection');\n        });\n        this._p2p.on(EVENT_CONNECT_OUTBOUND, peerInfo => {\n            this._logger.debug({\n                ...peerInfo,\n            }, 'EVENT_CONNECT_OUTBOUND: Outbound peer connection');\n        });\n        this._p2p.on(EVENT_DISCOVERED_PEER, peerInfo => {\n            this._logger.trace({\n                ...peerInfo,\n            }, 'EVENT_DISCOVERED_PEER: Discovered peer connection');\n        });\n        this._p2p.on(EVENT_NEW_INBOUND_PEER, peerInfo => {\n            this._logger.debug({\n                ...peerInfo,\n            }, 'EVENT_NEW_INBOUND_PEER: Inbound peer connection');\n        });\n        this._p2p.on(EVENT_FAILED_TO_FETCH_PEER_INFO, (error) => {\n            this._logger.error({ err: error }, 'EVENT_FAILED_TO_FETCH_PEER_INFO: Failed to fetch peer info');\n        });\n        this._p2p.on(EVENT_FAILED_TO_PUSH_NODE_INFO, (error) => {\n            this._logger.trace({ err: error }, 'EVENT_FAILED_TO_PUSH_NODE_INFO: Failed to push node info');\n        });\n        this._p2p.on(EVENT_OUTBOUND_SOCKET_ERROR, (error) => {\n            this._logger.debug({ err: error }, 'EVENT_OUTBOUND_SOCKET_ERROR: Outbound socket error');\n        });\n        this._p2p.on(EVENT_INBOUND_SOCKET_ERROR, (error) => {\n            this._logger.debug({ err: error }, 'EVENT_INBOUND_SOCKET_ERROR: Inbound socket error');\n        });\n        this._p2p.on(EVENT_UPDATED_PEER_INFO, peerInfo => {\n            this._logger.trace({\n                ...peerInfo,\n            }, 'EVENT_UPDATED_PEER_INFO: Update peer info');\n        });\n        this._p2p.on(EVENT_FAILED_PEER_INFO_UPDATE, (error) => {\n            this._logger.error({ err: error }, 'EVENT_FAILED_PEER_INFO_UPDATE: Failed peer update');\n        });\n        this._p2p.on(EVENT_REQUEST_RECEIVED, async (request) => {\n            this._logger.trace({ procedure: request.procedure }, 'EVENT_REQUEST_RECEIVED: Received inbound request for procedure');\n            if (request.wasResponseSent) {\n                return;\n            }\n            if (!Object.keys(this._endpoints).includes(request.procedure)) {\n                const error = new Error(`Requested procedure \"${request.procedure}\" is not permitted.`);\n                this._logger.error({ err: error, procedure: request.procedure }, 'Peer request not fulfilled event: Requested procedure is not permitted.');\n                this._p2p.applyPenalty({ peerId: request.peerId, penalty: 100 });\n                request.error(error);\n                return;\n            }\n            try {\n                const result = await this._endpoints[request.procedure]({\n                    data: request.data,\n                    peerId: request.peerId,\n                });\n                this._logger.trace({ procedure: request.procedure }, 'Peer request fulfilled event: Responded to peer request');\n                request.end(result);\n            }\n            catch (error) {\n                this._logger.error({ err: error, procedure: request.procedure }, 'Peer request not fulfilled event: Could not respond to peer request');\n                request.error(error);\n            }\n        });\n        this._p2p.on(EVENT_MESSAGE_RECEIVED, (packet) => {\n            if (!REMOTE_EVENTS_WHITE_LIST.includes(packet.event)) {\n                const error = new Error(`Sent event \"${packet.event}\" is not permitted.`);\n                this._logger.error({ err: error, event: packet.event }, 'Peer request not fulfilled. Sent event is not permitted.');\n                this._p2p.applyPenalty({ peerId: packet.peerId, penalty: 100 });\n                return;\n            }\n            this._logger.trace({\n                peerId: packet.peerId,\n                event: packet.event,\n            }, 'EVENT_MESSAGE_RECEIVED: Received inbound message');\n            this.events.emit(constants_1.APP_EVENT_NETWORK_EVENT, packet);\n        });\n        this._p2p.on(EVENT_BAN_PEER, (peerId) => {\n            this._logger.error({ peerId }, 'EVENT_MESSAGE_RECEIVED: Peer has been banned temporarily');\n        });\n        setInterval(async () => {\n            const triedPeers = this._p2p.getTriedPeers();\n            if (triedPeers.length) {\n                await this._nodeDB.put(DB_KEY_NETWORK_TRIED_PEERS_LIST, Buffer.from(JSON.stringify(triedPeers), 'utf8'));\n            }\n        }, DEFAULT_PEER_SAVE_INTERVAL);\n        try {\n            await this._p2p.start();\n        }\n        catch (error) {\n            this._logger.fatal({\n                message: error.message,\n                stack: error.stack,\n            }, 'Failed to initialize network');\n            throw error;\n        }\n    }\n    registerEndpoint(endpoint, handler) {\n        if (this._endpoints[endpoint]) {\n            throw new Error(`Endpoint ${endpoint} has already been registered.`);\n        }\n        this._endpoints[endpoint] = handler;\n    }\n    async request(requestPacket) {\n        return this._p2p.request({\n            procedure: requestPacket.procedure,\n            data: requestPacket.data,\n        });\n    }\n    send(sendPacket) {\n        return this._p2p.send({\n            event: sendPacket.event,\n            data: sendPacket.data,\n        });\n    }\n    async requestFromPeer(requestPacket) {\n        return this._p2p.requestFromPeer({\n            procedure: requestPacket.procedure,\n            data: requestPacket.data,\n        }, requestPacket.peerId);\n    }\n    sendToPeer(sendPacket) {\n        return this._p2p.sendToPeer({\n            event: sendPacket.event,\n            data: sendPacket.data,\n        }, sendPacket.peerId);\n    }\n    broadcast(broadcastPacket) {\n        return this._p2p.broadcast({\n            event: broadcastPacket.event,\n            data: broadcastPacket.data,\n        });\n    }\n    getConnectedPeers() {\n        const peers = this._p2p.getConnectedPeers();\n        return peers.map(peer => {\n            const parsedPeer = {\n                ...peer,\n            };\n            if (parsedPeer.options) {\n                parsedPeer.options = lisk_codec_1.codec.toJSON(schema_1.customNodeInfoSchema, parsedPeer.options);\n            }\n            return parsedPeer;\n        });\n    }\n    getNetworkStats() {\n        return this._p2p.getNetworkStats();\n    }\n    getDisconnectedPeers() {\n        const peers = this._p2p.getDisconnectedPeers();\n        return peers.map(peer => {\n            const parsedPeer = {\n                ...peer,\n            };\n            if (parsedPeer.options) {\n                parsedPeer.options = lisk_codec_1.codec.toJSON(schema_1.customNodeInfoSchema, parsedPeer.options);\n            }\n            return parsedPeer;\n        });\n    }\n    applyPenaltyOnPeer(penaltyPacket) {\n        return this._p2p.applyPenalty({\n            peerId: penaltyPacket.peerId,\n            penalty: penaltyPacket.penalty,\n        });\n    }\n    applyNodeInfo(data) {\n        var _a;\n        const newNodeInfo = {\n            networkIdentifier: this._networkID,\n            networkVersion: this._networkVersion,\n            advertiseAddress: (_a = this._options.advertiseAddress) !== null && _a !== void 0 ? _a : true,\n            options: data,\n        };\n        try {\n            this._p2p.applyNodeInfo(newNodeInfo);\n        }\n        catch (error) {\n            this._logger.error({ err: error }, 'Applying NodeInfo failed because of error');\n        }\n    }\n    async cleanup() {\n        this._logger.info('Network cleanup started');\n        await this._p2p.stop();\n        this._logger.info('Network cleanup completed');\n    }\n}\nexports.Network = Network;\n//# sourceMappingURL=network.js.map"]},"metadata":{},"sourceType":"script"}