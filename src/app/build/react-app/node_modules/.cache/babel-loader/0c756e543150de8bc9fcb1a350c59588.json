{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionList = exports.DEFAULT_MINIMUM_REPLACEMENT_FEE_DIFFERENCE = void 0;\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar DEFAULT_MAX_SIZE = 64;\nexports.DEFAULT_MINIMUM_REPLACEMENT_FEE_DIFFERENCE = BigInt(10);\n\nvar TransactionList = /*#__PURE__*/function () {\n  function TransactionList(address, options) {\n    _classCallCheck(this, TransactionList);\n\n    var _a, _b;\n\n    this.address = address;\n    this._transactions = {};\n    this._nonceHeap = new lisk_utils_1.dataStructures.MinHeap();\n    this._processable = [];\n    this._maxSize = (_a = options === null || options === void 0 ? void 0 : options.maxSize) !== null && _a !== void 0 ? _a : DEFAULT_MAX_SIZE;\n    this._minReplacementFeeDifference = (_b = options === null || options === void 0 ? void 0 : options.minReplacementFeeDifference) !== null && _b !== void 0 ? _b : exports.DEFAULT_MINIMUM_REPLACEMENT_FEE_DIFFERENCE;\n  }\n\n  _createClass(TransactionList, [{\n    key: \"get\",\n    value: function get(nonce) {\n      return this._transactions[nonce.toString()];\n    }\n  }, {\n    key: \"add\",\n    value: function add(incomingTx) {\n      var processable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var existingTx = this._transactions[incomingTx.nonce.toString()];\n\n      if (existingTx) {\n        if (incomingTx.fee < existingTx.fee + this._minReplacementFeeDifference) {\n          return {\n            added: false,\n            reason: 'Incoming transaction fee is not sufficient to replace existing transaction'\n          };\n        }\n\n        this._demoteAfter(incomingTx.nonce);\n\n        this._transactions[incomingTx.nonce.toString()] = incomingTx;\n        return {\n          added: true,\n          removedID: existingTx.id\n        };\n      }\n\n      var highestNonce = this._highestNonce();\n\n      var removedID;\n\n      if (this._nonceHeap.count >= this._maxSize) {\n        if (incomingTx.nonce > highestNonce) {\n          return {\n            added: false,\n            reason: 'Incoming transaction exceeds maximum transaction limit per account'\n          };\n        }\n\n        removedID = this.remove(highestNonce);\n      }\n\n      this._transactions[incomingTx.nonce.toString()] = incomingTx;\n\n      this._nonceHeap.push(incomingTx.nonce, undefined);\n\n      if (processable && this._processable.length === 0) {\n        this._processable.push(incomingTx.nonce);\n      }\n\n      return {\n        added: true,\n        removedID: removedID\n      };\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(nonce) {\n      var removingTx = this._transactions[nonce.toString()];\n\n      if (!removingTx) {\n        return undefined;\n      }\n\n      delete this._transactions[nonce.toString()];\n      var keys = this._nonceHeap.keys;\n\n      this._nonceHeap.clear();\n\n      var _iterator = _createForOfIteratorHelper(keys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n\n          if (key !== nonce) {\n            this._nonceHeap.push(key, undefined);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this._demoteAfter(nonce);\n\n      return removingTx.id;\n    }\n  }, {\n    key: \"promote\",\n    value: function promote(txs) {\n      var promotingNonces = [];\n\n      var _iterator2 = _createForOfIteratorHelper(txs),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var tx = _step2.value;\n\n          var promotingTx = this._transactions[tx.nonce.toString()];\n\n          if (!promotingTx) {\n            return false;\n          }\n\n          if (tx.id !== promotingTx.id) {\n            return false;\n          }\n\n          promotingNonces.push(tx.nonce);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this._processable = Array.from(new Set([].concat(_toConsumableArray(this._processable), promotingNonces)));\n\n      this._sortProcessable();\n\n      return true;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._nonceHeap.count;\n    }\n  }, {\n    key: \"getProcessable\",\n    value: function getProcessable() {\n      var txs = [];\n\n      var _iterator3 = _createForOfIteratorHelper(this._processable),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var nonce = _step3.value;\n          txs.push(this._transactions[nonce.toString()]);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return txs;\n    }\n  }, {\n    key: \"getUnprocessable\",\n    value: function getUnprocessable() {\n      if (this._nonceHeap.count === 0) {\n        return [];\n      }\n\n      if (this._processable.length === this._nonceHeap.count) {\n        return [];\n      }\n\n      var clonedHeap = this._nonceHeap.clone();\n\n      var _iterator4 = _createForOfIteratorHelper(this._processable),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _ = _step4.value;\n          clonedHeap.pop();\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var remainingCount = clonedHeap.count;\n      var unprocessableTx = [];\n\n      for (var i = 0; i < remainingCount; i += 1) {\n        var _clonedHeap$pop = clonedHeap.pop(),\n            key = _clonedHeap$pop.key;\n\n        unprocessableTx.push(this._transactions[key.toString()]);\n      }\n\n      return unprocessableTx;\n    }\n  }, {\n    key: \"getPromotable\",\n    value: function getPromotable() {\n      if (this._nonceHeap.count === 0) {\n        return [];\n      }\n\n      if (this._processable.length === this._nonceHeap.count) {\n        return [];\n      }\n\n      var clonedHeap = this._nonceHeap.clone();\n\n      var _iterator5 = _createForOfIteratorHelper(this._processable),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _ = _step5.value;\n          clonedHeap.pop();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var firstUnprocessable = clonedHeap.pop();\n\n      if (!firstUnprocessable) {\n        return [];\n      }\n\n      if (this._processable.length !== 0) {\n        var highestProcessableNonce = this._processable[this._processable.length - 1];\n\n        if (firstUnprocessable.key !== highestProcessableNonce + BigInt(1)) {\n          return [];\n        }\n      }\n\n      var promotableTx = [this._transactions[firstUnprocessable.key.toString()]];\n      var remainingNonces = clonedHeap.count;\n\n      var lastPromotedNonce = this._transactions[firstUnprocessable.key.toString()].nonce;\n\n      for (var i = 0; i < remainingNonces; i += 1) {\n        var _clonedHeap$pop2 = clonedHeap.pop(),\n            key = _clonedHeap$pop2.key;\n\n        if (lastPromotedNonce + BigInt(1) === key) {\n          promotableTx.push(this._transactions[key.toString()]);\n          lastPromotedNonce = this._transactions[key.toString()].nonce;\n        }\n      }\n\n      return promotableTx;\n    }\n  }, {\n    key: \"_demoteAfter\",\n    value: function _demoteAfter(nonce) {\n      this._processable = this._processable.filter(function (processableNonce) {\n        return processableNonce < nonce;\n      });\n\n      this._sortProcessable();\n    }\n  }, {\n    key: \"_highestNonce\",\n    value: function _highestNonce() {\n      var highestNonce = BigInt(-1);\n      var keys = this._nonceHeap.keys;\n\n      if (!keys) {\n        return highestNonce;\n      }\n\n      return keys.reduce(function (prev, current) {\n        if (current > prev) {\n          return current;\n        }\n\n        return prev;\n      }, highestNonce);\n    }\n  }, {\n    key: \"_sortProcessable\",\n    value: function _sortProcessable() {\n      this._processable.sort(function (a, b) {\n        if (a - b > BigInt(0)) {\n          return 1;\n        }\n\n        if (a - b < BigInt(0)) {\n          return -1;\n        }\n\n        return 0;\n      });\n    }\n  }]);\n\n  return TransactionList;\n}();\n\nexports.TransactionList = TransactionList;","map":{"version":3,"sources":["../src/transaction_list.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionList = exports.DEFAULT_MINIMUM_REPLACEMENT_FEE_DIFFERENCE = void 0;\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst DEFAULT_MAX_SIZE = 64;\nexports.DEFAULT_MINIMUM_REPLACEMENT_FEE_DIFFERENCE = BigInt(10);\nclass TransactionList {\n    constructor(address, options) {\n        var _a, _b;\n        this.address = address;\n        this._transactions = {};\n        this._nonceHeap = new lisk_utils_1.dataStructures.MinHeap();\n        this._processable = [];\n        this._maxSize = (_a = options === null || options === void 0 ? void 0 : options.maxSize) !== null && _a !== void 0 ? _a : DEFAULT_MAX_SIZE;\n        this._minReplacementFeeDifference =\n            (_b = options === null || options === void 0 ? void 0 : options.minReplacementFeeDifference) !== null && _b !== void 0 ? _b : exports.DEFAULT_MINIMUM_REPLACEMENT_FEE_DIFFERENCE;\n    }\n    get(nonce) {\n        return this._transactions[nonce.toString()];\n    }\n    add(incomingTx, processable = false) {\n        const existingTx = this._transactions[incomingTx.nonce.toString()];\n        if (existingTx) {\n            if (incomingTx.fee < existingTx.fee + this._minReplacementFeeDifference) {\n                return {\n                    added: false,\n                    reason: 'Incoming transaction fee is not sufficient to replace existing transaction',\n                };\n            }\n            this._demoteAfter(incomingTx.nonce);\n            this._transactions[incomingTx.nonce.toString()] = incomingTx;\n            return { added: true, removedID: existingTx.id };\n        }\n        const highestNonce = this._highestNonce();\n        let removedID;\n        if (this._nonceHeap.count >= this._maxSize) {\n            if (incomingTx.nonce > highestNonce) {\n                return {\n                    added: false,\n                    reason: 'Incoming transaction exceeds maximum transaction limit per account',\n                };\n            }\n            removedID = this.remove(highestNonce);\n        }\n        this._transactions[incomingTx.nonce.toString()] = incomingTx;\n        this._nonceHeap.push(incomingTx.nonce, undefined);\n        if (processable && this._processable.length === 0) {\n            this._processable.push(incomingTx.nonce);\n        }\n        return { added: true, removedID };\n    }\n    remove(nonce) {\n        const removingTx = this._transactions[nonce.toString()];\n        if (!removingTx) {\n            return undefined;\n        }\n        delete this._transactions[nonce.toString()];\n        const { keys } = this._nonceHeap;\n        this._nonceHeap.clear();\n        for (const key of keys) {\n            if (key !== nonce) {\n                this._nonceHeap.push(key, undefined);\n            }\n        }\n        this._demoteAfter(nonce);\n        return removingTx.id;\n    }\n    promote(txs) {\n        const promotingNonces = [];\n        for (const tx of txs) {\n            const promotingTx = this._transactions[tx.nonce.toString()];\n            if (!promotingTx) {\n                return false;\n            }\n            if (tx.id !== promotingTx.id) {\n                return false;\n            }\n            promotingNonces.push(tx.nonce);\n        }\n        this._processable = Array.from(new Set([...this._processable, ...promotingNonces]));\n        this._sortProcessable();\n        return true;\n    }\n    get size() {\n        return this._nonceHeap.count;\n    }\n    getProcessable() {\n        const txs = [];\n        for (const nonce of this._processable) {\n            txs.push(this._transactions[nonce.toString()]);\n        }\n        return txs;\n    }\n    getUnprocessable() {\n        if (this._nonceHeap.count === 0) {\n            return [];\n        }\n        if (this._processable.length === this._nonceHeap.count) {\n            return [];\n        }\n        const clonedHeap = this._nonceHeap.clone();\n        for (const _ of this._processable) {\n            clonedHeap.pop();\n        }\n        const remainingCount = clonedHeap.count;\n        const unprocessableTx = [];\n        for (let i = 0; i < remainingCount; i += 1) {\n            const { key } = clonedHeap.pop();\n            unprocessableTx.push(this._transactions[key.toString()]);\n        }\n        return unprocessableTx;\n    }\n    getPromotable() {\n        if (this._nonceHeap.count === 0) {\n            return [];\n        }\n        if (this._processable.length === this._nonceHeap.count) {\n            return [];\n        }\n        const clonedHeap = this._nonceHeap.clone();\n        for (const _ of this._processable) {\n            clonedHeap.pop();\n        }\n        const firstUnprocessable = clonedHeap.pop();\n        if (!firstUnprocessable) {\n            return [];\n        }\n        if (this._processable.length !== 0) {\n            const highestProcessableNonce = this._processable[this._processable.length - 1];\n            if (firstUnprocessable.key !== highestProcessableNonce + BigInt(1)) {\n                return [];\n            }\n        }\n        const promotableTx = [this._transactions[firstUnprocessable.key.toString()]];\n        const remainingNonces = clonedHeap.count;\n        let lastPromotedNonce = this._transactions[firstUnprocessable.key.toString()].nonce;\n        for (let i = 0; i < remainingNonces; i += 1) {\n            const { key } = clonedHeap.pop();\n            if (lastPromotedNonce + BigInt(1) === key) {\n                promotableTx.push(this._transactions[key.toString()]);\n                lastPromotedNonce = this._transactions[key.toString()].nonce;\n            }\n        }\n        return promotableTx;\n    }\n    _demoteAfter(nonce) {\n        this._processable = this._processable.filter(processableNonce => processableNonce < nonce);\n        this._sortProcessable();\n    }\n    _highestNonce() {\n        const highestNonce = BigInt(-1);\n        const { keys } = this._nonceHeap;\n        if (!keys) {\n            return highestNonce;\n        }\n        return keys.reduce((prev, current) => {\n            if (current > prev) {\n                return current;\n            }\n            return prev;\n        }, highestNonce);\n    }\n    _sortProcessable() {\n        this._processable.sort((a, b) => {\n            if (a - b > BigInt(0)) {\n                return 1;\n            }\n            if (a - b < BigInt(0)) {\n                return -1;\n            }\n            return 0;\n        });\n    }\n}\nexports.TransactionList = TransactionList;\n//# sourceMappingURL=transaction_list.js.map"]},"metadata":{},"sourceType":"script"}