{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transaction = exports.calculateMinFee = exports.transactionSchema = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nexports.transactionSchema = {\n  $id: 'lisk/transaction',\n  type: 'object',\n  required: ['moduleID', 'assetID', 'nonce', 'fee', 'senderPublicKey', 'asset'],\n  properties: {\n    moduleID: {\n      dataType: 'uint32',\n      fieldNumber: 1,\n      minimum: 2\n    },\n    assetID: {\n      dataType: 'uint32',\n      fieldNumber: 2\n    },\n    nonce: {\n      dataType: 'uint64',\n      fieldNumber: 3\n    },\n    fee: {\n      dataType: 'uint64',\n      fieldNumber: 4\n    },\n    senderPublicKey: {\n      dataType: 'bytes',\n      fieldNumber: 5,\n      minLength: 32,\n      maxLength: 32\n    },\n    asset: {\n      dataType: 'bytes',\n      fieldNumber: 6\n    },\n    signatures: {\n      type: 'array',\n      items: {\n        dataType: 'bytes'\n      },\n      fieldNumber: 7\n    }\n  }\n};\n\nvar calculateMinFee = function calculateMinFee(tx, minFeePerByte, baseFees) {\n  var _a, _b;\n\n  var size = tx.getBytes().length;\n  var baseFee = (_b = (_a = baseFees.find(function (bf) {\n    return bf.moduleID === tx.moduleID && bf.assetID === tx.assetID;\n  })) === null || _a === void 0 ? void 0 : _a.baseFee) !== null && _b !== void 0 ? _b : '0';\n  return BigInt(minFeePerByte * size) + BigInt(baseFee);\n};\n\nexports.calculateMinFee = calculateMinFee;\n\nvar Transaction = /*#__PURE__*/function () {\n  function Transaction(transaction) {\n    _classCallCheck(this, Transaction);\n\n    this.moduleID = transaction.moduleID;\n    this.assetID = transaction.assetID;\n    this.asset = transaction.asset;\n    this.nonce = transaction.nonce;\n    this.fee = transaction.fee;\n    this.senderPublicKey = transaction.senderPublicKey;\n    this.signatures = transaction.signatures;\n  }\n\n  _createClass(Transaction, [{\n    key: \"id\",\n    get: function get() {\n      if (!this._id) {\n        this._id = lisk_cryptography_1.hash(this.getBytes());\n      }\n\n      return this._id;\n    }\n  }, {\n    key: \"senderAddress\",\n    get: function get() {\n      if (!this._senderAddress) {\n        this._senderAddress = lisk_cryptography_1.getAddressFromPublicKey(this.senderPublicKey);\n      }\n\n      return this._senderAddress;\n    }\n  }, {\n    key: \"getBytes\",\n    value: function getBytes() {\n      var transactionBytes = lisk_codec_1.codec.encode(exports.transactionSchema, this);\n      return transactionBytes;\n    }\n  }, {\n    key: \"getSigningBytes\",\n    value: function getSigningBytes() {\n      var transactionBytes = lisk_codec_1.codec.encode(exports.transactionSchema, _objectSpread(_objectSpread({}, this), {}, {\n        signatures: []\n      }));\n      return transactionBytes;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(input) {\n      var schemaErrors = lisk_validator_1.validator.validate(exports.transactionSchema, this);\n\n      if (schemaErrors.length > 0) {\n        throw new lisk_validator_1.LiskValidationError(schemaErrors);\n      }\n\n      if (this.signatures.length === 0) {\n        throw new Error('Signatures must not be empty');\n      }\n\n      var _iterator = _createForOfIteratorHelper(this.signatures),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var signature = _step.value;\n\n          if (signature.length !== 0 && signature.length !== 64) {\n            throw new Error('Signature must be empty or 64 bytes');\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var minFee = exports.calculateMinFee(this, input.minFeePerByte, input.baseFees);\n\n      if (this.fee < minFee) {\n        throw new Error(\"Insufficient transaction fee. Minimum required fee is: \".concat(minFee.toString()));\n      }\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(bytes) {\n      var tx = lisk_codec_1.codec.decode(exports.transactionSchema, bytes);\n      return new Transaction(tx);\n    }\n  }]);\n\n  return Transaction;\n}();\n\nexports.Transaction = Transaction;","map":{"version":3,"sources":["../src/transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transaction = exports.calculateMinFee = exports.transactionSchema = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nexports.transactionSchema = {\n    $id: 'lisk/transaction',\n    type: 'object',\n    required: ['moduleID', 'assetID', 'nonce', 'fee', 'senderPublicKey', 'asset'],\n    properties: {\n        moduleID: {\n            dataType: 'uint32',\n            fieldNumber: 1,\n            minimum: 2,\n        },\n        assetID: {\n            dataType: 'uint32',\n            fieldNumber: 2,\n        },\n        nonce: {\n            dataType: 'uint64',\n            fieldNumber: 3,\n        },\n        fee: {\n            dataType: 'uint64',\n            fieldNumber: 4,\n        },\n        senderPublicKey: {\n            dataType: 'bytes',\n            fieldNumber: 5,\n            minLength: 32,\n            maxLength: 32,\n        },\n        asset: {\n            dataType: 'bytes',\n            fieldNumber: 6,\n        },\n        signatures: {\n            type: 'array',\n            items: {\n                dataType: 'bytes',\n            },\n            fieldNumber: 7,\n        },\n    },\n};\nconst calculateMinFee = (tx, minFeePerByte, baseFees) => {\n    var _a, _b;\n    const size = tx.getBytes().length;\n    const baseFee = (_b = (_a = baseFees.find(bf => bf.moduleID === tx.moduleID && bf.assetID === tx.assetID)) === null || _a === void 0 ? void 0 : _a.baseFee) !== null && _b !== void 0 ? _b : '0';\n    return BigInt(minFeePerByte * size) + BigInt(baseFee);\n};\nexports.calculateMinFee = calculateMinFee;\nclass Transaction {\n    constructor(transaction) {\n        this.moduleID = transaction.moduleID;\n        this.assetID = transaction.assetID;\n        this.asset = transaction.asset;\n        this.nonce = transaction.nonce;\n        this.fee = transaction.fee;\n        this.senderPublicKey = transaction.senderPublicKey;\n        this.signatures = transaction.signatures;\n    }\n    static decode(bytes) {\n        const tx = lisk_codec_1.codec.decode(exports.transactionSchema, bytes);\n        return new Transaction(tx);\n    }\n    get id() {\n        if (!this._id) {\n            this._id = lisk_cryptography_1.hash(this.getBytes());\n        }\n        return this._id;\n    }\n    get senderAddress() {\n        if (!this._senderAddress) {\n            this._senderAddress = lisk_cryptography_1.getAddressFromPublicKey(this.senderPublicKey);\n        }\n        return this._senderAddress;\n    }\n    getBytes() {\n        const transactionBytes = lisk_codec_1.codec.encode(exports.transactionSchema, this);\n        return transactionBytes;\n    }\n    getSigningBytes() {\n        const transactionBytes = lisk_codec_1.codec.encode(exports.transactionSchema, {\n            ...this,\n            signatures: [],\n        });\n        return transactionBytes;\n    }\n    validate(input) {\n        const schemaErrors = lisk_validator_1.validator.validate(exports.transactionSchema, this);\n        if (schemaErrors.length > 0) {\n            throw new lisk_validator_1.LiskValidationError(schemaErrors);\n        }\n        if (this.signatures.length === 0) {\n            throw new Error('Signatures must not be empty');\n        }\n        for (const signature of this.signatures) {\n            if (signature.length !== 0 && signature.length !== 64) {\n                throw new Error('Signature must be empty or 64 bytes');\n            }\n        }\n        const minFee = exports.calculateMinFee(this, input.minFeePerByte, input.baseFees);\n        if (this.fee < minFee) {\n            throw new Error(`Insufficient transaction fee. Minimum required fee is: ${minFee.toString()}`);\n        }\n    }\n}\nexports.Transaction = Transaction;\n//# sourceMappingURL=transaction.js.map"]},"metadata":{},"sourceType":"script"}