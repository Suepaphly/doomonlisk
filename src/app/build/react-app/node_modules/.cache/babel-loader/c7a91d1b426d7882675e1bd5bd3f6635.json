{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _templateObject, _templateObject2;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar code_1 = require(\"../code\");\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar util_2 = require(\"../../compile/util\");\n\nvar def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        schema = cxt.schema,\n        data = cxt.data,\n        parentSchema = cxt.parentSchema,\n        it = cxt.it;\n    var opts = it.opts;\n    var patterns = code_1.schemaProperties(it, schema); // TODO mark properties matching patterns with always valid schemas as evaluated\n\n    if (patterns.length === 0) return;\n    var checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    var valid = gen.name(\"valid\");\n\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = util_2.evaluatedPropsToName(gen, it.props);\n    }\n\n    var props = it.props;\n    validatePatternProperties();\n\n    function validatePatternProperties() {\n      var _iterator = _createForOfIteratorHelper(patterns),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pat = _step.value;\n          if (checkProperties) checkMatchingProperties(pat);\n\n          if (it.allErrors) {\n            validateProperties(pat);\n          } else {\n            gen.var(valid, true); // TODO var\n\n            validateProperties(pat);\n            gen.if(valid);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    function checkMatchingProperties(pat) {\n      for (var prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          util_1.checkStrictMode(it, \"property \".concat(prop, \" matches pattern \").concat(pat, \" (use allowMatchingProperties)\"));\n        }\n      }\n    }\n\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, function (key) {\n        gen.if(codegen_1._(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".test(\", \")\"])), code_1.usePattern(cxt, pat), key), function () {\n          cxt.subschema({\n            keyword: \"patternProperties\",\n            schemaProp: pat,\n            dataProp: key,\n            dataPropType: util_2.Type.Str\n          }, valid);\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(codegen_1._(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), props, key), true);\n          } else if (!it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(codegen_1.not(valid), function () {\n              return gen.break();\n            });\n          }\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/applicator/patternProperties.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst util_2 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = code_1.schemaProperties(it, schema);\n        // TODO mark properties matching patterns with always valid schemas as evaluated\n        if (patterns.length === 0)\n            return;\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name(\"valid\");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = util_2.evaluatedPropsToName(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    util_1.checkStrictMode(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn(\"key\", data, (key) => {\n                gen.if(codegen_1._ `${code_1.usePattern(cxt, pat)}.test(${key})`, () => {\n                    cxt.subschema({\n                        keyword: \"patternProperties\",\n                        schemaProp: pat,\n                        dataProp: key,\n                        dataPropType: util_2.Type.Str,\n                    }, valid);\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign(codegen_1._ `${props}[${key}]`, true);\n                    }\n                    else if (!it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if(codegen_1.not(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=patternProperties.js.map"]},"metadata":{},"sourceType":"script"}