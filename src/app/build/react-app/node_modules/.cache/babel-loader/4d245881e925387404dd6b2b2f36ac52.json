{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lookupPeersIPs = void 0;\n\nvar net_1 = require(\"net\");\n\nvar dns_1 = require(\"dns\");\n\nvar lookupPromise = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(hostname, options) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n              dns_1.lookup(hostname, options, function (err, address) {\n                if (err) {\n                  return reject(err);\n                }\n\n                return resolve(address);\n              });\n            }));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function lookupPromise(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar lookupPeersIPs = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peersList, enabled) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (enabled) {\n              _context3.next = 2;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", []);\n\n          case 2:\n            return _context3.abrupt(\"return\", Promise.all(peersList.map( /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(peer) {\n                var ip, address;\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        ip = peer.ip;\n\n                        if (!net_1.isIPv4(ip)) {\n                          _context2.next = 3;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", peer);\n\n                      case 3:\n                        _context2.prev = 3;\n                        _context2.next = 6;\n                        return lookupPromise(ip, {\n                          family: 4\n                        });\n\n                      case 6:\n                        address = _context2.sent;\n                        return _context2.abrupt(\"return\", _objectSpread(_objectSpread({}, peer), {}, {\n                          ip: address\n                        }));\n\n                      case 10:\n                        _context2.prev = 10;\n                        _context2.t0 = _context2[\"catch\"](3);\n                        console.error(\"Failed to resolve peer domain name \".concat(ip, \" to an IP address\"));\n                        return _context2.abrupt(\"return\", peer);\n\n                      case 14:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2, null, [[3, 10]]);\n              }));\n\n              return function (_x5) {\n                return _ref3.apply(this, arguments);\n              };\n            }())));\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function lookupPeersIPs(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.lookupPeersIPs = lookupPeersIPs;","map":{"version":3,"sources":["../../../src/node/network/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAcA,IAAA,KAAA,GAAA,OAAA,CAAA,KAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,KAAA,CAAA;;AAGA,IAAM,aAAa;AAAA,sEAAG,iBAAO,QAAP,EAAyB,OAAzB;AAAA;AAAA;AAAA;AAAA;AAAA,6CACrB,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAoB;AAC/B,cAAA,KAAA,CAAA,MAAA,CAAO,QAAP,EAAiB,OAAjB,EAA0B,UAAC,GAAD,EAAM,OAAN,EAAiB;AAC1C,oBAAI,GAAJ,EAAS;AACR,yBAAO,MAAM,CAAC,GAAD,CAAb;AACA;;AAED,uBAAO,OAAO,CAAC,OAAD,CAAd;AACA,eAND;AAOA,aARD,CADqB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAb,aAAa;AAAA;AAAA;AAAA,GAAnB;;AAWO,IAAM,cAAc;AAAA,uEAAG,kBAC7B,SAD6B,EAE7B,OAF6B;AAAA;AAAA;AAAA;AAAA;AAAA,gBAKxB,OALwB;AAAA;AAAA;AAAA;;AAAA,8CAMrB,EANqB;;AAAA;AAAA,8CAUtB,OAAO,CAAC,GAAR,CACN,SAAS,CAAC,GAAV;AAAA,mFAAc,kBAAO,IAAP;AAAA;AAAA;AAAA;AAAA;AAAA;AACL,wBAAA,EADK,GACE,IADF,CACL,EADK;;AAAA,6BAET,KAAA,CAAA,MAAA,CAAO,EAAP,CAFS;AAAA;AAAA;AAAA;;AAAA,0DAGL,IAHK;;AAAA;AAAA;AAAA;AAAA,+BAOU,aAAa,CAAC,EAAD,EAAK;AAAE,0BAAA,MAAM,EAAE;AAAV,yBAAL,CAPvB;;AAAA;AAON,wBAAA,OAPM;AAAA,0FASR,IATQ;AAUX,0BAAA,EAAE,EAAE;AAVO;;AAAA;AAAA;AAAA;AAaZ,wBAAA,OAAO,CAAC,KAAR,8CAAoD,EAApD;AAbY,0DAcL,IAdK;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAAd;;AAAA;AAAA;AAAA;AAAA,gBADM,CAVsB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAd,cAAc;AAAA;AAAA;AAAA,GAApB;;AAAM,OAAA,CAAA,cAAA,GAAc,cAAd","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lookupPeersIPs = void 0;\nconst net_1 = require(\"net\");\nconst dns_1 = require(\"dns\");\nconst lookupPromise = async (hostname, options) => new Promise((resolve, reject) => {\n    dns_1.lookup(hostname, options, (err, address) => {\n        if (err) {\n            return reject(err);\n        }\n        return resolve(address);\n    });\n});\nconst lookupPeersIPs = async (peersList, enabled) => {\n    if (!enabled) {\n        return [];\n    }\n    return Promise.all(peersList.map(async (peer) => {\n        const { ip } = peer;\n        if (net_1.isIPv4(ip)) {\n            return peer;\n        }\n        try {\n            const address = await lookupPromise(ip, { family: 4 });\n            return {\n                ...peer,\n                ip: address,\n            };\n        }\n        catch (err) {\n            console.error(`Failed to resolve peer domain name ${ip} to an IP address`);\n            return peer;\n        }\n    }));\n};\nexports.lookupPeersIPs = lookupPeersIPs;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}