{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.smartConvert = exports.isASCIIChar = exports.getLastPrefix = exports.getFirstPrefix = exports.formatInt = void 0;\n\nvar formatInt = function formatInt(num) {\n  var buf;\n\n  if (typeof num === 'bigint') {\n    if (num < BigInt(0)) {\n      throw new Error('Negative number cannot be formatted');\n    }\n\n    buf = Buffer.alloc(8);\n    buf.writeBigUInt64BE(num);\n  } else {\n    if (num < 0) {\n      throw new Error('Negative number cannot be formatted');\n    }\n\n    buf = Buffer.alloc(4);\n    buf.writeUInt32BE(num, 0);\n  }\n\n  return buf.toString('binary');\n};\n\nexports.formatInt = formatInt;\n\nvar getFirstPrefix = function getFirstPrefix(prefix) {\n  return \"\".concat(prefix, \"\\0\");\n};\n\nexports.getFirstPrefix = getFirstPrefix;\n\nvar getLastPrefix = function getLastPrefix(prefix) {\n  return \"\".concat(prefix, \"\\xFF\");\n};\n\nexports.getLastPrefix = getLastPrefix;\n\nvar isASCIIChar = function isASCIIChar(val) {\n  return /^[\\x21-\\x7F]*$/.test(val);\n};\n\nexports.isASCIIChar = isASCIIChar;\n\nvar smartConvert = function smartConvert(message, delimiter, format) {\n  return message.split(delimiter).map(function (s) {\n    if (exports.isASCIIChar(s)) {\n      return s;\n    }\n\n    return Buffer.from(s, 'binary').toString(format);\n  }).join(delimiter);\n};\n\nexports.smartConvert = smartConvert;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";;;;;;;AAcO,IAAM,SAAS,GAAG,SAAZ,SAAY,CAAC,GAAD,EAAiC;AACzD,MAAI,GAAJ;;AACA,MAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AAC5B,QAAI,GAAG,GAAG,MAAM,CAAC,CAAD,CAAhB,EAAqB;AACpB,YAAM,IAAI,KAAJ,CAAU,qCAAV,CAAN;AACA;;AACD,IAAA,GAAG,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAN;AACA,IAAA,GAAG,CAAC,gBAAJ,CAAqB,GAArB;AACA,GAND,MAMO;AACN,QAAI,GAAG,GAAG,CAAV,EAAa;AACZ,YAAM,IAAI,KAAJ,CAAU,qCAAV,CAAN;AACA;;AACD,IAAA,GAAG,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAN;AACA,IAAA,GAAG,CAAC,aAAJ,CAAkB,GAAlB,EAAuB,CAAvB;AACA;;AACD,SAAO,GAAG,CAAC,QAAJ,CAAa,QAAb,CAAP;AACA,CAhBM;;AAAM,OAAA,CAAA,SAAA,GAAS,SAAT;;AAkBN,IAAM,cAAc,GAAG,SAAjB,cAAiB,CAAC,MAAD;AAAA,mBAA+B,MAA/B;AAAA,CAAvB;;AAAM,OAAA,CAAA,cAAA,GAAc,cAAd;;AACN,IAAM,aAAa,GAAG,SAAhB,aAAgB,CAAC,MAAD;AAAA,mBAA+B,MAA/B;AAAA,CAAtB;;AAAM,OAAA,CAAA,aAAA,GAAa,aAAb;;AAEN,IAAM,WAAW,GAAG,SAAd,WAAc,CAAC,GAAD;AAAA,SAA0B,iBAAiB,IAAjB,CAAsB,GAAtB,CAA1B;AAAA,CAApB;;AAAM,OAAA,CAAA,WAAA,GAAW,WAAX;;AAEN,IAAM,YAAY,GAAG,SAAf,YAAe,CAAC,OAAD,EAAkB,SAAlB,EAAqC,MAArC;AAAA,SAC3B,OAAO,CACL,KADF,CACQ,SADR,EAEE,GAFF,CAEM,UAAA,CAAC,EAAG;AACR,QAAI,OAAA,CAAA,WAAA,CAAY,CAAZ,CAAJ,EAAoB;AACnB,aAAO,CAAP;AACA;;AACD,WAAO,MAAM,CAAC,IAAP,CAAY,CAAZ,EAAe,QAAf,EAAyB,QAAzB,CAAkC,MAAlC,CAAP;AACA,GAPF,EAQE,IARF,CAQO,SARP,CAD2B;AAAA,CAArB;;AAAM,OAAA,CAAA,YAAA,GAAY,YAAZ","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.smartConvert = exports.isASCIIChar = exports.getLastPrefix = exports.getFirstPrefix = exports.formatInt = void 0;\nconst formatInt = (num) => {\n    let buf;\n    if (typeof num === 'bigint') {\n        if (num < BigInt(0)) {\n            throw new Error('Negative number cannot be formatted');\n        }\n        buf = Buffer.alloc(8);\n        buf.writeBigUInt64BE(num);\n    }\n    else {\n        if (num < 0) {\n            throw new Error('Negative number cannot be formatted');\n        }\n        buf = Buffer.alloc(4);\n        buf.writeUInt32BE(num, 0);\n    }\n    return buf.toString('binary');\n};\nexports.formatInt = formatInt;\nconst getFirstPrefix = (prefix) => `${prefix}\\x00`;\nexports.getFirstPrefix = getFirstPrefix;\nconst getLastPrefix = (prefix) => `${prefix}\\xFF`;\nexports.getLastPrefix = getLastPrefix;\nconst isASCIIChar = (val) => /^[\\x21-\\x7F]*$/.test(val);\nexports.isASCIIChar = isASCIIChar;\nconst smartConvert = (message, delimiter, format) => message\n    .split(delimiter)\n    .map(s => {\n    if (exports.isASCIIChar(s)) {\n        return s;\n    }\n    return Buffer.from(s, 'binary').toString(format);\n})\n    .join(delimiter);\nexports.smartConvert = smartConvert;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}