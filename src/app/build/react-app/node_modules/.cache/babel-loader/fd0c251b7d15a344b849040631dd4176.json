{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBase32AddressFromAddress = exports.getLisk32AddressFromAddress = exports.getAddressFromBase32Address = exports.getAddressFromLisk32Address = exports.validateBase32Address = exports.validateLisk32Address = exports.getBase32AddressFromPassphrase = exports.getLisk32AddressFromPassphrase = exports.getBase32AddressFromPublicKey = exports.getLisk32AddressFromPublicKey = exports.verifyChecksum = exports.createChecksum = exports.getAddressFromPrivateKey = exports.getAddressFromPassphrase = exports.getAddressAndPublicKeyFromPassphrase = exports.getAddressFromPublicKey = exports.getKeys = exports.getPrivateAndPublicKeyFromPassphrase = void 0;\n\nvar constants_1 = require(\"./constants\");\n\nvar convert_1 = require(\"./convert\");\n\nvar hash_1 = require(\"./hash\");\n\nvar nacl_1 = require(\"./nacl\");\n\nvar getPrivateAndPublicKeyFromPassphrase = function getPrivateAndPublicKeyFromPassphrase(passphrase) {\n  var hashed = hash_1.hash(passphrase, 'utf8');\n  return nacl_1.getKeyPair(hashed);\n};\n\nexports.getPrivateAndPublicKeyFromPassphrase = getPrivateAndPublicKeyFromPassphrase;\nexports.getKeys = exports.getPrivateAndPublicKeyFromPassphrase;\n\nvar getAddressFromPublicKey = function getAddressFromPublicKey(publicKey) {\n  var buffer = hash_1.hash(publicKey);\n  var truncatedBuffer = buffer.slice(0, constants_1.BINARY_ADDRESS_LENGTH);\n\n  if (truncatedBuffer.length !== constants_1.BINARY_ADDRESS_LENGTH) {\n    throw new Error('The Lisk addresses must contains exactly 20 bytes');\n  }\n\n  return truncatedBuffer;\n};\n\nexports.getAddressFromPublicKey = getAddressFromPublicKey;\n\nvar getAddressAndPublicKeyFromPassphrase = function getAddressAndPublicKeyFromPassphrase(passphrase) {\n  var _exports$getKeys = exports.getKeys(passphrase),\n      publicKey = _exports$getKeys.publicKey;\n\n  var address = exports.getAddressFromPublicKey(publicKey);\n  return {\n    address: address,\n    publicKey: publicKey\n  };\n};\n\nexports.getAddressAndPublicKeyFromPassphrase = getAddressAndPublicKeyFromPassphrase;\n\nvar getAddressFromPassphrase = function getAddressFromPassphrase(passphrase) {\n  var _exports$getKeys2 = exports.getKeys(passphrase),\n      publicKey = _exports$getKeys2.publicKey;\n\n  return exports.getAddressFromPublicKey(publicKey);\n};\n\nexports.getAddressFromPassphrase = getAddressFromPassphrase;\n\nvar getAddressFromPrivateKey = function getAddressFromPrivateKey(privateKey) {\n  var publicKey = nacl_1.getPublicKey(privateKey);\n  return exports.getAddressFromPublicKey(publicKey);\n};\n\nexports.getAddressFromPrivateKey = getAddressFromPrivateKey;\nvar GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n\nvar polymod = function polymod(uint5Array) {\n  var chk = 1;\n\n  var _iterator = _createForOfIteratorHelper(uint5Array),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var value = _step.value;\n      var top = chk >> 25;\n      chk = (chk & 0x1ffffff) << 5 ^ value;\n\n      for (var i = 0; i < 5; i += 1) {\n        if (top >> i & 1) {\n          chk ^= GENERATOR[i];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return chk;\n};\n\nvar createChecksum = function createChecksum(uint5Array) {\n  var values = uint5Array.concat([0, 0, 0, 0, 0, 0]);\n  var mod = polymod(values) ^ 1;\n  var result = [];\n\n  for (var p = 0; p < 6; p += 1) {\n    result.push(mod >> 5 * (5 - p) & 31);\n  }\n\n  return result;\n};\n\nexports.createChecksum = createChecksum;\n\nvar verifyChecksum = function verifyChecksum(integerSequence) {\n  return polymod(integerSequence) === 1;\n};\n\nexports.verifyChecksum = verifyChecksum;\n\nvar addressToLisk32 = function addressToLisk32(address) {\n  var byteSequence = [];\n\n  var _iterator2 = _createForOfIteratorHelper(address),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var b = _step2.value;\n      byteSequence.push(b);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var uint5Address = convert_1.convertUIntArray(byteSequence, 8, 5);\n  var uint5Checksum = exports.createChecksum(uint5Address);\n  return convert_1.convertUInt5ToBase32(uint5Address.concat(uint5Checksum));\n};\n\nvar getLisk32AddressFromPublicKey = function getLisk32AddressFromPublicKey(publicKey) {\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.DEFAULT_LISK32_ADDRESS_PREFIX;\n  return \"\".concat(prefix).concat(addressToLisk32(exports.getAddressFromPublicKey(publicKey)));\n};\n\nexports.getLisk32AddressFromPublicKey = getLisk32AddressFromPublicKey;\nexports.getBase32AddressFromPublicKey = exports.getLisk32AddressFromPublicKey;\n\nvar getLisk32AddressFromPassphrase = function getLisk32AddressFromPassphrase(passphrase) {\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.DEFAULT_LISK32_ADDRESS_PREFIX;\n\n  var _exports$getAddressAn = exports.getAddressAndPublicKeyFromPassphrase(passphrase),\n      publicKey = _exports$getAddressAn.publicKey;\n\n  return exports.getLisk32AddressFromPublicKey(publicKey, prefix);\n};\n\nexports.getLisk32AddressFromPassphrase = getLisk32AddressFromPassphrase;\nexports.getBase32AddressFromPassphrase = exports.getLisk32AddressFromPassphrase;\nvar LISK32_ADDRESS_LENGTH = 41;\nvar LISK32_CHARSET = 'zxvcpmbn3465o978uyrtkqew2adsjhfg';\n\nvar validateLisk32Address = function validateLisk32Address(address) {\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.DEFAULT_LISK32_ADDRESS_PREFIX;\n\n  if (address.length !== LISK32_ADDRESS_LENGTH) {\n    throw new Error('Address length does not match requirements. Expected 41 characters.');\n  }\n\n  var addressPrefix = address.substring(0, 3);\n\n  if (addressPrefix !== prefix) {\n    throw new Error(\"Invalid address prefix. Actual prefix: \".concat(addressPrefix, \", Expected prefix: \").concat(prefix));\n  }\n\n  var addressSubstringArray = address.substring(3).split('');\n\n  if (!addressSubstringArray.every(function (char) {\n    return LISK32_CHARSET.includes(char);\n  })) {\n    throw new Error(\"Invalid character found in address. Only allow characters: 'abcdefghjkmnopqrstuvwxyz23456789'.\");\n  }\n\n  var integerSequence = addressSubstringArray.map(function (char) {\n    return LISK32_CHARSET.indexOf(char);\n  });\n\n  if (!exports.verifyChecksum(integerSequence)) {\n    throw new Error('Invalid checksum for address.');\n  }\n\n  return true;\n};\n\nexports.validateLisk32Address = validateLisk32Address;\nexports.validateBase32Address = exports.validateLisk32Address;\n\nvar getAddressFromLisk32Address = function getAddressFromLisk32Address(base32Address) {\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.DEFAULT_LISK32_ADDRESS_PREFIX;\n  exports.validateLisk32Address(base32Address, prefix);\n  var base32AddressNoPrefixNoChecksum = base32Address.substring(prefix.length, base32Address.length - 6);\n  var addressArray = base32AddressNoPrefixNoChecksum.split('');\n  var integerSequence = addressArray.map(function (char) {\n    return LISK32_CHARSET.indexOf(char);\n  });\n  var integerSequence8 = convert_1.convertUIntArray(integerSequence, 5, 8);\n  return Buffer.from(integerSequence8);\n};\n\nexports.getAddressFromLisk32Address = getAddressFromLisk32Address;\nexports.getAddressFromBase32Address = exports.getAddressFromLisk32Address;\n\nvar getLisk32AddressFromAddress = function getLisk32AddressFromAddress(address) {\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.DEFAULT_LISK32_ADDRESS_PREFIX;\n  return \"\".concat(prefix).concat(addressToLisk32(address));\n};\n\nexports.getLisk32AddressFromAddress = getLisk32AddressFromAddress;\nexports.getBase32AddressFromAddress = exports.getLisk32AddressFromAddress;","map":{"version":3,"sources":["../src/keys.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBase32AddressFromAddress = exports.getLisk32AddressFromAddress = exports.getAddressFromBase32Address = exports.getAddressFromLisk32Address = exports.validateBase32Address = exports.validateLisk32Address = exports.getBase32AddressFromPassphrase = exports.getLisk32AddressFromPassphrase = exports.getBase32AddressFromPublicKey = exports.getLisk32AddressFromPublicKey = exports.verifyChecksum = exports.createChecksum = exports.getAddressFromPrivateKey = exports.getAddressFromPassphrase = exports.getAddressAndPublicKeyFromPassphrase = exports.getAddressFromPublicKey = exports.getKeys = exports.getPrivateAndPublicKeyFromPassphrase = void 0;\nconst constants_1 = require(\"./constants\");\nconst convert_1 = require(\"./convert\");\nconst hash_1 = require(\"./hash\");\nconst nacl_1 = require(\"./nacl\");\nconst getPrivateAndPublicKeyFromPassphrase = (passphrase) => {\n    const hashed = hash_1.hash(passphrase, 'utf8');\n    return nacl_1.getKeyPair(hashed);\n};\nexports.getPrivateAndPublicKeyFromPassphrase = getPrivateAndPublicKeyFromPassphrase;\nexports.getKeys = exports.getPrivateAndPublicKeyFromPassphrase;\nconst getAddressFromPublicKey = (publicKey) => {\n    const buffer = hash_1.hash(publicKey);\n    const truncatedBuffer = buffer.slice(0, constants_1.BINARY_ADDRESS_LENGTH);\n    if (truncatedBuffer.length !== constants_1.BINARY_ADDRESS_LENGTH) {\n        throw new Error('The Lisk addresses must contains exactly 20 bytes');\n    }\n    return truncatedBuffer;\n};\nexports.getAddressFromPublicKey = getAddressFromPublicKey;\nconst getAddressAndPublicKeyFromPassphrase = (passphrase) => {\n    const { publicKey } = exports.getKeys(passphrase);\n    const address = exports.getAddressFromPublicKey(publicKey);\n    return {\n        address,\n        publicKey,\n    };\n};\nexports.getAddressAndPublicKeyFromPassphrase = getAddressAndPublicKeyFromPassphrase;\nconst getAddressFromPassphrase = (passphrase) => {\n    const { publicKey } = exports.getKeys(passphrase);\n    return exports.getAddressFromPublicKey(publicKey);\n};\nexports.getAddressFromPassphrase = getAddressFromPassphrase;\nconst getAddressFromPrivateKey = (privateKey) => {\n    const publicKey = nacl_1.getPublicKey(privateKey);\n    return exports.getAddressFromPublicKey(publicKey);\n};\nexports.getAddressFromPrivateKey = getAddressFromPrivateKey;\nconst GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nconst polymod = (uint5Array) => {\n    let chk = 1;\n    for (const value of uint5Array) {\n        const top = chk >> 25;\n        chk = ((chk & 0x1ffffff) << 5) ^ value;\n        for (let i = 0; i < 5; i += 1) {\n            if ((top >> i) & 1) {\n                chk ^= GENERATOR[i];\n            }\n        }\n    }\n    return chk;\n};\nconst createChecksum = (uint5Array) => {\n    const values = uint5Array.concat([0, 0, 0, 0, 0, 0]);\n    const mod = polymod(values) ^ 1;\n    const result = [];\n    for (let p = 0; p < 6; p += 1) {\n        result.push((mod >> (5 * (5 - p))) & 31);\n    }\n    return result;\n};\nexports.createChecksum = createChecksum;\nconst verifyChecksum = (integerSequence) => polymod(integerSequence) === 1;\nexports.verifyChecksum = verifyChecksum;\nconst addressToLisk32 = (address) => {\n    const byteSequence = [];\n    for (const b of address) {\n        byteSequence.push(b);\n    }\n    const uint5Address = convert_1.convertUIntArray(byteSequence, 8, 5);\n    const uint5Checksum = exports.createChecksum(uint5Address);\n    return convert_1.convertUInt5ToBase32(uint5Address.concat(uint5Checksum));\n};\nconst getLisk32AddressFromPublicKey = (publicKey, prefix = constants_1.DEFAULT_LISK32_ADDRESS_PREFIX) => `${prefix}${addressToLisk32(exports.getAddressFromPublicKey(publicKey))}`;\nexports.getLisk32AddressFromPublicKey = getLisk32AddressFromPublicKey;\nexports.getBase32AddressFromPublicKey = exports.getLisk32AddressFromPublicKey;\nconst getLisk32AddressFromPassphrase = (passphrase, prefix = constants_1.DEFAULT_LISK32_ADDRESS_PREFIX) => {\n    const { publicKey } = exports.getAddressAndPublicKeyFromPassphrase(passphrase);\n    return exports.getLisk32AddressFromPublicKey(publicKey, prefix);\n};\nexports.getLisk32AddressFromPassphrase = getLisk32AddressFromPassphrase;\nexports.getBase32AddressFromPassphrase = exports.getLisk32AddressFromPassphrase;\nconst LISK32_ADDRESS_LENGTH = 41;\nconst LISK32_CHARSET = 'zxvcpmbn3465o978uyrtkqew2adsjhfg';\nconst validateLisk32Address = (address, prefix = constants_1.DEFAULT_LISK32_ADDRESS_PREFIX) => {\n    if (address.length !== LISK32_ADDRESS_LENGTH) {\n        throw new Error('Address length does not match requirements. Expected 41 characters.');\n    }\n    const addressPrefix = address.substring(0, 3);\n    if (addressPrefix !== prefix) {\n        throw new Error(`Invalid address prefix. Actual prefix: ${addressPrefix}, Expected prefix: ${prefix}`);\n    }\n    const addressSubstringArray = address.substring(3).split('');\n    if (!addressSubstringArray.every(char => LISK32_CHARSET.includes(char))) {\n        throw new Error(\"Invalid character found in address. Only allow characters: 'abcdefghjkmnopqrstuvwxyz23456789'.\");\n    }\n    const integerSequence = addressSubstringArray.map(char => LISK32_CHARSET.indexOf(char));\n    if (!exports.verifyChecksum(integerSequence)) {\n        throw new Error('Invalid checksum for address.');\n    }\n    return true;\n};\nexports.validateLisk32Address = validateLisk32Address;\nexports.validateBase32Address = exports.validateLisk32Address;\nconst getAddressFromLisk32Address = (base32Address, prefix = constants_1.DEFAULT_LISK32_ADDRESS_PREFIX) => {\n    exports.validateLisk32Address(base32Address, prefix);\n    const base32AddressNoPrefixNoChecksum = base32Address.substring(prefix.length, base32Address.length - 6);\n    const addressArray = base32AddressNoPrefixNoChecksum.split('');\n    const integerSequence = addressArray.map(char => LISK32_CHARSET.indexOf(char));\n    const integerSequence8 = convert_1.convertUIntArray(integerSequence, 5, 8);\n    return Buffer.from(integerSequence8);\n};\nexports.getAddressFromLisk32Address = getAddressFromLisk32Address;\nexports.getAddressFromBase32Address = exports.getAddressFromLisk32Address;\nconst getLisk32AddressFromAddress = (address, prefix = constants_1.DEFAULT_LISK32_ADDRESS_PREFIX) => `${prefix}${addressToLisk32(address)}`;\nexports.getLisk32AddressFromAddress = getLisk32AddressFromAddress;\nexports.getBase32AddressFromAddress = exports.getLisk32AddressFromAddress;\n//# sourceMappingURL=keys.js.map"]},"metadata":{},"sourceType":"script"}