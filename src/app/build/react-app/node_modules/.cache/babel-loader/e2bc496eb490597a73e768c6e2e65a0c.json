{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getBucketId = exports.expirePeerFromBucket = exports.evictPeerRandomlyFromBucket = exports.getByteSize = exports.constructPeerId = exports.getNetgroup = exports.getNetwork = exports.isLocal = exports.isPrivate = exports.PEER_TYPE = exports.NETWORK = exports.getIPBytes = exports.getIPGroup = exports.NETWORK_BUFFER_LENGTH = exports.SECRET_BUFFER_LENGTH = void 0;\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar net_1 = require(\"net\");\n\nvar BYTES_4 = 4;\nvar BYTES_16 = 16;\nexports.SECRET_BUFFER_LENGTH = 4;\nexports.NETWORK_BUFFER_LENGTH = 1;\nvar PREFIX_BUFFER_LENGTH = 1;\n\nvar getIPGroup = function getIPGroup(address, groupNumber) {\n  if (groupNumber > 3) {\n    throw new Error('Invalid IP group.');\n  }\n\n  return parseInt(address.split('.')[groupNumber], 10);\n};\n\nexports.getIPGroup = getIPGroup;\n\nvar getIPBytes = function getIPBytes(address) {\n  var aBytes = Buffer.alloc(PREFIX_BUFFER_LENGTH);\n  aBytes.writeUInt8(exports.getIPGroup(address, 0), 0);\n  var bBytes = Buffer.alloc(PREFIX_BUFFER_LENGTH);\n  bBytes.writeUInt8(exports.getIPGroup(address, 1), 0);\n  var cBytes = Buffer.alloc(PREFIX_BUFFER_LENGTH);\n  cBytes.writeUInt8(exports.getIPGroup(address, 2), 0);\n  var dBytes = Buffer.alloc(PREFIX_BUFFER_LENGTH);\n  dBytes.writeUInt8(exports.getIPGroup(address, 3), 0);\n  return {\n    aBytes: aBytes,\n    bBytes: bBytes,\n    cBytes: cBytes,\n    dBytes: dBytes\n  };\n};\n\nexports.getIPBytes = getIPBytes;\nvar NETWORK;\n\n(function (NETWORK) {\n  NETWORK[NETWORK[\"NET_IPV4\"] = 0] = \"NET_IPV4\";\n  NETWORK[NETWORK[\"NET_PRIVATE\"] = 1] = \"NET_PRIVATE\";\n  NETWORK[NETWORK[\"NET_LOCAL\"] = 2] = \"NET_LOCAL\";\n  NETWORK[NETWORK[\"NET_OTHER\"] = 3] = \"NET_OTHER\";\n})(NETWORK = exports.NETWORK || (exports.NETWORK = {}));\n\nvar PEER_TYPE;\n\n(function (PEER_TYPE) {\n  PEER_TYPE[\"NEW_PEER\"] = \"newPeer\";\n  PEER_TYPE[\"TRIED_PEER\"] = \"triedPeer\";\n})(PEER_TYPE = exports.PEER_TYPE || (exports.PEER_TYPE = {}));\n\nvar isPrivate = function isPrivate(address) {\n  return exports.getIPGroup(address, 0) === 10 || exports.getIPGroup(address, 0) === 172 && exports.getIPGroup(address, 1) >= 16 && exports.getIPGroup(address, 1) <= 31;\n};\n\nexports.isPrivate = isPrivate;\n\nvar isLocal = function isLocal(address) {\n  return exports.getIPGroup(address, 0) === 127 || address === '0.0.0.0';\n};\n\nexports.isLocal = isLocal;\n\nvar getNetwork = function getNetwork(address) {\n  if (exports.isLocal(address)) {\n    return NETWORK.NET_LOCAL;\n  }\n\n  if (exports.isPrivate(address)) {\n    return NETWORK.NET_PRIVATE;\n  }\n\n  if (net_1.isIPv4(address)) {\n    return NETWORK.NET_IPV4;\n  }\n\n  return NETWORK.NET_OTHER;\n};\n\nexports.getNetwork = getNetwork;\n\nvar getNetgroup = function getNetgroup(address, secret) {\n  var secretBytes = Buffer.alloc(exports.SECRET_BUFFER_LENGTH);\n  secretBytes.writeUInt32BE(secret, 0);\n  var network = exports.getNetwork(address);\n  var networkBytes = Buffer.alloc(exports.NETWORK_BUFFER_LENGTH);\n  networkBytes.writeUInt8(network, 0);\n\n  var _exports$getIPBytes = exports.getIPBytes(address),\n      aBytes = _exports$getIPBytes.aBytes,\n      bBytes = _exports$getIPBytes.bBytes;\n\n  if (network === NETWORK.NET_OTHER) {\n    throw Error('IP address is unsupported.');\n  }\n\n  var netgroupBytes = Buffer.concat([secretBytes, networkBytes, aBytes, bBytes]);\n  return lisk_cryptography_1.hash(netgroupBytes).readUInt32BE(0);\n};\n\nexports.getNetgroup = getNetgroup;\n\nvar constructPeerId = function constructPeerId(ipAddress, port) {\n  return \"\".concat(ipAddress, \":\").concat(port);\n};\n\nexports.constructPeerId = constructPeerId;\n\nvar getByteSize = function getByteSize(data) {\n  if (Buffer.isBuffer(data)) {\n    return data.length;\n  }\n\n  return Buffer.byteLength(JSON.stringify(data));\n};\n\nexports.getByteSize = getByteSize;\n\nvar evictPeerRandomlyFromBucket = function evictPeerRandomlyFromBucket(bucket) {\n  var bucketPeerIds = Array.from(bucket.keys());\n  var randomPeerIndex = Math.floor(Math.random() * bucketPeerIds.length);\n  var randomPeerId = bucketPeerIds[randomPeerIndex];\n  var evictedPeer = bucket.get(randomPeerId);\n  bucket.delete(randomPeerId);\n  return evictedPeer;\n};\n\nexports.evictPeerRandomlyFromBucket = evictPeerRandomlyFromBucket;\n\nvar expirePeerFromBucket = function expirePeerFromBucket(bucket, thresholdTime) {\n  var _iterator = _createForOfIteratorHelper(bucket),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          peerId = _step$value[0],\n          peer = _step$value[1];\n\n      var timeDifference = Math.round(Math.abs(peer.dateAdded.getTime() - new Date().getTime()));\n\n      if (timeDifference >= thresholdTime) {\n        bucket.delete(peerId);\n        return peer;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return undefined;\n};\n\nexports.expirePeerFromBucket = expirePeerFromBucket;\n\nvar getBucketId = function getBucketId(options) {\n  var secret = options.secret,\n      targetAddress = options.targetAddress,\n      sourceAddress = options.sourceAddress,\n      peerType = options.peerType,\n      bucketCount = options.bucketCount;\n  var firstMod = peerType === PEER_TYPE.NEW_PEER ? BYTES_16 : BYTES_4;\n  var secretBytes = Buffer.alloc(exports.SECRET_BUFFER_LENGTH);\n  secretBytes.writeUInt32BE(secret, 0);\n  var network = exports.getNetwork(targetAddress);\n  var networkBytes = Buffer.alloc(exports.NETWORK_BUFFER_LENGTH);\n  networkBytes.writeUInt8(network, 0);\n\n  var _exports$getIPBytes2 = exports.getIPBytes(targetAddress),\n      targetABytes = _exports$getIPBytes2.aBytes,\n      targetBBytes = _exports$getIPBytes2.bBytes,\n      targetCBytes = _exports$getIPBytes2.cBytes,\n      targetDBytes = _exports$getIPBytes2.dBytes;\n\n  if (network === NETWORK.NET_OTHER) {\n    throw Error('IP address is unsupported.');\n  }\n\n  if (network !== NETWORK.NET_IPV4) {\n    return lisk_cryptography_1.hash(Buffer.concat([secretBytes, networkBytes])).readUInt32BE(0) % bucketCount;\n  }\n\n  var addressBytes = Buffer.concat([targetABytes, targetBBytes, targetCBytes, targetDBytes]);\n  var kBytes = Buffer.alloc(firstMod);\n  var sourceBytes = sourceAddress ? exports.getIPBytes(sourceAddress) : undefined;\n  var k = peerType === PEER_TYPE.NEW_PEER && sourceBytes ? lisk_cryptography_1.hash(Buffer.concat([secretBytes, networkBytes, sourceBytes.aBytes, sourceBytes.bBytes, targetABytes, targetBBytes])).readUInt32BE(0) % firstMod : lisk_cryptography_1.hash(Buffer.concat([secretBytes, networkBytes, addressBytes])).readUInt32BE(0) % firstMod;\n  kBytes.writeUInt32BE(k, 0);\n  var bucketBytes = peerType === PEER_TYPE.NEW_PEER && sourceBytes ? Buffer.concat([secretBytes, networkBytes, sourceBytes.aBytes, sourceBytes.bBytes, kBytes]) : Buffer.concat([secretBytes, networkBytes, targetABytes, targetBBytes, kBytes]);\n  return lisk_cryptography_1.hash(bucketBytes).readUInt32BE(0) % bucketCount;\n};\n\nexports.getBucketId = getBucketId;","map":{"version":3,"sources":["../../src/utils/network.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBucketId = exports.expirePeerFromBucket = exports.evictPeerRandomlyFromBucket = exports.getByteSize = exports.constructPeerId = exports.getNetgroup = exports.getNetwork = exports.isLocal = exports.isPrivate = exports.PEER_TYPE = exports.NETWORK = exports.getIPBytes = exports.getIPGroup = exports.NETWORK_BUFFER_LENGTH = exports.SECRET_BUFFER_LENGTH = void 0;\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst net_1 = require(\"net\");\nconst BYTES_4 = 4;\nconst BYTES_16 = 16;\nexports.SECRET_BUFFER_LENGTH = 4;\nexports.NETWORK_BUFFER_LENGTH = 1;\nconst PREFIX_BUFFER_LENGTH = 1;\nconst getIPGroup = (address, groupNumber) => {\n    if (groupNumber > 3) {\n        throw new Error('Invalid IP group.');\n    }\n    return parseInt(address.split('.')[groupNumber], 10);\n};\nexports.getIPGroup = getIPGroup;\nconst getIPBytes = (address) => {\n    const aBytes = Buffer.alloc(PREFIX_BUFFER_LENGTH);\n    aBytes.writeUInt8(exports.getIPGroup(address, 0), 0);\n    const bBytes = Buffer.alloc(PREFIX_BUFFER_LENGTH);\n    bBytes.writeUInt8(exports.getIPGroup(address, 1), 0);\n    const cBytes = Buffer.alloc(PREFIX_BUFFER_LENGTH);\n    cBytes.writeUInt8(exports.getIPGroup(address, 2), 0);\n    const dBytes = Buffer.alloc(PREFIX_BUFFER_LENGTH);\n    dBytes.writeUInt8(exports.getIPGroup(address, 3), 0);\n    return {\n        aBytes,\n        bBytes,\n        cBytes,\n        dBytes,\n    };\n};\nexports.getIPBytes = getIPBytes;\nvar NETWORK;\n(function (NETWORK) {\n    NETWORK[NETWORK[\"NET_IPV4\"] = 0] = \"NET_IPV4\";\n    NETWORK[NETWORK[\"NET_PRIVATE\"] = 1] = \"NET_PRIVATE\";\n    NETWORK[NETWORK[\"NET_LOCAL\"] = 2] = \"NET_LOCAL\";\n    NETWORK[NETWORK[\"NET_OTHER\"] = 3] = \"NET_OTHER\";\n})(NETWORK = exports.NETWORK || (exports.NETWORK = {}));\nvar PEER_TYPE;\n(function (PEER_TYPE) {\n    PEER_TYPE[\"NEW_PEER\"] = \"newPeer\";\n    PEER_TYPE[\"TRIED_PEER\"] = \"triedPeer\";\n})(PEER_TYPE = exports.PEER_TYPE || (exports.PEER_TYPE = {}));\nconst isPrivate = (address) => exports.getIPGroup(address, 0) === 10 ||\n    (exports.getIPGroup(address, 0) === 172 && exports.getIPGroup(address, 1) >= 16 && exports.getIPGroup(address, 1) <= 31);\nexports.isPrivate = isPrivate;\nconst isLocal = (address) => exports.getIPGroup(address, 0) === 127 || address === '0.0.0.0';\nexports.isLocal = isLocal;\nconst getNetwork = (address) => {\n    if (exports.isLocal(address)) {\n        return NETWORK.NET_LOCAL;\n    }\n    if (exports.isPrivate(address)) {\n        return NETWORK.NET_PRIVATE;\n    }\n    if (net_1.isIPv4(address)) {\n        return NETWORK.NET_IPV4;\n    }\n    return NETWORK.NET_OTHER;\n};\nexports.getNetwork = getNetwork;\nconst getNetgroup = (address, secret) => {\n    const secretBytes = Buffer.alloc(exports.SECRET_BUFFER_LENGTH);\n    secretBytes.writeUInt32BE(secret, 0);\n    const network = exports.getNetwork(address);\n    const networkBytes = Buffer.alloc(exports.NETWORK_BUFFER_LENGTH);\n    networkBytes.writeUInt8(network, 0);\n    const { aBytes, bBytes } = exports.getIPBytes(address);\n    if (network === NETWORK.NET_OTHER) {\n        throw Error('IP address is unsupported.');\n    }\n    const netgroupBytes = Buffer.concat([secretBytes, networkBytes, aBytes, bBytes]);\n    return lisk_cryptography_1.hash(netgroupBytes).readUInt32BE(0);\n};\nexports.getNetgroup = getNetgroup;\nconst constructPeerId = (ipAddress, port) => `${ipAddress}:${port}`;\nexports.constructPeerId = constructPeerId;\nconst getByteSize = (data) => {\n    if (Buffer.isBuffer(data)) {\n        return data.length;\n    }\n    return Buffer.byteLength(JSON.stringify(data));\n};\nexports.getByteSize = getByteSize;\nconst evictPeerRandomlyFromBucket = (bucket) => {\n    const bucketPeerIds = Array.from(bucket.keys());\n    const randomPeerIndex = Math.floor(Math.random() * bucketPeerIds.length);\n    const randomPeerId = bucketPeerIds[randomPeerIndex];\n    const evictedPeer = bucket.get(randomPeerId);\n    bucket.delete(randomPeerId);\n    return evictedPeer;\n};\nexports.evictPeerRandomlyFromBucket = evictPeerRandomlyFromBucket;\nconst expirePeerFromBucket = (bucket, thresholdTime) => {\n    for (const [peerId, peer] of bucket) {\n        const timeDifference = Math.round(Math.abs(peer.dateAdded.getTime() - new Date().getTime()));\n        if (timeDifference >= thresholdTime) {\n            bucket.delete(peerId);\n            return peer;\n        }\n    }\n    return undefined;\n};\nexports.expirePeerFromBucket = expirePeerFromBucket;\nconst getBucketId = (options) => {\n    const { secret, targetAddress, sourceAddress, peerType, bucketCount } = options;\n    const firstMod = peerType === PEER_TYPE.NEW_PEER ? BYTES_16 : BYTES_4;\n    const secretBytes = Buffer.alloc(exports.SECRET_BUFFER_LENGTH);\n    secretBytes.writeUInt32BE(secret, 0);\n    const network = exports.getNetwork(targetAddress);\n    const networkBytes = Buffer.alloc(exports.NETWORK_BUFFER_LENGTH);\n    networkBytes.writeUInt8(network, 0);\n    const { aBytes: targetABytes, bBytes: targetBBytes, cBytes: targetCBytes, dBytes: targetDBytes, } = exports.getIPBytes(targetAddress);\n    if (network === NETWORK.NET_OTHER) {\n        throw Error('IP address is unsupported.');\n    }\n    if (network !== NETWORK.NET_IPV4) {\n        return lisk_cryptography_1.hash(Buffer.concat([secretBytes, networkBytes])).readUInt32BE(0) % bucketCount;\n    }\n    const addressBytes = Buffer.concat([targetABytes, targetBBytes, targetCBytes, targetDBytes]);\n    const kBytes = Buffer.alloc(firstMod);\n    const sourceBytes = sourceAddress ? exports.getIPBytes(sourceAddress) : undefined;\n    const k = peerType === PEER_TYPE.NEW_PEER && sourceBytes\n        ? lisk_cryptography_1.hash(Buffer.concat([\n            secretBytes,\n            networkBytes,\n            sourceBytes.aBytes,\n            sourceBytes.bBytes,\n            targetABytes,\n            targetBBytes,\n        ])).readUInt32BE(0) % firstMod\n        : lisk_cryptography_1.hash(Buffer.concat([secretBytes, networkBytes, addressBytes])).readUInt32BE(0) % firstMod;\n    kBytes.writeUInt32BE(k, 0);\n    const bucketBytes = peerType === PEER_TYPE.NEW_PEER && sourceBytes\n        ? Buffer.concat([secretBytes, networkBytes, sourceBytes.aBytes, sourceBytes.bBytes, kBytes])\n        : Buffer.concat([secretBytes, networkBytes, targetABytes, targetBBytes, kBytes]);\n    return lisk_cryptography_1.hash(bucketBytes).readUInt32BE(0) % bucketCount;\n};\nexports.getBucketId = getBucketId;\n//# sourceMappingURL=network.js.map"]},"metadata":{},"sourceType":"script"}