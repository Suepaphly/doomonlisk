{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseEncryptedPassphrase = exports.stringifyEncryptedPassphrase = exports.convertPrivateKeyEd2Curve = exports.convertPublicKeyEd2Curve = exports.getFirstEightBytesReversed = exports.convertUInt5ToBase32 = exports.convertUIntArray = void 0;\n\nvar ed2curve = require(\"ed2curve\");\n\nvar querystring = require(\"querystring\");\n\nvar reverse = require(\"buffer-reverse\");\n\nvar CHARSET = 'zxvcpmbn3465o978uyrtkqew2adsjhfg';\n\nvar convertUIntArray = function convertUIntArray(uintArray, fromBits, toBits) {\n  var maxValue = (1 << toBits) - 1;\n  var accumulator = 0;\n  var bits = 0;\n  var result = [];\n\n  for (var p = 0; p < uintArray.length; p += 1) {\n    var byte = uintArray[p];\n\n    if (byte < 0 || byte >> fromBits !== 0) {\n      return [];\n    }\n\n    accumulator = accumulator << fromBits | byte;\n    bits += fromBits;\n\n    while (bits >= toBits) {\n      bits -= toBits;\n      result.push(accumulator >> bits & maxValue);\n    }\n  }\n\n  return result;\n};\n\nexports.convertUIntArray = convertUIntArray;\n\nvar convertUInt5ToBase32 = function convertUInt5ToBase32(uint5Array) {\n  return uint5Array.map(function (val) {\n    return CHARSET[val];\n  }).join('');\n};\n\nexports.convertUInt5ToBase32 = convertUInt5ToBase32;\n\nvar getFirstEightBytesReversed = function getFirstEightBytesReversed(input) {\n  var BUFFER_SIZE = 8;\n\n  if (typeof input === 'string') {\n    return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n  }\n\n  return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n};\n\nexports.getFirstEightBytesReversed = getFirstEightBytesReversed;\nexports.convertPublicKeyEd2Curve = ed2curve.convertPublicKey;\nexports.convertPrivateKeyEd2Curve = ed2curve.convertSecretKey;\n\nvar stringifyEncryptedPassphrase = function stringifyEncryptedPassphrase(encryptedPassphrase) {\n  if (typeof encryptedPassphrase !== 'object' || encryptedPassphrase === null) {\n    throw new Error('Encrypted passphrase to stringify must be an object.');\n  }\n\n  var objectToStringify = encryptedPassphrase.iterations ? encryptedPassphrase : {\n    salt: encryptedPassphrase.salt,\n    cipherText: encryptedPassphrase.cipherText,\n    iv: encryptedPassphrase.iv,\n    tag: encryptedPassphrase.tag,\n    version: encryptedPassphrase.version\n  };\n  return querystring.stringify(objectToStringify);\n};\n\nexports.stringifyEncryptedPassphrase = stringifyEncryptedPassphrase;\n\nvar parseIterations = function parseIterations(iterationsString) {\n  var iterations = iterationsString === undefined ? undefined : parseInt(iterationsString, 10);\n\n  if (typeof iterations !== 'undefined' && Number.isNaN(iterations)) {\n    throw new Error('Could not parse iterations.');\n  }\n\n  return iterations;\n};\n\nvar parseEncryptedPassphrase = function parseEncryptedPassphrase(encryptedPassphrase) {\n  if (typeof encryptedPassphrase !== 'string') {\n    throw new Error('Encrypted passphrase to parse must be a string.');\n  }\n\n  var keyValuePairs = querystring.parse(encryptedPassphrase);\n  var iterations = keyValuePairs.iterations,\n      salt = keyValuePairs.salt,\n      cipherText = keyValuePairs.cipherText,\n      iv = keyValuePairs.iv,\n      tag = keyValuePairs.tag,\n      version = keyValuePairs.version;\n\n  if (typeof iterations !== 'string' && typeof iterations !== 'undefined' || typeof salt !== 'string' || typeof cipherText !== 'string' || typeof iv !== 'string' || typeof tag !== 'string' || typeof version !== 'string') {\n    throw new Error('Encrypted passphrase to parse must have only one value per key.');\n  }\n\n  return {\n    iterations: parseIterations(iterations),\n    salt: salt,\n    cipherText: cipherText,\n    iv: iv,\n    tag: tag,\n    version: version\n  };\n};\n\nexports.parseEncryptedPassphrase = parseEncryptedPassphrase;","map":{"version":3,"sources":["../src/convert.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseEncryptedPassphrase = exports.stringifyEncryptedPassphrase = exports.convertPrivateKeyEd2Curve = exports.convertPublicKeyEd2Curve = exports.getFirstEightBytesReversed = exports.convertUInt5ToBase32 = exports.convertUIntArray = void 0;\nconst ed2curve = require(\"ed2curve\");\nconst querystring = require(\"querystring\");\nconst reverse = require(\"buffer-reverse\");\nconst CHARSET = 'zxvcpmbn3465o978uyrtkqew2adsjhfg';\nconst convertUIntArray = (uintArray, fromBits, toBits) => {\n    const maxValue = (1 << toBits) - 1;\n    let accumulator = 0;\n    let bits = 0;\n    const result = [];\n    for (let p = 0; p < uintArray.length; p += 1) {\n        const byte = uintArray[p];\n        if (byte < 0 || byte >> fromBits !== 0) {\n            return [];\n        }\n        accumulator = (accumulator << fromBits) | byte;\n        bits += fromBits;\n        while (bits >= toBits) {\n            bits -= toBits;\n            result.push((accumulator >> bits) & maxValue);\n        }\n    }\n    return result;\n};\nexports.convertUIntArray = convertUIntArray;\nconst convertUInt5ToBase32 = (uint5Array) => uint5Array.map((val) => CHARSET[val]).join('');\nexports.convertUInt5ToBase32 = convertUInt5ToBase32;\nconst getFirstEightBytesReversed = (input) => {\n    const BUFFER_SIZE = 8;\n    if (typeof input === 'string') {\n        return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n    }\n    return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n};\nexports.getFirstEightBytesReversed = getFirstEightBytesReversed;\nexports.convertPublicKeyEd2Curve = ed2curve.convertPublicKey;\nexports.convertPrivateKeyEd2Curve = ed2curve.convertSecretKey;\nconst stringifyEncryptedPassphrase = (encryptedPassphrase) => {\n    if (typeof encryptedPassphrase !== 'object' || encryptedPassphrase === null) {\n        throw new Error('Encrypted passphrase to stringify must be an object.');\n    }\n    const objectToStringify = encryptedPassphrase.iterations\n        ? encryptedPassphrase\n        : {\n            salt: encryptedPassphrase.salt,\n            cipherText: encryptedPassphrase.cipherText,\n            iv: encryptedPassphrase.iv,\n            tag: encryptedPassphrase.tag,\n            version: encryptedPassphrase.version,\n        };\n    return querystring.stringify(objectToStringify);\n};\nexports.stringifyEncryptedPassphrase = stringifyEncryptedPassphrase;\nconst parseIterations = (iterationsString) => {\n    const iterations = iterationsString === undefined ? undefined : parseInt(iterationsString, 10);\n    if (typeof iterations !== 'undefined' && Number.isNaN(iterations)) {\n        throw new Error('Could not parse iterations.');\n    }\n    return iterations;\n};\nconst parseEncryptedPassphrase = (encryptedPassphrase) => {\n    if (typeof encryptedPassphrase !== 'string') {\n        throw new Error('Encrypted passphrase to parse must be a string.');\n    }\n    const keyValuePairs = querystring.parse(encryptedPassphrase);\n    const { iterations, salt, cipherText, iv, tag, version } = keyValuePairs;\n    if ((typeof iterations !== 'string' && typeof iterations !== 'undefined') ||\n        typeof salt !== 'string' ||\n        typeof cipherText !== 'string' ||\n        typeof iv !== 'string' ||\n        typeof tag !== 'string' ||\n        typeof version !== 'string') {\n        throw new Error('Encrypted passphrase to parse must have only one value per key.');\n    }\n    return {\n        iterations: parseIterations(iterations),\n        salt,\n        cipherText,\n        iv,\n        tag,\n        version,\n    };\n};\nexports.parseEncryptedPassphrase = parseEncryptedPassphrase;\n//# sourceMappingURL=convert.js.map"]},"metadata":{},"sourceType":"script"}