{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectWithoutProperties = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _excluded = [\"default\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Chain = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_db_1 = require(\"@liskhq/lisk-db\");\n\nvar createDebug = require(\"debug\");\n\nvar events_1 = require(\"events\");\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nvar block_reward_1 = require(\"./block_reward\");\n\nvar constants_1 = require(\"./constants\");\n\nvar data_access_1 = require(\"./data_access\");\n\nvar slots_1 = require(\"./slots\");\n\nvar state_store_1 = require(\"./state_store\");\n\nvar account_1 = require(\"./utils/account\");\n\nvar validate_1 = require(\"./validate\");\n\nvar verify_1 = require(\"./verify\");\n\nvar schema_1 = require(\"./schema\");\n\nvar debug = createDebug('lisk:chain');\n\nvar Chain = /*#__PURE__*/function () {\n  function Chain(_ref) {\n    var db = _ref.db,\n        genesisBlock = _ref.genesisBlock,\n        accountSchemas = _ref.accountSchemas,\n        blockTime = _ref.blockTime,\n        networkIdentifier = _ref.networkIdentifier,\n        maxPayloadLength = _ref.maxPayloadLength,\n        rewardDistance = _ref.rewardDistance,\n        rewardOffset = _ref.rewardOffset,\n        rewardMilestones = _ref.rewardMilestones,\n        minFeePerByte = _ref.minFeePerByte,\n        baseFees = _ref.baseFees,\n        _ref$minBlockHeaderCa = _ref.minBlockHeaderCache,\n        minBlockHeaderCache = _ref$minBlockHeaderCa === void 0 ? constants_1.DEFAULT_MIN_BLOCK_HEADER_CACHE : _ref$minBlockHeaderCa,\n        _ref$maxBlockHeaderCa = _ref.maxBlockHeaderCache,\n        maxBlockHeaderCache = _ref$maxBlockHeaderCa === void 0 ? constants_1.DEFAULT_MAX_BLOCK_HEADER_CACHE : _ref$maxBlockHeaderCa;\n\n    _classCallCheck(this, Chain);\n\n    this._numberOfValidators = -1;\n    this.events = new events_1.EventEmitter();\n\n    var _account_1$getAccount = account_1.getAccountSchemaWithDefault(accountSchemas),\n        defaultAccount = _account_1$getAccount.default,\n        schema = _objectWithoutProperties(_account_1$getAccount, _excluded);\n\n    this._defaultAccount = defaultAccount;\n    this._accountSchema = schema;\n    this._blockAssetSchema = schema_1.getRegisteredBlockAssetSchema(this._accountSchema);\n    lisk_codec_1.codec.addSchema(schema_1.blockSchema);\n    lisk_codec_1.codec.addSchema(schema_1.blockHeaderSchema);\n    lisk_codec_1.codec.addSchema(schema_1.signingBlockHeaderSchema);\n\n    for (var _i = 0, _Object$values = Object.values(this._blockAssetSchema); _i < _Object$values.length; _i++) {\n      var assetSchema = _Object$values[_i];\n      lisk_codec_1.codec.addSchema(assetSchema);\n    }\n\n    lisk_codec_1.codec.addSchema(this._accountSchema);\n    lisk_codec_1.codec.addSchema(schema_1.stateDiffSchema);\n    this.dataAccess = new data_access_1.DataAccess({\n      db: db,\n      registeredBlockHeaders: this._blockAssetSchema,\n      accountSchema: this._accountSchema,\n      minBlockHeaderCache: minBlockHeaderCache,\n      maxBlockHeaderCache: maxBlockHeaderCache\n    });\n    this._lastBlock = genesisBlock;\n    this._networkIdentifier = networkIdentifier;\n    this.slots = new slots_1.Slots({\n      genesisBlockTimestamp: genesisBlock.header.timestamp,\n      interval: blockTime\n    });\n    this._genesisHeight = genesisBlock.header.height;\n    this._blockRewardArgs = {\n      distance: rewardDistance,\n      rewardOffset: rewardOffset,\n      milestones: rewardMilestones\n    };\n    this.constants = {\n      blockTime: blockTime,\n      maxPayloadLength: maxPayloadLength,\n      rewardDistance: rewardDistance,\n      rewardOffset: rewardOffset,\n      rewardMilestones: rewardMilestones,\n      networkIdentifier: networkIdentifier,\n      minFeePerByte: minFeePerByte,\n      baseFees: baseFees\n    };\n  }\n\n  _createClass(Chain, [{\n    key: \"genesisHeight\",\n    get: function get() {\n      return this._genesisHeight;\n    }\n  }, {\n    key: \"lastBlock\",\n    get: function get() {\n      return this._lastBlock;\n    }\n  }, {\n    key: \"numberOfValidators\",\n    get: function get() {\n      return this._numberOfValidators;\n    }\n  }, {\n    key: \"accountSchema\",\n    get: function get() {\n      return this._accountSchema;\n    }\n  }, {\n    key: \"blockAssetSchema\",\n    get: function get() {\n      return this._blockAssetSchema;\n    }\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(genesisBlock) {\n        var storageLastBlock, genesisInfo, validators;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this.dataAccess.getLastBlock();\n\n              case 3:\n                storageLastBlock = _context.sent;\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](0);\n                throw new Error('Failed to load last block');\n\n              case 9:\n                if (!(storageLastBlock.header.height !== genesisBlock.header.height)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                _context.next = 12;\n                return this._cacheBlockHeaders(storageLastBlock);\n\n              case 12:\n                _context.next = 14;\n                return this._getGenesisInfo();\n\n              case 14:\n                genesisInfo = _context.sent;\n\n                if (genesisInfo) {\n                  _context.next = 18;\n                  break;\n                }\n\n                _context.next = 18;\n                return this.dataAccess.setConsensusState(constants_1.CONSENSUS_STATE_GENESIS_INFO, lisk_codec_1.codec.encode(schema_1.genesisInfoSchema, {\n                  height: genesisBlock.header.height,\n                  initRounds: genesisBlock.header.asset.initRounds\n                }));\n\n              case 18:\n                _context.next = 20;\n                return this.getValidators();\n\n              case 20:\n                validators = _context.sent;\n                this._numberOfValidators = validators.length;\n                this._lastBlock = storageLastBlock;\n\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 6]]);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"calculateDefaultReward\",\n    value: function calculateDefaultReward(height) {\n      return block_reward_1.calculateDefaultReward(height, this._blockRewardArgs);\n    }\n  }, {\n    key: \"calculateExpectedReward\",\n    value: function calculateExpectedReward(blockHeader, stateStore) {\n      var defaultReward = this.calculateDefaultReward(blockHeader.height);\n      var isValid = this.isValidSeedReveal(blockHeader, stateStore);\n      return isValid ? defaultReward : BigInt(0);\n    }\n  }, {\n    key: \"resetBlockHeaderCache\",\n    value: function resetBlockHeaderCache() {\n      this.dataAccess.resetBlockHeaderCache();\n    }\n  }, {\n    key: \"newStateStore\",\n    value: function () {\n      var _newStateStore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var skipLastHeights,\n            _a,\n            _b,\n            _c,\n            genesisInfo,\n            fromHeight,\n            toHeight,\n            lastBlockHeaders,\n            lastBlockReward,\n            _args2 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                skipLastHeights = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : 0;\n                _context2.next = 3;\n                return this._getGenesisInfo();\n\n              case 3:\n                genesisInfo = _context2.sent;\n                fromHeight = Math.max((_a = genesisInfo === null || genesisInfo === void 0 ? void 0 : genesisInfo.height) !== null && _a !== void 0 ? _a : 0, this._lastBlock.header.height - this.numberOfValidators * 3 - skipLastHeights);\n                toHeight = Math.max(this._lastBlock.header.height - skipLastHeights, 1);\n                _context2.next = 8;\n                return this.dataAccess.getBlockHeadersByHeightBetween(fromHeight, toHeight);\n\n              case 8:\n                lastBlockHeaders = _context2.sent;\n                lastBlockReward = this.calculateDefaultReward((_c = (_b = lastBlockHeaders[0]) === null || _b === void 0 ? void 0 : _b.height) !== null && _c !== void 0 ? _c : 1);\n                return _context2.abrupt(\"return\", new state_store_1.StateStore(this.dataAccess, {\n                  networkIdentifier: this._networkIdentifier,\n                  lastBlockHeaders: lastBlockHeaders,\n                  lastBlockReward: lastBlockReward,\n                  defaultAccount: this._defaultAccount\n                }));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function newStateStore() {\n        return _newStateStore.apply(this, arguments);\n      }\n\n      return newStateStore;\n    }()\n  }, {\n    key: \"genesisBlockExist\",\n    value: function () {\n      var _genesisBlockExist = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(genesisBlock) {\n        var matchingGenesisBlock, lastBlockHeader;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.dataAccess.blockHeaderExists(genesisBlock.header.id);\n\n              case 2:\n                matchingGenesisBlock = _context3.sent;\n                _context3.prev = 3;\n                _context3.next = 6;\n                return this.dataAccess.getLastBlockHeader();\n\n              case 6:\n                lastBlockHeader = _context3.sent;\n                _context3.next = 13;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](3);\n\n                if (_context3.t0 instanceof lisk_db_1.NotFoundError) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                throw _context3.t0;\n\n              case 13:\n                if (!(lastBlockHeader && !matchingGenesisBlock)) {\n                  _context3.next = 15;\n                  break;\n                }\n\n                throw new Error('Genesis block does not match');\n\n              case 15:\n                if (!(!lastBlockHeader && !matchingGenesisBlock)) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", false);\n\n              case 17:\n                return _context3.abrupt(\"return\", true);\n\n              case 18:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 9]]);\n      }));\n\n      function genesisBlockExist(_x2) {\n        return _genesisBlockExist.apply(this, arguments);\n      }\n\n      return genesisBlockExist;\n    }()\n  }, {\n    key: \"isValidSeedReveal\",\n    value: function isValidSeedReveal(blockHeader, stateStore) {\n      return verify_1.isValidSeedReveal(blockHeader, stateStore, this.numberOfValidators);\n    }\n  }, {\n    key: \"validateGenesisBlockHeader\",\n    value: function validateGenesisBlockHeader(block) {\n      validate_1.validateGenesisBlockHeader(block, this._accountSchema);\n    }\n  }, {\n    key: \"applyGenesisBlock\",\n    value: function () {\n      var _applyGenesisBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(block, stateStore) {\n        var _iterator, _step, account, initialValidators;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _iterator = _createForOfIteratorHelper(block.header.asset.accounts);\n                _context4.prev = 1;\n\n                _iterator.s();\n\n              case 3:\n                if ((_step = _iterator.n()).done) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                account = _step.value;\n                _context4.next = 7;\n                return stateStore.account.set(account.address, account);\n\n              case 7:\n                _context4.next = 3;\n                break;\n\n              case 9:\n                _context4.next = 14;\n                break;\n\n              case 11:\n                _context4.prev = 11;\n                _context4.t0 = _context4[\"catch\"](1);\n\n                _iterator.e(_context4.t0);\n\n              case 14:\n                _context4.prev = 14;\n\n                _iterator.f();\n\n                return _context4.finish(14);\n\n              case 17:\n                initialValidators = block.header.asset.initDelegates.map(function (address) {\n                  return {\n                    address: address,\n                    minActiveHeight: block.header.height + 1,\n                    isConsensusParticipant: false\n                  };\n                });\n                _context4.next = 20;\n                return stateStore.consensus.set(constants_1.CONSENSUS_STATE_VALIDATORS_KEY, lisk_codec_1.codec.encode(schema_1.validatorsSchema, {\n                  validators: initialValidators\n                }));\n\n              case 20:\n                _context4.next = 22;\n                return stateStore.consensus.set(constants_1.CONSENSUS_STATE_GENESIS_INFO, lisk_codec_1.codec.encode(schema_1.genesisInfoSchema, {\n                  height: block.header.height,\n                  initRounds: block.header.asset.initRounds\n                }));\n\n              case 22:\n                this._numberOfValidators = block.header.asset.initDelegates.length;\n\n              case 23:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 11, 14, 17]]);\n      }));\n\n      function applyGenesisBlock(_x3, _x4) {\n        return _applyGenesisBlock.apply(this, arguments);\n      }\n\n      return applyGenesisBlock;\n    }()\n  }, {\n    key: \"validateTransaction\",\n    value: function validateTransaction(transaction) {\n      transaction.validate({\n        minFeePerByte: this.constants.minFeePerByte,\n        baseFees: this.constants.baseFees\n      });\n    }\n  }, {\n    key: \"validateBlockHeader\",\n    value: function validateBlockHeader(block) {\n      var _this = this;\n\n      var headerWithoutAsset = _objectSpread(_objectSpread({}, block.header), {}, {\n        asset: Buffer.alloc(0)\n      });\n\n      var errors = lisk_validator_1.validator.validate(schema_1.blockHeaderSchema, headerWithoutAsset);\n\n      if (errors.length) {\n        throw new lisk_validator_1.LiskValidationError(errors);\n      }\n\n      var assetSchema = this.dataAccess.getBlockHeaderAssetSchema(block.header.version);\n      var assetErrors = lisk_validator_1.validator.validate(assetSchema, block.header.asset);\n\n      if (assetErrors.length) {\n        throw new lisk_validator_1.LiskValidationError(assetErrors);\n      }\n\n      var encodedBlockHeaderWithoutSignature = this.dataAccess.encodeBlockHeader(block.header, true);\n      validate_1.validateSignature(block.header.generatorPublicKey, encodedBlockHeaderWithoutSignature, block.header.signature, this._networkIdentifier);\n      validate_1.validateReward(block, this.calculateDefaultReward(block.header.height));\n      var encodedPayload = Buffer.concat(block.payload.map(function (tx) {\n        return _this.dataAccess.encodeTransaction(tx);\n      }));\n      validate_1.validateBlockProperties(block, encodedPayload, this.constants.maxPayloadLength);\n    }\n  }, {\n    key: \"verifyBlockHeader\",\n    value: function () {\n      var _verifyBlockHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(block, stateStore) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                verify_1.verifyPreviousBlockId(block, this._lastBlock);\n                validate_1.validateBlockSlot(block, this._lastBlock, this.slots);\n                verify_1.verifyReward(block.header, stateStore, this.numberOfValidators);\n                _context5.next = 5;\n                return verify_1.verifyBlockGenerator(block.header, this.slots, stateStore);\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function verifyBlockHeader(_x5, _x6) {\n        return _verifyBlockHeader.apply(this, arguments);\n      }\n\n      return verifyBlockHeader;\n    }()\n  }, {\n    key: \"saveBlock\",\n    value: function () {\n      var _saveBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(block, stateStore, finalizedHeight) {\n        var _ref2,\n            removeFromTempTable,\n            _args6 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _ref2 = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : {\n                  removeFromTempTable: false\n                }, removeFromTempTable = _ref2.removeFromTempTable;\n                _context6.next = 3;\n                return this.dataAccess.saveBlock(block, stateStore, finalizedHeight, removeFromTempTable);\n\n              case 3:\n                this.dataAccess.addBlockHeader(block.header);\n                this._lastBlock = block;\n                this.events.emit(constants_1.EVENT_NEW_BLOCK, {\n                  block: block,\n                  accounts: stateStore.account.getUpdated()\n                });\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function saveBlock(_x7, _x8, _x9) {\n        return _saveBlock.apply(this, arguments);\n      }\n\n      return saveBlock;\n    }()\n  }, {\n    key: \"removeBlock\",\n    value: function () {\n      var _removeBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(block, stateStore) {\n        var _ref3,\n            saveTempBlock,\n            secondLastBlock,\n            updatedAccounts,\n            _args7 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _ref3 = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : {\n                  saveTempBlock: false\n                }, saveTempBlock = _ref3.saveTempBlock;\n\n                if (!(block.header.version === constants_1.GENESIS_BLOCK_VERSION)) {\n                  _context7.next = 3;\n                  break;\n                }\n\n                throw new Error('Cannot delete genesis block');\n\n              case 3:\n                _context7.prev = 3;\n                _context7.next = 6;\n                return this.dataAccess.getBlockByID(block.header.previousBlockID);\n\n              case 6:\n                secondLastBlock = _context7.sent;\n                _context7.next = 12;\n                break;\n\n              case 9:\n                _context7.prev = 9;\n                _context7.t0 = _context7[\"catch\"](3);\n                throw new Error('PreviousBlock is null');\n\n              case 12:\n                _context7.next = 14;\n                return this.dataAccess.deleteBlock(block, stateStore, saveTempBlock);\n\n              case 14:\n                updatedAccounts = _context7.sent;\n                _context7.next = 17;\n                return this.dataAccess.removeBlockHeader(block.header.id);\n\n              case 17:\n                this._lastBlock = secondLastBlock;\n                this.events.emit(constants_1.EVENT_DELETE_BLOCK, {\n                  block: block,\n                  accounts: updatedAccounts\n                });\n\n              case 19:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[3, 9]]);\n      }));\n\n      function removeBlock(_x10, _x11) {\n        return _removeBlock.apply(this, arguments);\n      }\n\n      return removeBlock;\n    }()\n  }, {\n    key: \"getValidator\",\n    value: function () {\n      var _getValidator = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(timestamp) {\n        var validators, currentSlot;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this.getValidators();\n\n              case 2:\n                validators = _context8.sent;\n                currentSlot = this.slots.getSlotNumber(timestamp);\n                return _context8.abrupt(\"return\", validators[currentSlot % validators.length]);\n\n              case 5:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getValidator(_x12) {\n        return _getValidator.apply(this, arguments);\n      }\n\n      return getValidator;\n    }()\n  }, {\n    key: \"getValidators\",\n    value: function () {\n      var _getValidators = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var validatorsBuffer, _lisk_codec_1$codec$d, validators;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.dataAccess.getConsensusState(constants_1.CONSENSUS_STATE_VALIDATORS_KEY);\n\n              case 2:\n                validatorsBuffer = _context9.sent;\n\n                if (validatorsBuffer) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", []);\n\n              case 5:\n                _lisk_codec_1$codec$d = lisk_codec_1.codec.decode(schema_1.validatorsSchema, validatorsBuffer), validators = _lisk_codec_1$codec$d.validators;\n                return _context9.abrupt(\"return\", validators);\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getValidators() {\n        return _getValidators.apply(this, arguments);\n      }\n\n      return getValidators;\n    }()\n  }, {\n    key: \"setValidators\",\n    value: function () {\n      var _setValidators = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(validators, stateStore, blockHeader) {\n        var lastBootstrapHeight, validatorsBuffer, _lisk_codec_1$codec$d2, previousValidators, nextValidatorSet, _iterator2, _step2, _loop, encodedValidators;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this._getLastBootstrapHeight();\n\n              case 2:\n                lastBootstrapHeight = _context10.sent;\n\n                if (!(lastBootstrapHeight > blockHeader.height)) {\n                  _context10.next = 6;\n                  break;\n                }\n\n                debug(\"Skipping updating validator since current height \".concat(blockHeader.height, \" is lower than last bootstrap height \").concat(lastBootstrapHeight));\n                return _context10.abrupt(\"return\");\n\n              case 6:\n                _context10.next = 8;\n                return stateStore.consensus.get(constants_1.CONSENSUS_STATE_VALIDATORS_KEY);\n\n              case 8:\n                validatorsBuffer = _context10.sent;\n\n                if (validatorsBuffer) {\n                  _context10.next = 11;\n                  break;\n                }\n\n                throw new Error('Previous validator set must exist');\n\n              case 11:\n                _lisk_codec_1$codec$d2 = lisk_codec_1.codec.decode(schema_1.validatorsSchema, validatorsBuffer), previousValidators = _lisk_codec_1$codec$d2.validators;\n                nextValidatorSet = [];\n                _iterator2 = _createForOfIteratorHelper(validators);\n\n                try {\n                  _loop = function _loop() {\n                    var nextValidator = _step2.value;\n                    var previousInfo = previousValidators.find(function (pv) {\n                      return pv.address.equals(nextValidator.address);\n                    });\n                    nextValidatorSet.push(_objectSpread(_objectSpread({}, nextValidator), {}, {\n                      minActiveHeight: previousInfo !== undefined ? previousInfo.minActiveHeight : blockHeader.height + 1\n                    }));\n                  };\n\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    _loop();\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                encodedValidators = lisk_codec_1.codec.encode(schema_1.validatorsSchema, {\n                  validators: nextValidatorSet\n                });\n                _context10.next = 18;\n                return stateStore.consensus.set(constants_1.CONSENSUS_STATE_VALIDATORS_KEY, encodedValidators);\n\n              case 18:\n                this.events.emit(constants_1.EVENT_VALIDATORS_CHANGED, {\n                  validators: nextValidatorSet\n                });\n\n              case 19:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function setValidators(_x13, _x14, _x15) {\n        return _setValidators.apply(this, arguments);\n      }\n\n      return setValidators;\n    }()\n  }, {\n    key: \"_cacheBlockHeaders\",\n    value: function () {\n      var _cacheBlockHeaders2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(storageLastBlock) {\n        var fromHeight, toHeight, blockHeaders, sortedBlockHeaders, _iterator3, _step3, blockHeader;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                fromHeight = Math.max(storageLastBlock.header.height - constants_1.DEFAULT_MAX_BLOCK_HEADER_CACHE, 0);\n                toHeight = storageLastBlock.header.height;\n                debug({\n                  h: storageLastBlock.header.height,\n                  fromHeight: fromHeight,\n                  toHeight: toHeight\n                }, 'Cache block headers during chain init');\n                _context11.next = 5;\n                return this.dataAccess.getBlockHeadersByHeightBetween(fromHeight, toHeight);\n\n              case 5:\n                blockHeaders = _context11.sent;\n                sortedBlockHeaders = _toConsumableArray(blockHeaders).sort(function (a, b) {\n                  return a.height - b.height;\n                });\n                _iterator3 = _createForOfIteratorHelper(sortedBlockHeaders);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    blockHeader = _step3.value;\n                    debug({\n                      height: blockHeader.height\n                    }, 'Add block header to cache');\n                    this.dataAccess.addBlockHeader(blockHeader);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n              case 9:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function _cacheBlockHeaders(_x16) {\n        return _cacheBlockHeaders2.apply(this, arguments);\n      }\n\n      return _cacheBlockHeaders;\n    }()\n  }, {\n    key: \"_getLastBootstrapHeight\",\n    value: function () {\n      var _getLastBootstrapHeight2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var genesisInfo;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.next = 2;\n                return this._getGenesisInfo();\n\n              case 2:\n                genesisInfo = _context12.sent;\n\n                if (genesisInfo) {\n                  _context12.next = 5;\n                  break;\n                }\n\n                throw new Error('genesis info not stored');\n\n              case 5:\n                return _context12.abrupt(\"return\", this._numberOfValidators * genesisInfo.initRounds + genesisInfo.height);\n\n              case 6:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function _getLastBootstrapHeight() {\n        return _getLastBootstrapHeight2.apply(this, arguments);\n      }\n\n      return _getLastBootstrapHeight;\n    }()\n  }, {\n    key: \"_getGenesisInfo\",\n    value: function () {\n      var _getGenesisInfo2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var genesisInfoBytes;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.dataAccess.getConsensusState(constants_1.CONSENSUS_STATE_GENESIS_INFO);\n\n              case 2:\n                genesisInfoBytes = _context13.sent;\n\n                if (genesisInfoBytes) {\n                  _context13.next = 5;\n                  break;\n                }\n\n                return _context13.abrupt(\"return\", undefined);\n\n              case 5:\n                return _context13.abrupt(\"return\", lisk_codec_1.codec.decode(schema_1.genesisInfoSchema, genesisInfoBytes));\n\n              case 6:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function _getGenesisInfo() {\n        return _getGenesisInfo2.apply(this, arguments);\n      }\n\n      return _getGenesisInfo;\n    }()\n  }]);\n\n  return Chain;\n}();\n\nexports.Chain = Chain;","map":{"version":3,"sources":["../src/chain.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Chain = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_db_1 = require(\"@liskhq/lisk-db\");\nconst createDebug = require(\"debug\");\nconst events_1 = require(\"events\");\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst block_reward_1 = require(\"./block_reward\");\nconst constants_1 = require(\"./constants\");\nconst data_access_1 = require(\"./data_access\");\nconst slots_1 = require(\"./slots\");\nconst state_store_1 = require(\"./state_store\");\nconst account_1 = require(\"./utils/account\");\nconst validate_1 = require(\"./validate\");\nconst verify_1 = require(\"./verify\");\nconst schema_1 = require(\"./schema\");\nconst debug = createDebug('lisk:chain');\nclass Chain {\n    constructor({ db, genesisBlock, accountSchemas, blockTime, networkIdentifier, maxPayloadLength, rewardDistance, rewardOffset, rewardMilestones, minFeePerByte, baseFees, minBlockHeaderCache = constants_1.DEFAULT_MIN_BLOCK_HEADER_CACHE, maxBlockHeaderCache = constants_1.DEFAULT_MAX_BLOCK_HEADER_CACHE, }) {\n        this._numberOfValidators = -1;\n        this.events = new events_1.EventEmitter();\n        const { default: defaultAccount, ...schema } = account_1.getAccountSchemaWithDefault(accountSchemas);\n        this._defaultAccount = defaultAccount;\n        this._accountSchema = schema;\n        this._blockAssetSchema = schema_1.getRegisteredBlockAssetSchema(this._accountSchema);\n        lisk_codec_1.codec.addSchema(schema_1.blockSchema);\n        lisk_codec_1.codec.addSchema(schema_1.blockHeaderSchema);\n        lisk_codec_1.codec.addSchema(schema_1.signingBlockHeaderSchema);\n        for (const assetSchema of Object.values(this._blockAssetSchema)) {\n            lisk_codec_1.codec.addSchema(assetSchema);\n        }\n        lisk_codec_1.codec.addSchema(this._accountSchema);\n        lisk_codec_1.codec.addSchema(schema_1.stateDiffSchema);\n        this.dataAccess = new data_access_1.DataAccess({\n            db,\n            registeredBlockHeaders: this._blockAssetSchema,\n            accountSchema: this._accountSchema,\n            minBlockHeaderCache,\n            maxBlockHeaderCache,\n        });\n        this._lastBlock = genesisBlock;\n        this._networkIdentifier = networkIdentifier;\n        this.slots = new slots_1.Slots({\n            genesisBlockTimestamp: genesisBlock.header.timestamp,\n            interval: blockTime,\n        });\n        this._genesisHeight = genesisBlock.header.height;\n        this._blockRewardArgs = {\n            distance: rewardDistance,\n            rewardOffset,\n            milestones: rewardMilestones,\n        };\n        this.constants = {\n            blockTime,\n            maxPayloadLength,\n            rewardDistance,\n            rewardOffset,\n            rewardMilestones,\n            networkIdentifier,\n            minFeePerByte,\n            baseFees,\n        };\n    }\n    get genesisHeight() {\n        return this._genesisHeight;\n    }\n    get lastBlock() {\n        return this._lastBlock;\n    }\n    get numberOfValidators() {\n        return this._numberOfValidators;\n    }\n    get accountSchema() {\n        return this._accountSchema;\n    }\n    get blockAssetSchema() {\n        return this._blockAssetSchema;\n    }\n    async init(genesisBlock) {\n        let storageLastBlock;\n        try {\n            storageLastBlock = await this.dataAccess.getLastBlock();\n        }\n        catch (error) {\n            throw new Error('Failed to load last block');\n        }\n        if (storageLastBlock.header.height !== genesisBlock.header.height) {\n            await this._cacheBlockHeaders(storageLastBlock);\n        }\n        const genesisInfo = await this._getGenesisInfo();\n        if (!genesisInfo) {\n            await this.dataAccess.setConsensusState(constants_1.CONSENSUS_STATE_GENESIS_INFO, lisk_codec_1.codec.encode(schema_1.genesisInfoSchema, {\n                height: genesisBlock.header.height,\n                initRounds: genesisBlock.header.asset.initRounds,\n            }));\n        }\n        const validators = await this.getValidators();\n        this._numberOfValidators = validators.length;\n        this._lastBlock = storageLastBlock;\n    }\n    calculateDefaultReward(height) {\n        return block_reward_1.calculateDefaultReward(height, this._blockRewardArgs);\n    }\n    calculateExpectedReward(blockHeader, stateStore) {\n        const defaultReward = this.calculateDefaultReward(blockHeader.height);\n        const isValid = this.isValidSeedReveal(blockHeader, stateStore);\n        return isValid ? defaultReward : BigInt(0);\n    }\n    resetBlockHeaderCache() {\n        this.dataAccess.resetBlockHeaderCache();\n    }\n    async newStateStore(skipLastHeights = 0) {\n        var _a, _b, _c;\n        const genesisInfo = await this._getGenesisInfo();\n        const fromHeight = Math.max((_a = genesisInfo === null || genesisInfo === void 0 ? void 0 : genesisInfo.height) !== null && _a !== void 0 ? _a : 0, this._lastBlock.header.height - this.numberOfValidators * 3 - skipLastHeights);\n        const toHeight = Math.max(this._lastBlock.header.height - skipLastHeights, 1);\n        const lastBlockHeaders = await this.dataAccess.getBlockHeadersByHeightBetween(fromHeight, toHeight);\n        const lastBlockReward = this.calculateDefaultReward((_c = (_b = lastBlockHeaders[0]) === null || _b === void 0 ? void 0 : _b.height) !== null && _c !== void 0 ? _c : 1);\n        return new state_store_1.StateStore(this.dataAccess, {\n            networkIdentifier: this._networkIdentifier,\n            lastBlockHeaders,\n            lastBlockReward,\n            defaultAccount: this._defaultAccount,\n        });\n    }\n    async genesisBlockExist(genesisBlock) {\n        const matchingGenesisBlock = await this.dataAccess.blockHeaderExists(genesisBlock.header.id);\n        let lastBlockHeader;\n        try {\n            lastBlockHeader = await this.dataAccess.getLastBlockHeader();\n        }\n        catch (error) {\n            if (!(error instanceof lisk_db_1.NotFoundError)) {\n                throw error;\n            }\n        }\n        if (lastBlockHeader && !matchingGenesisBlock) {\n            throw new Error('Genesis block does not match');\n        }\n        if (!lastBlockHeader && !matchingGenesisBlock) {\n            return false;\n        }\n        return true;\n    }\n    isValidSeedReveal(blockHeader, stateStore) {\n        return verify_1.isValidSeedReveal(blockHeader, stateStore, this.numberOfValidators);\n    }\n    validateGenesisBlockHeader(block) {\n        validate_1.validateGenesisBlockHeader(block, this._accountSchema);\n    }\n    async applyGenesisBlock(block, stateStore) {\n        for (const account of block.header.asset.accounts) {\n            await stateStore.account.set(account.address, account);\n        }\n        const initialValidators = block.header.asset.initDelegates.map(address => ({\n            address,\n            minActiveHeight: block.header.height + 1,\n            isConsensusParticipant: false,\n        }));\n        await stateStore.consensus.set(constants_1.CONSENSUS_STATE_VALIDATORS_KEY, lisk_codec_1.codec.encode(schema_1.validatorsSchema, { validators: initialValidators }));\n        await stateStore.consensus.set(constants_1.CONSENSUS_STATE_GENESIS_INFO, lisk_codec_1.codec.encode(schema_1.genesisInfoSchema, {\n            height: block.header.height,\n            initRounds: block.header.asset.initRounds,\n        }));\n        this._numberOfValidators = block.header.asset.initDelegates.length;\n    }\n    validateTransaction(transaction) {\n        transaction.validate({\n            minFeePerByte: this.constants.minFeePerByte,\n            baseFees: this.constants.baseFees,\n        });\n    }\n    validateBlockHeader(block) {\n        const headerWithoutAsset = {\n            ...block.header,\n            asset: Buffer.alloc(0),\n        };\n        const errors = lisk_validator_1.validator.validate(schema_1.blockHeaderSchema, headerWithoutAsset);\n        if (errors.length) {\n            throw new lisk_validator_1.LiskValidationError(errors);\n        }\n        const assetSchema = this.dataAccess.getBlockHeaderAssetSchema(block.header.version);\n        const assetErrors = lisk_validator_1.validator.validate(assetSchema, block.header.asset);\n        if (assetErrors.length) {\n            throw new lisk_validator_1.LiskValidationError(assetErrors);\n        }\n        const encodedBlockHeaderWithoutSignature = this.dataAccess.encodeBlockHeader(block.header, true);\n        validate_1.validateSignature(block.header.generatorPublicKey, encodedBlockHeaderWithoutSignature, block.header.signature, this._networkIdentifier);\n        validate_1.validateReward(block, this.calculateDefaultReward(block.header.height));\n        const encodedPayload = Buffer.concat(block.payload.map(tx => this.dataAccess.encodeTransaction(tx)));\n        validate_1.validateBlockProperties(block, encodedPayload, this.constants.maxPayloadLength);\n    }\n    async verifyBlockHeader(block, stateStore) {\n        verify_1.verifyPreviousBlockId(block, this._lastBlock);\n        validate_1.validateBlockSlot(block, this._lastBlock, this.slots);\n        verify_1.verifyReward(block.header, stateStore, this.numberOfValidators);\n        await verify_1.verifyBlockGenerator(block.header, this.slots, stateStore);\n    }\n    async saveBlock(block, stateStore, finalizedHeight, { removeFromTempTable } = {\n        removeFromTempTable: false,\n    }) {\n        await this.dataAccess.saveBlock(block, stateStore, finalizedHeight, removeFromTempTable);\n        this.dataAccess.addBlockHeader(block.header);\n        this._lastBlock = block;\n        this.events.emit(constants_1.EVENT_NEW_BLOCK, {\n            block,\n            accounts: stateStore.account.getUpdated(),\n        });\n    }\n    async removeBlock(block, stateStore, { saveTempBlock } = { saveTempBlock: false }) {\n        if (block.header.version === constants_1.GENESIS_BLOCK_VERSION) {\n            throw new Error('Cannot delete genesis block');\n        }\n        let secondLastBlock;\n        try {\n            secondLastBlock = await this.dataAccess.getBlockByID(block.header.previousBlockID);\n        }\n        catch (error) {\n            throw new Error('PreviousBlock is null');\n        }\n        const updatedAccounts = await this.dataAccess.deleteBlock(block, stateStore, saveTempBlock);\n        await this.dataAccess.removeBlockHeader(block.header.id);\n        this._lastBlock = secondLastBlock;\n        this.events.emit(constants_1.EVENT_DELETE_BLOCK, {\n            block,\n            accounts: updatedAccounts,\n        });\n    }\n    async getValidator(timestamp) {\n        const validators = await this.getValidators();\n        const currentSlot = this.slots.getSlotNumber(timestamp);\n        return validators[currentSlot % validators.length];\n    }\n    async getValidators() {\n        const validatorsBuffer = await this.dataAccess.getConsensusState(constants_1.CONSENSUS_STATE_VALIDATORS_KEY);\n        if (!validatorsBuffer) {\n            return [];\n        }\n        const { validators } = lisk_codec_1.codec.decode(schema_1.validatorsSchema, validatorsBuffer);\n        return validators;\n    }\n    async setValidators(validators, stateStore, blockHeader) {\n        const lastBootstrapHeight = await this._getLastBootstrapHeight();\n        if (lastBootstrapHeight > blockHeader.height) {\n            debug(`Skipping updating validator since current height ${blockHeader.height} is lower than last bootstrap height ${lastBootstrapHeight}`);\n            return;\n        }\n        const validatorsBuffer = await stateStore.consensus.get(constants_1.CONSENSUS_STATE_VALIDATORS_KEY);\n        if (!validatorsBuffer) {\n            throw new Error('Previous validator set must exist');\n        }\n        const { validators: previousValidators } = lisk_codec_1.codec.decode(schema_1.validatorsSchema, validatorsBuffer);\n        const nextValidatorSet = [];\n        for (const nextValidator of validators) {\n            const previousInfo = previousValidators.find(pv => pv.address.equals(nextValidator.address));\n            nextValidatorSet.push({\n                ...nextValidator,\n                minActiveHeight: previousInfo !== undefined ? previousInfo.minActiveHeight : blockHeader.height + 1,\n            });\n        }\n        const encodedValidators = lisk_codec_1.codec.encode(schema_1.validatorsSchema, { validators: nextValidatorSet });\n        await stateStore.consensus.set(constants_1.CONSENSUS_STATE_VALIDATORS_KEY, encodedValidators);\n        this.events.emit(constants_1.EVENT_VALIDATORS_CHANGED, { validators: nextValidatorSet });\n    }\n    async _cacheBlockHeaders(storageLastBlock) {\n        const fromHeight = Math.max(storageLastBlock.header.height - constants_1.DEFAULT_MAX_BLOCK_HEADER_CACHE, 0);\n        const toHeight = storageLastBlock.header.height;\n        debug({ h: storageLastBlock.header.height, fromHeight, toHeight }, 'Cache block headers during chain init');\n        const blockHeaders = await this.dataAccess.getBlockHeadersByHeightBetween(fromHeight, toHeight);\n        const sortedBlockHeaders = [...blockHeaders].sort((a, b) => a.height - b.height);\n        for (const blockHeader of sortedBlockHeaders) {\n            debug({ height: blockHeader.height }, 'Add block header to cache');\n            this.dataAccess.addBlockHeader(blockHeader);\n        }\n    }\n    async _getLastBootstrapHeight() {\n        const genesisInfo = await this._getGenesisInfo();\n        if (!genesisInfo) {\n            throw new Error('genesis info not stored');\n        }\n        return this._numberOfValidators * genesisInfo.initRounds + genesisInfo.height;\n    }\n    async _getGenesisInfo() {\n        const genesisInfoBytes = await this.dataAccess.getConsensusState(constants_1.CONSENSUS_STATE_GENESIS_INFO);\n        if (!genesisInfoBytes) {\n            return undefined;\n        }\n        return lisk_codec_1.codec.decode(schema_1.genesisInfoSchema, genesisInfoBytes);\n    }\n}\nexports.Chain = Chain;\n//# sourceMappingURL=chain.js.map"]},"metadata":{},"sourceType":"script"}