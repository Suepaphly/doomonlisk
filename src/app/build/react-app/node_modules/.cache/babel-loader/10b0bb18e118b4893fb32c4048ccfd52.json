{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SequenceModule = void 0;\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar base_module_1 = require(\"../base_module\");\n\nvar errors_1 = require(\"../../errors\");\n\nvar errors_2 = require(\"./errors\");\n\nvar SequenceModule = /*#__PURE__*/function (_base_module_1$BaseMo) {\n  _inherits(SequenceModule, _base_module_1$BaseMo);\n\n  var _super = _createSuper(SequenceModule);\n\n  function SequenceModule() {\n    var _this;\n\n    _classCallCheck(this, SequenceModule);\n\n    _this = _super.apply(this, arguments);\n    _this.name = 'sequence';\n    _this.id = 3;\n    _this.accountSchema = {\n      type: 'object',\n      properties: {\n        nonce: {\n          fieldNumber: 1,\n          dataType: 'uint64'\n        }\n      },\n      default: {\n        nonce: BigInt(0)\n      }\n    };\n    return _this;\n  }\n\n  _createClass(SequenceModule, [{\n    key: \"beforeTransactionApply\",\n    value: function () {\n      var _beforeTransactionApply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n        var transaction, stateStore, senderAddress, senderAccount;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                transaction = _ref.transaction, stateStore = _ref.stateStore;\n                senderAddress = lisk_cryptography_1.getAddressFromPublicKey(transaction.senderPublicKey);\n                _context.next = 4;\n                return stateStore.account.get(senderAddress);\n\n              case 4:\n                senderAccount = _context.sent;\n\n                if (!(transaction.nonce < senderAccount.sequence.nonce)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new errors_2.InvalidNonceError(\"Transaction with id:\".concat(transaction.id.toString('hex'), \" nonce is lower than account nonce\"), transaction.nonce, senderAccount.sequence.nonce);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function beforeTransactionApply(_x) {\n        return _beforeTransactionApply.apply(this, arguments);\n      }\n\n      return beforeTransactionApply;\n    }()\n  }, {\n    key: \"afterTransactionApply\",\n    value: function () {\n      var _afterTransactionApply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n        var transaction, stateStore, senderAddress, senderAccount;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                transaction = _ref2.transaction, stateStore = _ref2.stateStore;\n                senderAddress = lisk_cryptography_1.getAddressFromPublicKey(transaction.senderPublicKey);\n                _context2.next = 4;\n                return stateStore.account.get(senderAddress);\n\n              case 4:\n                senderAccount = _context2.sent;\n\n                if (!(transaction.nonce !== senderAccount.sequence.nonce)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                throw new errors_1.NonceOutOfBoundsError(\"Transaction with id:\".concat(transaction.id.toString('hex'), \" nonce is not equal to account nonce\"), transaction.nonce, senderAccount.sequence.nonce);\n\n              case 7:\n                senderAccount.sequence.nonce += BigInt(1);\n                _context2.next = 10;\n                return stateStore.account.set(senderAddress, senderAccount);\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function afterTransactionApply(_x2) {\n        return _afterTransactionApply.apply(this, arguments);\n      }\n\n      return afterTransactionApply;\n    }()\n  }]);\n\n  return SequenceModule;\n}(base_module_1.BaseModule);\n\nexports.SequenceModule = SequenceModule;","map":{"version":3,"sources":["../../../src/modules/sequence/sequence_module.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAcA,IAAA,mBAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AAEA,IAAA,aAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;IAQa,c;;;;;AAAb,4BAAA;AAAA;;AAAA;;;AACQ,UAAA,IAAA,GAAO,UAAP;AACA,UAAA,EAAA,GAAK,CAAL;AACA,UAAA,aAAA,GAAgB;AACtB,MAAA,IAAI,EAAE,QADgB;AAEtB,MAAA,UAAU,EAAE;AACX,QAAA,KAAK,EAAE;AACN,UAAA,WAAW,EAAE,CADP;AAEN,UAAA,QAAQ,EAAE;AAFJ;AADI,OAFU;AAQtB,MAAA,OAAO,EAAE;AACR,QAAA,KAAK,EAAE,MAAM,CAAC,CAAD;AADL;AARa,KAAhB;AAHR;AAuDC;;;;;6FAvCO;AAAA;AAAA;AAAA;AAAA;AAAA;AACN,gBAAA,WADM,QACN,WADM,EAEN,UAFM,QAEN,UAFM;AAIA,gBAAA,aAJA,GAIgB,mBAAA,CAAA,uBAAA,CAAwB,WAAW,CAAC,eAApC,CAJhB;AAAA;AAAA,uBAKsB,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAiD,aAAjD,CALtB;;AAAA;AAKA,gBAAA,aALA;;AAAA,sBAQF,WAAW,CAAC,KAAZ,GAAoB,aAAa,CAAC,QAAd,CAAuB,KARzC;AAAA;AAAA;AAAA;;AAAA,sBASC,IAAI,QAAA,CAAA,iBAAJ,+BACkB,WAAW,CAAC,EAAZ,CAAe,QAAf,CAAwB,KAAxB,CADlB,yCAEL,WAAW,CAAC,KAFP,EAGL,aAAa,CAAC,QAAd,CAAuB,KAHlB,CATD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;4FAiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACN,gBAAA,WADM,SACN,WADM,EAEN,UAFM,SAEN,UAFM;AAIA,gBAAA,aAJA,GAIgB,mBAAA,CAAA,uBAAA,CAAwB,WAAW,CAAC,eAApC,CAJhB;AAAA;AAAA,uBAKsB,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAiD,aAAjD,CALtB;;AAAA;AAKA,gBAAA,aALA;;AAAA,sBAQF,WAAW,CAAC,KAAZ,KAAsB,aAAa,CAAC,QAAd,CAAuB,KAR3C;AAAA;AAAA;AAAA;;AAAA,sBASC,IAAI,QAAA,CAAA,qBAAJ,+BACkB,WAAW,CAAC,EAAZ,CAAe,QAAf,CAAwB,KAAxB,CADlB,2CAEL,WAAW,CAAC,KAFP,EAGL,aAAa,CAAC,QAAd,CAAuB,KAHlB,CATD;;AAAA;AAiBN,gBAAA,aAAa,CAAC,QAAd,CAAuB,KAAvB,IAAgC,MAAM,CAAC,CAAD,CAAtC;AAjBM;AAAA,uBAoBA,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAuB,aAAvB,EAAsC,aAAtC,CApBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;EAjC4B,aAAA,CAAA,U;;AAApC,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SequenceModule = void 0;\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst base_module_1 = require(\"../base_module\");\nconst errors_1 = require(\"../../errors\");\nconst errors_2 = require(\"./errors\");\nclass SequenceModule extends base_module_1.BaseModule {\n    constructor() {\n        super(...arguments);\n        this.name = 'sequence';\n        this.id = 3;\n        this.accountSchema = {\n            type: 'object',\n            properties: {\n                nonce: {\n                    fieldNumber: 1,\n                    dataType: 'uint64',\n                },\n            },\n            default: {\n                nonce: BigInt(0),\n            },\n        };\n    }\n    async beforeTransactionApply({ transaction, stateStore, }) {\n        const senderAddress = lisk_cryptography_1.getAddressFromPublicKey(transaction.senderPublicKey);\n        const senderAccount = await stateStore.account.get(senderAddress);\n        if (transaction.nonce < senderAccount.sequence.nonce) {\n            throw new errors_2.InvalidNonceError(`Transaction with id:${transaction.id.toString('hex')} nonce is lower than account nonce`, transaction.nonce, senderAccount.sequence.nonce);\n        }\n    }\n    async afterTransactionApply({ transaction, stateStore, }) {\n        const senderAddress = lisk_cryptography_1.getAddressFromPublicKey(transaction.senderPublicKey);\n        const senderAccount = await stateStore.account.get(senderAddress);\n        if (transaction.nonce !== senderAccount.sequence.nonce) {\n            throw new errors_1.NonceOutOfBoundsError(`Transaction with id:${transaction.id.toString('hex')} nonce is not equal to account nonce`, transaction.nonce, senderAccount.sequence.nonce);\n        }\n        senderAccount.sequence.nonce += BigInt(1);\n        await stateStore.account.set(senderAddress, senderAccount);\n    }\n}\nexports.SequenceModule = SequenceModule;\n//# sourceMappingURL=sequence_module.js.map"]},"metadata":{},"sourceType":"script"}