{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Synchronizer = void 0;\n\nvar assert = require(\"assert\");\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nvar schemas_1 = require(\"../transport/schemas\");\n\nvar utils = require(\"./utils\");\n\nvar Synchronizer = /*#__PURE__*/function () {\n  function Synchronizer(_ref) {\n    var channel = _ref.channel,\n        logger = _ref.logger,\n        chainModule = _ref.chainModule,\n        bftModule = _ref.bftModule,\n        processorModule = _ref.processorModule,\n        transactionPoolModule = _ref.transactionPoolModule,\n        _ref$mechanisms = _ref.mechanisms,\n        mechanisms = _ref$mechanisms === void 0 ? [] : _ref$mechanisms,\n        networkModule = _ref.networkModule;\n\n    _classCallCheck(this, Synchronizer);\n\n    assert(Array.isArray(mechanisms), 'mechanisms should be an array of mechanisms');\n    this.mechanisms = mechanisms;\n    this.channel = channel;\n    this.logger = logger;\n    this.chainModule = chainModule;\n    this.bftModule = bftModule;\n    this.processorModule = processorModule;\n    this.transactionPoolModule = transactionPoolModule;\n    this._networkModule = networkModule;\n    this.loadTransactionsRetries = 5;\n\n    this._checkMechanismsInterfaces();\n\n    this._mutex = new lisk_utils_1.jobHandlers.Mutex();\n  }\n\n  _createClass(Synchronizer, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var isEmpty;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.chainModule.dataAccess.isTempBlockEmpty();\n\n              case 2:\n                isEmpty = _context.sent;\n\n                if (isEmpty) {\n                  _context.next = 12;\n                  break;\n                }\n\n                _context.prev = 4;\n                _context.next = 7;\n                return utils.restoreBlocksUponStartup(this.logger, this.chainModule, this.bftModule, this.processorModule);\n\n              case 7:\n                _context.next = 12;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](4);\n                this.logger.error({\n                  err: _context.t0\n                }, 'Failed to restore blocks from temp table upon startup');\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 9]]);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"run\",\n    value: function () {\n      var _run = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(receivedBlock, peerId) {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this._mutex.isLocked()) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                this.logger.debug('Synchronizer is already running.');\n                return _context3.abrupt(\"return\");\n\n              case 3:\n                _context3.next = 5;\n                return this._mutex.runExclusive( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n                  var validMechanism;\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          assert(receivedBlock, 'A block must be provided to the Synchronizer in order to run');\n\n                          _this.logger.info({\n                            blockId: receivedBlock.header.id,\n                            height: receivedBlock.header.height\n                          }, 'Starting synchronizer');\n\n                          _this.processorModule.validate(receivedBlock);\n\n                          _context2.next = 5;\n                          return _this._determineSyncMechanism(receivedBlock, peerId);\n\n                        case 5:\n                          validMechanism = _context2.sent;\n\n                          if (validMechanism) {\n                            _context2.next = 9;\n                            break;\n                          }\n\n                          _this.logger.info({\n                            blockId: receivedBlock.header.id\n                          }, 'Syncing mechanism could not be determined for the given block');\n\n                          return _context2.abrupt(\"return\");\n\n                        case 9:\n                          _this.logger.info(\"Triggering: \".concat(validMechanism.constructor.name));\n\n                          _context2.next = 12;\n                          return validMechanism.run(receivedBlock, peerId);\n\n                        case 12:\n                          _this.logger.info({\n                            lastBlockHeight: _this.chainModule.lastBlock.header.height,\n                            lastBlockID: _this.chainModule.lastBlock.header.id,\n                            mechanism: validMechanism.constructor.name\n                          }, 'Synchronization finished.');\n\n                        case 13:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2);\n                })));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function run(_x, _x2) {\n        return _run.apply(this, arguments);\n      }\n\n      return run;\n    }()\n  }, {\n    key: \"isActive\",\n    get: function get() {\n      return this._mutex.isLocked();\n    }\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _iterator, _step, mechanism;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _iterator = _createForOfIteratorHelper(this.mechanisms);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    mechanism = _step.value;\n                    mechanism.stop();\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context4.next = 4;\n                return this._mutex.acquire();\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n  }, {\n    key: \"loadUnconfirmedTransactions\",\n    value: function () {\n      var _loadUnconfirmedTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var retry;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                retry = 0;\n\n              case 1:\n                if (!(retry < this.loadTransactionsRetries)) {\n                  _context5.next = 14;\n                  break;\n                }\n\n                _context5.prev = 2;\n                _context5.next = 5;\n                return this._getUnconfirmedTransactionsFromNetwork();\n\n              case 5:\n                return _context5.abrupt(\"break\", 14);\n\n              case 8:\n                _context5.prev = 8;\n                _context5.t0 = _context5[\"catch\"](2);\n\n                if (_context5.t0 && retry === this.loadTransactionsRetries - 1) {\n                  this.logger.error({\n                    err: _context5.t0\n                  }, \"Failed to get transactions from network after \".concat(this.loadTransactionsRetries, \" retries\"));\n                }\n\n              case 11:\n                retry += 1;\n                _context5.next = 1;\n                break;\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[2, 8]]);\n      }));\n\n      function loadUnconfirmedTransactions() {\n        return _loadUnconfirmedTransactions.apply(this, arguments);\n      }\n\n      return loadUnconfirmedTransactions;\n    }()\n  }, {\n    key: \"_determineSyncMechanism\",\n    value: function () {\n      var _determineSyncMechanism2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(receivedBlock, peerId) {\n        var _iterator2, _step2, mechanism;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _iterator2 = _createForOfIteratorHelper(this.mechanisms);\n                _context6.prev = 1;\n\n                _iterator2.s();\n\n              case 3:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context6.next = 11;\n                  break;\n                }\n\n                mechanism = _step2.value;\n                _context6.next = 7;\n                return mechanism.isValidFor(receivedBlock, peerId);\n\n              case 7:\n                if (!_context6.sent) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", mechanism);\n\n              case 9:\n                _context6.next = 3;\n                break;\n\n              case 11:\n                _context6.next = 16;\n                break;\n\n              case 13:\n                _context6.prev = 13;\n                _context6.t0 = _context6[\"catch\"](1);\n\n                _iterator2.e(_context6.t0);\n\n              case 16:\n                _context6.prev = 16;\n\n                _iterator2.f();\n\n                return _context6.finish(16);\n\n              case 19:\n                return _context6.abrupt(\"return\", undefined);\n\n              case 20:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[1, 13, 16, 19]]);\n      }));\n\n      function _determineSyncMechanism(_x3, _x4) {\n        return _determineSyncMechanism2.apply(this, arguments);\n      }\n\n      return _determineSyncMechanism;\n    }()\n  }, {\n    key: \"_getUnconfirmedTransactionsFromNetwork\",\n    value: function () {\n      var _getUnconfirmedTransactionsFromNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _this2 = this;\n\n        var _yield$this$_networkM, data, encodedData, validatorErrors, transactions, _iterator3, _step3, transaction, transactionCount, i, _yield$this$transacti, error;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this.logger.info('Loading transactions from the network');\n                _context7.next = 3;\n                return this._networkModule.request({\n                  procedure: 'getTransactions'\n                });\n\n              case 3:\n                _yield$this$_networkM = _context7.sent;\n                data = _yield$this$_networkM.data;\n                encodedData = lisk_codec_1.codec.decode(schemas_1.transactionsSchema, data);\n                validatorErrors = lisk_validator_1.validator.validate(schemas_1.transactionsSchema, encodedData);\n\n                if (!validatorErrors.length) {\n                  _context7.next = 9;\n                  break;\n                }\n\n                throw new lisk_validator_1.LiskValidationError(validatorErrors);\n\n              case 9:\n                transactions = encodedData.transactions.map(function (transaction) {\n                  return _this2.chainModule.dataAccess.decodeTransaction(transaction);\n                });\n                _iterator3 = _createForOfIteratorHelper(transactions);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    transaction = _step3.value;\n                    this.processorModule.validateTransaction(transaction);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                transactionCount = transactions.length;\n                i = 0;\n\n              case 14:\n                if (!(i < transactionCount)) {\n                  _context7.next = 25;\n                  break;\n                }\n\n                _context7.next = 17;\n                return this.transactionPoolModule.add(transactions[i]);\n\n              case 17:\n                _yield$this$transacti = _context7.sent;\n                error = _yield$this$transacti.error;\n\n                if (!error) {\n                  _context7.next = 22;\n                  break;\n                }\n\n                this.logger.error({\n                  err: error\n                }, 'Failed to add transaction to pool.');\n                throw error;\n\n              case 22:\n                i += 1;\n                _context7.next = 14;\n                break;\n\n              case 25:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _getUnconfirmedTransactionsFromNetwork() {\n        return _getUnconfirmedTransactionsFromNetwork2.apply(this, arguments);\n      }\n\n      return _getUnconfirmedTransactionsFromNetwork;\n    }()\n  }, {\n    key: \"_checkMechanismsInterfaces\",\n    value: function _checkMechanismsInterfaces() {\n      var _iterator4 = _createForOfIteratorHelper(this.mechanisms),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var mechanism = _step4.value;\n          assert(typeof mechanism.isValidFor === 'function', \"Mechanism \".concat(mechanism.constructor.name, \" should implement \\\"isValidFor\\\" method\"));\n          assert(typeof mechanism.run === 'function', \"Mechanism \".concat(mechanism.constructor.name, \" should implement \\\"run\\\" method\"));\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }]);\n\n  return Synchronizer;\n}();\n\nexports.Synchronizer = Synchronizer;","map":{"version":3,"sources":["../../../src/node/synchronizer/synchronizer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Synchronizer = void 0;\nconst assert = require(\"assert\");\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst schemas_1 = require(\"../transport/schemas\");\nconst utils = require(\"./utils\");\nclass Synchronizer {\n    constructor({ channel, logger, chainModule, bftModule, processorModule, transactionPoolModule, mechanisms = [], networkModule, }) {\n        assert(Array.isArray(mechanisms), 'mechanisms should be an array of mechanisms');\n        this.mechanisms = mechanisms;\n        this.channel = channel;\n        this.logger = logger;\n        this.chainModule = chainModule;\n        this.bftModule = bftModule;\n        this.processorModule = processorModule;\n        this.transactionPoolModule = transactionPoolModule;\n        this._networkModule = networkModule;\n        this.loadTransactionsRetries = 5;\n        this._checkMechanismsInterfaces();\n        this._mutex = new lisk_utils_1.jobHandlers.Mutex();\n    }\n    async init() {\n        const isEmpty = await this.chainModule.dataAccess.isTempBlockEmpty();\n        if (!isEmpty) {\n            try {\n                await utils.restoreBlocksUponStartup(this.logger, this.chainModule, this.bftModule, this.processorModule);\n            }\n            catch (err) {\n                this.logger.error({ err: err }, 'Failed to restore blocks from temp table upon startup');\n            }\n        }\n    }\n    async run(receivedBlock, peerId) {\n        if (this._mutex.isLocked()) {\n            this.logger.debug('Synchronizer is already running.');\n            return;\n        }\n        await this._mutex.runExclusive(async () => {\n            assert(receivedBlock, 'A block must be provided to the Synchronizer in order to run');\n            this.logger.info({\n                blockId: receivedBlock.header.id,\n                height: receivedBlock.header.height,\n            }, 'Starting synchronizer');\n            this.processorModule.validate(receivedBlock);\n            const validMechanism = await this._determineSyncMechanism(receivedBlock, peerId);\n            if (!validMechanism) {\n                this.logger.info({ blockId: receivedBlock.header.id }, 'Syncing mechanism could not be determined for the given block');\n                return;\n            }\n            this.logger.info(`Triggering: ${validMechanism.constructor.name}`);\n            await validMechanism.run(receivedBlock, peerId);\n            this.logger.info({\n                lastBlockHeight: this.chainModule.lastBlock.header.height,\n                lastBlockID: this.chainModule.lastBlock.header.id,\n                mechanism: validMechanism.constructor.name,\n            }, 'Synchronization finished.');\n        });\n    }\n    get isActive() {\n        return this._mutex.isLocked();\n    }\n    async stop() {\n        for (const mechanism of this.mechanisms) {\n            mechanism.stop();\n        }\n        await this._mutex.acquire();\n    }\n    async loadUnconfirmedTransactions() {\n        for (let retry = 0; retry < this.loadTransactionsRetries; retry += 1) {\n            try {\n                await this._getUnconfirmedTransactionsFromNetwork();\n                break;\n            }\n            catch (err) {\n                if (err && retry === this.loadTransactionsRetries - 1) {\n                    this.logger.error({ err: err }, `Failed to get transactions from network after ${this.loadTransactionsRetries} retries`);\n                }\n            }\n        }\n    }\n    async _determineSyncMechanism(receivedBlock, peerId) {\n        for (const mechanism of this.mechanisms) {\n            if (await mechanism.isValidFor(receivedBlock, peerId)) {\n                return mechanism;\n            }\n        }\n        return undefined;\n    }\n    async _getUnconfirmedTransactionsFromNetwork() {\n        this.logger.info('Loading transactions from the network');\n        const { data } = (await this._networkModule.request({\n            procedure: 'getTransactions',\n        }));\n        const encodedData = lisk_codec_1.codec.decode(schemas_1.transactionsSchema, data);\n        const validatorErrors = lisk_validator_1.validator.validate(schemas_1.transactionsSchema, encodedData);\n        if (validatorErrors.length) {\n            throw new lisk_validator_1.LiskValidationError(validatorErrors);\n        }\n        const transactions = encodedData.transactions.map(transaction => this.chainModule.dataAccess.decodeTransaction(transaction));\n        for (const transaction of transactions) {\n            this.processorModule.validateTransaction(transaction);\n        }\n        const transactionCount = transactions.length;\n        for (let i = 0; i < transactionCount; i += 1) {\n            const { error } = await this.transactionPoolModule.add(transactions[i]);\n            if (error) {\n                this.logger.error({ err: error }, 'Failed to add transaction to pool.');\n                throw error;\n            }\n        }\n    }\n    _checkMechanismsInterfaces() {\n        for (const mechanism of this.mechanisms) {\n            assert(typeof mechanism.isValidFor === 'function', `Mechanism ${mechanism.constructor.name} should implement \"isValidFor\" method`);\n            assert(typeof mechanism.run === 'function', `Mechanism ${mechanism.constructor.name} should implement \"run\" method`);\n        }\n    }\n}\nexports.Synchronizer = Synchronizer;\n//# sourceMappingURL=synchronizer.js.map"]},"metadata":{},"sourceType":"script"}