{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FinalityManager = exports.BFTVotingLedgerSchema = exports.CONSENSUS_STATE_VALIDATOR_LEDGER_KEY = exports.EVENT_BFT_FINALIZED_HEIGHT_CHANGED = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar lisk_chain_1 = require(\"@liskhq/lisk-chain\");\n\nvar assert = require(\"assert\");\n\nvar createDebug = require(\"debug\");\n\nvar events_1 = require(\"events\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar constant_1 = require(\"./constant\");\n\nvar types_1 = require(\"./types\");\n\nvar header_contradicting_1 = require(\"./header_contradicting\");\n\nvar debug = createDebug('lisk:bft:consensus_manager');\nexports.EVENT_BFT_FINALIZED_HEIGHT_CHANGED = 'EVENT_BFT_FINALIZED_HEIGHT_CHANGED';\nexports.CONSENSUS_STATE_VALIDATOR_LEDGER_KEY = 'bft:votingLedger';\nexports.BFTVotingLedgerSchema = {\n  type: 'object',\n  $id: '/bft/validators',\n  title: 'Lisk BFT Validator ledger',\n  required: ['validators', 'ledger'],\n  properties: {\n    validators: {\n      type: 'array',\n      fieldNumber: 1,\n      items: {\n        type: 'object',\n        required: ['address', 'maxPreVoteHeight', 'maxPreCommitHeight'],\n        properties: {\n          address: {\n            dataType: 'bytes',\n            fieldNumber: 1\n          },\n          maxPreVoteHeight: {\n            dataType: 'uint32',\n            fieldNumber: 2\n          },\n          maxPreCommitHeight: {\n            dataType: 'uint32',\n            fieldNumber: 3\n          }\n        }\n      }\n    },\n    ledger: {\n      type: 'array',\n      fieldNumber: 2,\n      items: {\n        type: 'object',\n        required: ['height', 'prevotes', 'precommits'],\n        properties: {\n          height: {\n            dataType: 'uint32',\n            fieldNumber: 1\n          },\n          prevotes: {\n            dataType: 'uint32',\n            fieldNumber: 2\n          },\n          precommits: {\n            dataType: 'uint32',\n            fieldNumber: 3\n          }\n        }\n      }\n    }\n  }\n};\nlisk_codec_1.codec.addSchema(exports.BFTVotingLedgerSchema);\n\nvar FinalityManager = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(FinalityManager, _events_1$EventEmitte);\n\n  var _super = _createSuper(FinalityManager);\n\n  function FinalityManager(_ref) {\n    var _this;\n\n    var chain = _ref.chain,\n        genesisHeight = _ref.genesisHeight,\n        finalizedHeight = _ref.finalizedHeight,\n        threshold = _ref.threshold;\n\n    _classCallCheck(this, FinalityManager);\n\n    _this = _super.call(this);\n    assert(threshold > 0, 'Must provide a positive threshold');\n    _this._chain = chain;\n    _this._genesisHeight = genesisHeight;\n    _this.preVoteThreshold = threshold;\n    _this.preCommitThreshold = threshold;\n\n    if (_this._chain.numberOfValidators <= 0) {\n      throw new Error('Invalid number of validators for BFT property');\n    }\n\n    _this.processingThreshold = _this._chain.numberOfValidators * constant_1.BFT_ROUND_THRESHOLD - 1;\n    _this.maxHeaders = _this._chain.numberOfValidators * 5;\n    _this.finalizedHeight = finalizedHeight;\n    return _this;\n  }\n\n  _createClass(FinalityManager, [{\n    key: \"addBlockHeader\",\n    value: function () {\n      var _addBlockHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(blockHeader, stateStore) {\n        var lastBlockHeaders;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                debug('addBlockHeader invoked');\n                debug('validateBlockHeader invoked');\n                lastBlockHeaders = stateStore.chain.lastBlockHeaders;\n                _context.next = 5;\n                return this.verifyBlockHeaders(blockHeader, stateStore);\n\n              case 5:\n                _context.next = 7;\n                return this.updatePrevotesPrecommits(blockHeader, stateStore, lastBlockHeaders);\n\n              case 7:\n                _context.next = 9;\n                return this.updateFinalizedHeight(stateStore);\n\n              case 9:\n                debug('after adding block header', {\n                  finalizedHeight: this.finalizedHeight\n                });\n                return _context.abrupt(\"return\", this);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function addBlockHeader(_x, _x2) {\n        return _addBlockHeader.apply(this, arguments);\n      }\n\n      return addBlockHeader;\n    }()\n  }, {\n    key: \"updatePrevotesPrecommits\",\n    value: function () {\n      var _updatePrevotesPrecommits = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(header, stateStore, bftBlockHeaders) {\n        var _a, generatorPublicKey, generatorAddress, validators, validator, votingLedger, validatorsMap, ledgerMap, validatorState, minValidHeightToPreCommit, validatorMinHeightActive, minPreCommitHeight, maxPreCommitHeight, j, ledgerState, minPreVoteHeight, maxPreVoteHeight, _j, _ledgerState;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                debug('updatePrevotesPrecommits invoked');\n\n                if (!(header.asset.maxHeightPreviouslyForged >= header.height)) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 3:\n                generatorPublicKey = header.generatorPublicKey;\n                generatorAddress = lisk_cryptography_1.getAddressFromPublicKey(generatorPublicKey);\n                _context2.next = 7;\n                return lisk_chain_1.getValidators(stateStore);\n\n              case 7:\n                validators = _context2.sent;\n                validator = validators.find(function (v) {\n                  return v.address.equals(generatorAddress);\n                });\n\n                if (validator) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                throw new Error(\"Generator \".concat(generatorPublicKey.toString('hex'), \" is not in validators set\"));\n\n              case 11:\n                if (validator.isConsensusParticipant) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", false);\n\n              case 13:\n                _context2.next = 15;\n                return this._getVotingLedger(stateStore);\n\n              case 15:\n                votingLedger = _context2.sent;\n                validatorsMap = votingLedger.validators, ledgerMap = votingLedger.ledger;\n                validatorState = (_a = validatorsMap.get(generatorAddress)) !== null && _a !== void 0 ? _a : {\n                  maxPreVoteHeight: 0,\n                  maxPreCommitHeight: 0\n                };\n                minValidHeightToPreCommit = this._getMinValidHeightToPreCommit(header, bftBlockHeaders);\n                validatorMinHeightActive = validator.minActiveHeight;\n                minPreCommitHeight = Math.max(header.height - this.processingThreshold, validatorMinHeightActive, minValidHeightToPreCommit, validatorState.maxPreCommitHeight + 1);\n                maxPreCommitHeight = header.height - 1;\n\n                for (j = minPreCommitHeight; j <= maxPreCommitHeight; j += 1) {\n                  ledgerState = ledgerMap[j] || {\n                    prevotes: 0,\n                    precommits: 0\n                  };\n\n                  if (ledgerState.prevotes >= this.preVoteThreshold) {\n                    ledgerState.precommits += 1;\n                    validatorState.maxPreCommitHeight = j;\n                    ledgerMap[j] = ledgerState;\n                    validatorsMap.set(generatorAddress, validatorState);\n                  }\n                }\n\n                minPreVoteHeight = Math.max(validatorMinHeightActive, header.asset.maxHeightPreviouslyForged + 1, header.height - this.processingThreshold);\n                maxPreVoteHeight = header.height;\n\n                for (_j = minPreVoteHeight; _j <= maxPreVoteHeight; _j += 1) {\n                  _ledgerState = ledgerMap[_j] || {\n                    prevotes: 0,\n                    precommits: 0\n                  };\n                  _ledgerState.prevotes += 1;\n                  ledgerMap[_j] = _ledgerState;\n                }\n\n                validatorState.maxPreVoteHeight = maxPreVoteHeight;\n                validatorsMap.set(generatorAddress, validatorState);\n                Object.keys(ledgerMap).slice(0, this.maxHeaders * -1).forEach(function (key) {\n                  delete ledgerMap[key];\n                });\n                _context2.next = 31;\n                return this._setVotingLedger(stateStore, {\n                  validators: validatorsMap,\n                  ledger: ledgerMap\n                });\n\n              case 31:\n                return _context2.abrupt(\"return\", true);\n\n              case 32:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function updatePrevotesPrecommits(_x3, _x4, _x5) {\n        return _updatePrevotesPrecommits.apply(this, arguments);\n      }\n\n      return updatePrevotesPrecommits;\n    }()\n  }, {\n    key: \"updateFinalizedHeight\",\n    value: function () {\n      var _updateFinalizedHeight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(stateStore) {\n        var _this2 = this;\n\n        var _yield$this$_getVotin, ledger, highestHeightPreCommitted, previouslyFinalizedHeight, nextFinalizedHeight;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                debug('updatePreVotedAndFinalizedHeight invoked');\n                _context3.next = 3;\n                return this._getVotingLedger(stateStore);\n\n              case 3:\n                _yield$this$_getVotin = _context3.sent;\n                ledger = _yield$this$_getVotin.ledger;\n                highestHeightPreCommitted = Object.keys(ledger).reverse().find(function (key) {\n                  return ledger[key].precommits >= _this2.preCommitThreshold;\n                });\n\n                if (highestHeightPreCommitted) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", false);\n\n              case 8:\n                previouslyFinalizedHeight = this.finalizedHeight;\n                nextFinalizedHeight = parseInt(highestHeightPreCommitted, 10);\n\n                if (!(nextFinalizedHeight <= previouslyFinalizedHeight)) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", false);\n\n              case 12:\n                this.finalizedHeight = nextFinalizedHeight;\n                this.emit(exports.EVENT_BFT_FINALIZED_HEIGHT_CHANGED, this.finalizedHeight);\n                return _context3.abrupt(\"return\", true);\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function updateFinalizedHeight(_x6) {\n        return _updateFinalizedHeight.apply(this, arguments);\n      }\n\n      return updateFinalizedHeight;\n    }()\n  }, {\n    key: \"verifyBlockHeaders\",\n    value: function () {\n      var _verifyBlockHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(blockHeader, stateStore) {\n        var bftBlockHeaders, _yield$this$_getVotin2, ledger, lastMaxHeightPrevoted, chainMaxHeightPrevoted, validatorLastBlock;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                debug('verifyBlockHeaders invoked');\n                debug(blockHeader);\n                bftBlockHeaders = stateStore.chain.lastBlockHeaders;\n                _context4.next = 5;\n                return this._getVotingLedger(stateStore);\n\n              case 5:\n                _yield$this$_getVotin2 = _context4.sent;\n                ledger = _yield$this$_getVotin2.ledger;\n                lastMaxHeightPrevoted = bftBlockHeaders.length > 0 && bftBlockHeaders[0].asset.maxHeightPrevoted ? bftBlockHeaders[0].asset.maxHeightPrevoted : this._genesisHeight;\n                chainMaxHeightPrevoted = this._calculateMaxHeightPrevoted(ledger, lastMaxHeightPrevoted);\n\n                if (!(bftBlockHeaders.length >= this.processingThreshold && blockHeader.asset.maxHeightPrevoted !== chainMaxHeightPrevoted)) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                throw new types_1.BFTInvalidAttributeError(\"Wrong maxHeightPrevoted in blockHeader. maxHeightPrevoted: \".concat(blockHeader.asset.maxHeightPrevoted, \", : \").concat(chainMaxHeightPrevoted));\n\n              case 11:\n                validatorLastBlock = bftBlockHeaders.find(function (header) {\n                  return header.generatorPublicKey.equals(blockHeader.generatorPublicKey);\n                });\n\n                if (validatorLastBlock) {\n                  _context4.next = 14;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", true);\n\n              case 14:\n                if (!header_contradicting_1.areHeadersContradicting(validatorLastBlock, blockHeader)) {\n                  _context4.next = 16;\n                  break;\n                }\n\n                throw new types_1.BFTError();\n\n              case 16:\n                return _context4.abrupt(\"return\", true);\n\n              case 17:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function verifyBlockHeaders(_x7, _x8) {\n        return _verifyBlockHeaders.apply(this, arguments);\n      }\n\n      return verifyBlockHeaders;\n    }()\n  }, {\n    key: \"getMaxHeightPrevoted\",\n    value: function () {\n      var _getMaxHeightPrevoted = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(lastMaxHeightPrevoted) {\n        var bftState, _this$_decodeVotingLe, ledger;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._chain.dataAccess.getConsensusState(exports.CONSENSUS_STATE_VALIDATOR_LEDGER_KEY);\n\n              case 2:\n                bftState = _context5.sent;\n                _this$_decodeVotingLe = this._decodeVotingLedger(bftState), ledger = _this$_decodeVotingLe.ledger;\n                return _context5.abrupt(\"return\", this._calculateMaxHeightPrevoted(ledger, lastMaxHeightPrevoted !== null && lastMaxHeightPrevoted !== void 0 ? lastMaxHeightPrevoted : this._genesisHeight));\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getMaxHeightPrevoted(_x9) {\n        return _getMaxHeightPrevoted.apply(this, arguments);\n      }\n\n      return getMaxHeightPrevoted;\n    }()\n  }, {\n    key: \"_calculateMaxHeightPrevoted\",\n    value: function _calculateMaxHeightPrevoted(ledger, lastMaxHeightPrevoted) {\n      var _this3 = this;\n\n      debug('updatePreVotedAndFinalizedHeight invoked');\n      var maxHeightPreVoted = Object.keys(ledger).reverse().find(function (key) {\n        return ledger[key].prevotes >= _this3.preVoteThreshold;\n      });\n      return maxHeightPreVoted ? parseInt(maxHeightPreVoted, 10) : lastMaxHeightPrevoted;\n    }\n  }, {\n    key: \"_getMinValidHeightToPreCommit\",\n    value: function _getMinValidHeightToPreCommit(header, bftApplicableBlocks) {\n      var needleHeight = Math.max(header.asset.maxHeightPreviouslyForged, header.height - this.processingThreshold);\n      var searchTillHeight = Math.max(1, header.height - this.processingThreshold);\n      var previousBlockHeight = header.asset.maxHeightPreviouslyForged;\n      var blocksIncludingCurrent = [header].concat(_toConsumableArray(bftApplicableBlocks));\n\n      while (needleHeight >= searchTillHeight) {\n        if (needleHeight === previousBlockHeight) {\n          var previousBlockHeader = blocksIncludingCurrent.find(function (bftHeader) {\n            return bftHeader.height === needleHeight;\n          });\n\n          if (!previousBlockHeader) {\n            debug('Fail to get cached block header');\n            return 0;\n          }\n\n          if (!previousBlockHeader.generatorPublicKey.equals(header.generatorPublicKey) || previousBlockHeader.asset.maxHeightPreviouslyForged >= needleHeight) {\n            return needleHeight + 1;\n          }\n\n          previousBlockHeight = previousBlockHeader.asset.maxHeightPreviouslyForged;\n          needleHeight = previousBlockHeader.asset.maxHeightPreviouslyForged;\n        } else {\n          needleHeight -= 1;\n        }\n      }\n\n      return Math.max(needleHeight + 1, searchTillHeight);\n    }\n  }, {\n    key: \"_getVotingLedger\",\n    value: function () {\n      var _getVotingLedger2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(stateStore) {\n        var votingLedgerBuffer;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return stateStore.consensus.get(exports.CONSENSUS_STATE_VALIDATOR_LEDGER_KEY);\n\n              case 2:\n                votingLedgerBuffer = _context6.sent;\n                return _context6.abrupt(\"return\", this._decodeVotingLedger(votingLedgerBuffer));\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _getVotingLedger(_x10) {\n        return _getVotingLedger2.apply(this, arguments);\n      }\n\n      return _getVotingLedger;\n    }()\n  }, {\n    key: \"_decodeVotingLedger\",\n    value: function _decodeVotingLedger(bftVotingLedgerBuffer) {\n      var votingLedger = bftVotingLedgerBuffer === undefined ? {\n        ledger: [],\n        validators: []\n      } : lisk_codec_1.codec.decode(exports.BFTVotingLedgerSchema, bftVotingLedgerBuffer);\n      var ledger = votingLedger.ledger.reduce(function (prev, curr) {\n        prev[curr.height] = {\n          prevotes: curr.prevotes,\n          precommits: curr.precommits\n        };\n        return prev;\n      }, {});\n      var validators = votingLedger.validators.reduce(function (prev, curr) {\n        prev.set(curr.address, {\n          maxPreVoteHeight: curr.maxPreVoteHeight,\n          maxPreCommitHeight: curr.maxPreCommitHeight\n        });\n        return prev;\n      }, new lisk_utils_1.dataStructures.BufferMap());\n      return {\n        ledger: ledger,\n        validators: validators\n      };\n    }\n  }, {\n    key: \"_setVotingLedger\",\n    value: function () {\n      var _setVotingLedger2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(stateStore, votingLedgerMap) {\n        var ledgerState, _i, _Object$keys, height, intHeight, validatorsState, _iterator, _step, _step$value, key, value;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                ledgerState = [];\n\n                for (_i = 0, _Object$keys = Object.keys(votingLedgerMap.ledger); _i < _Object$keys.length; _i++) {\n                  height = _Object$keys[_i];\n                  intHeight = parseInt(height, 10);\n                  ledgerState.push(_objectSpread({\n                    height: intHeight\n                  }, votingLedgerMap.ledger[intHeight]));\n                }\n\n                validatorsState = [];\n                _iterator = _createForOfIteratorHelper(votingLedgerMap.validators.entries());\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value = _step$value[1];\n                    validatorsState.push(_objectSpread({\n                      address: key\n                    }, value));\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context7.next = 7;\n                return stateStore.consensus.set(exports.CONSENSUS_STATE_VALIDATOR_LEDGER_KEY, lisk_codec_1.codec.encode(exports.BFTVotingLedgerSchema, {\n                  validators: validatorsState,\n                  ledger: ledgerState\n                }));\n\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function _setVotingLedger(_x11, _x12) {\n        return _setVotingLedger2.apply(this, arguments);\n      }\n\n      return _setVotingLedger;\n    }()\n  }]);\n\n  return FinalityManager;\n}(events_1.EventEmitter);\n\nexports.FinalityManager = FinalityManager;","map":{"version":3,"sources":["../src/finality_manager.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FinalityManager = exports.BFTVotingLedgerSchema = exports.CONSENSUS_STATE_VALIDATOR_LEDGER_KEY = exports.EVENT_BFT_FINALIZED_HEIGHT_CHANGED = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_chain_1 = require(\"@liskhq/lisk-chain\");\nconst assert = require(\"assert\");\nconst createDebug = require(\"debug\");\nconst events_1 = require(\"events\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst constant_1 = require(\"./constant\");\nconst types_1 = require(\"./types\");\nconst header_contradicting_1 = require(\"./header_contradicting\");\nconst debug = createDebug('lisk:bft:consensus_manager');\nexports.EVENT_BFT_FINALIZED_HEIGHT_CHANGED = 'EVENT_BFT_FINALIZED_HEIGHT_CHANGED';\nexports.CONSENSUS_STATE_VALIDATOR_LEDGER_KEY = 'bft:votingLedger';\nexports.BFTVotingLedgerSchema = {\n    type: 'object',\n    $id: '/bft/validators',\n    title: 'Lisk BFT Validator ledger',\n    required: ['validators', 'ledger'],\n    properties: {\n        validators: {\n            type: 'array',\n            fieldNumber: 1,\n            items: {\n                type: 'object',\n                required: ['address', 'maxPreVoteHeight', 'maxPreCommitHeight'],\n                properties: {\n                    address: {\n                        dataType: 'bytes',\n                        fieldNumber: 1,\n                    },\n                    maxPreVoteHeight: {\n                        dataType: 'uint32',\n                        fieldNumber: 2,\n                    },\n                    maxPreCommitHeight: {\n                        dataType: 'uint32',\n                        fieldNumber: 3,\n                    },\n                },\n            },\n        },\n        ledger: {\n            type: 'array',\n            fieldNumber: 2,\n            items: {\n                type: 'object',\n                required: ['height', 'prevotes', 'precommits'],\n                properties: {\n                    height: {\n                        dataType: 'uint32',\n                        fieldNumber: 1,\n                    },\n                    prevotes: {\n                        dataType: 'uint32',\n                        fieldNumber: 2,\n                    },\n                    precommits: {\n                        dataType: 'uint32',\n                        fieldNumber: 3,\n                    },\n                },\n            },\n        },\n    },\n};\nlisk_codec_1.codec.addSchema(exports.BFTVotingLedgerSchema);\nclass FinalityManager extends events_1.EventEmitter {\n    constructor({ chain, genesisHeight, finalizedHeight, threshold, }) {\n        super();\n        assert(threshold > 0, 'Must provide a positive threshold');\n        this._chain = chain;\n        this._genesisHeight = genesisHeight;\n        this.preVoteThreshold = threshold;\n        this.preCommitThreshold = threshold;\n        if (this._chain.numberOfValidators <= 0) {\n            throw new Error('Invalid number of validators for BFT property');\n        }\n        this.processingThreshold = this._chain.numberOfValidators * constant_1.BFT_ROUND_THRESHOLD - 1;\n        this.maxHeaders = this._chain.numberOfValidators * 5;\n        this.finalizedHeight = finalizedHeight;\n    }\n    async addBlockHeader(blockHeader, stateStore) {\n        debug('addBlockHeader invoked');\n        debug('validateBlockHeader invoked');\n        const { lastBlockHeaders } = stateStore.chain;\n        await this.verifyBlockHeaders(blockHeader, stateStore);\n        await this.updatePrevotesPrecommits(blockHeader, stateStore, lastBlockHeaders);\n        await this.updateFinalizedHeight(stateStore);\n        debug('after adding block header', {\n            finalizedHeight: this.finalizedHeight,\n        });\n        return this;\n    }\n    async updatePrevotesPrecommits(header, stateStore, bftBlockHeaders) {\n        var _a;\n        debug('updatePrevotesPrecommits invoked');\n        if (header.asset.maxHeightPreviouslyForged >= header.height) {\n            return false;\n        }\n        const { generatorPublicKey } = header;\n        const generatorAddress = lisk_cryptography_1.getAddressFromPublicKey(generatorPublicKey);\n        const validators = await lisk_chain_1.getValidators(stateStore);\n        const validator = validators.find(v => v.address.equals(generatorAddress));\n        if (!validator) {\n            throw new Error(`Generator ${generatorPublicKey.toString('hex')} is not in validators set`);\n        }\n        if (!validator.isConsensusParticipant) {\n            return false;\n        }\n        const votingLedger = await this._getVotingLedger(stateStore);\n        const { validators: validatorsMap, ledger: ledgerMap } = votingLedger;\n        const validatorState = (_a = validatorsMap.get(generatorAddress)) !== null && _a !== void 0 ? _a : {\n            maxPreVoteHeight: 0,\n            maxPreCommitHeight: 0,\n        };\n        const minValidHeightToPreCommit = this._getMinValidHeightToPreCommit(header, bftBlockHeaders);\n        const validatorMinHeightActive = validator.minActiveHeight;\n        const minPreCommitHeight = Math.max(header.height - this.processingThreshold, validatorMinHeightActive, minValidHeightToPreCommit, validatorState.maxPreCommitHeight + 1);\n        const maxPreCommitHeight = header.height - 1;\n        for (let j = minPreCommitHeight; j <= maxPreCommitHeight; j += 1) {\n            const ledgerState = ledgerMap[j] || {\n                prevotes: 0,\n                precommits: 0,\n            };\n            if (ledgerState.prevotes >= this.preVoteThreshold) {\n                ledgerState.precommits += 1;\n                validatorState.maxPreCommitHeight = j;\n                ledgerMap[j] = ledgerState;\n                validatorsMap.set(generatorAddress, validatorState);\n            }\n        }\n        const minPreVoteHeight = Math.max(validatorMinHeightActive, header.asset.maxHeightPreviouslyForged + 1, header.height - this.processingThreshold);\n        const maxPreVoteHeight = header.height;\n        for (let j = minPreVoteHeight; j <= maxPreVoteHeight; j += 1) {\n            const ledgerState = ledgerMap[j] || {\n                prevotes: 0,\n                precommits: 0,\n            };\n            ledgerState.prevotes += 1;\n            ledgerMap[j] = ledgerState;\n        }\n        validatorState.maxPreVoteHeight = maxPreVoteHeight;\n        validatorsMap.set(generatorAddress, validatorState);\n        Object.keys(ledgerMap)\n            .slice(0, this.maxHeaders * -1)\n            .forEach(key => {\n            delete ledgerMap[key];\n        });\n        await this._setVotingLedger(stateStore, {\n            validators: validatorsMap,\n            ledger: ledgerMap,\n        });\n        return true;\n    }\n    async updateFinalizedHeight(stateStore) {\n        debug('updatePreVotedAndFinalizedHeight invoked');\n        const { ledger } = await this._getVotingLedger(stateStore);\n        const highestHeightPreCommitted = Object.keys(ledger)\n            .reverse()\n            .find(key => ledger[key].precommits >= this.preCommitThreshold);\n        if (!highestHeightPreCommitted) {\n            return false;\n        }\n        const previouslyFinalizedHeight = this.finalizedHeight;\n        const nextFinalizedHeight = parseInt(highestHeightPreCommitted, 10);\n        if (nextFinalizedHeight <= previouslyFinalizedHeight) {\n            return false;\n        }\n        this.finalizedHeight = nextFinalizedHeight;\n        this.emit(exports.EVENT_BFT_FINALIZED_HEIGHT_CHANGED, this.finalizedHeight);\n        return true;\n    }\n    async verifyBlockHeaders(blockHeader, stateStore) {\n        debug('verifyBlockHeaders invoked');\n        debug(blockHeader);\n        const bftBlockHeaders = stateStore.chain.lastBlockHeaders;\n        const { ledger } = await this._getVotingLedger(stateStore);\n        const lastMaxHeightPrevoted = bftBlockHeaders.length > 0 && bftBlockHeaders[0].asset.maxHeightPrevoted\n            ? bftBlockHeaders[0].asset.maxHeightPrevoted\n            : this._genesisHeight;\n        const chainMaxHeightPrevoted = this._calculateMaxHeightPrevoted(ledger, lastMaxHeightPrevoted);\n        if (bftBlockHeaders.length >= this.processingThreshold &&\n            blockHeader.asset.maxHeightPrevoted !== chainMaxHeightPrevoted) {\n            throw new types_1.BFTInvalidAttributeError(`Wrong maxHeightPrevoted in blockHeader. maxHeightPrevoted: ${blockHeader.asset.maxHeightPrevoted}, : ${chainMaxHeightPrevoted}`);\n        }\n        const validatorLastBlock = bftBlockHeaders.find(header => header.generatorPublicKey.equals(blockHeader.generatorPublicKey));\n        if (!validatorLastBlock) {\n            return true;\n        }\n        if (header_contradicting_1.areHeadersContradicting(validatorLastBlock, blockHeader)) {\n            throw new types_1.BFTError();\n        }\n        return true;\n    }\n    async getMaxHeightPrevoted(lastMaxHeightPrevoted) {\n        const bftState = await this._chain.dataAccess.getConsensusState(exports.CONSENSUS_STATE_VALIDATOR_LEDGER_KEY);\n        const { ledger } = this._decodeVotingLedger(bftState);\n        return this._calculateMaxHeightPrevoted(ledger, lastMaxHeightPrevoted !== null && lastMaxHeightPrevoted !== void 0 ? lastMaxHeightPrevoted : this._genesisHeight);\n    }\n    _calculateMaxHeightPrevoted(ledger, lastMaxHeightPrevoted) {\n        debug('updatePreVotedAndFinalizedHeight invoked');\n        const maxHeightPreVoted = Object.keys(ledger)\n            .reverse()\n            .find(key => ledger[key].prevotes >= this.preVoteThreshold);\n        return maxHeightPreVoted ? parseInt(maxHeightPreVoted, 10) : lastMaxHeightPrevoted;\n    }\n    _getMinValidHeightToPreCommit(header, bftApplicableBlocks) {\n        let needleHeight = Math.max(header.asset.maxHeightPreviouslyForged, header.height - this.processingThreshold);\n        const searchTillHeight = Math.max(1, header.height - this.processingThreshold);\n        let previousBlockHeight = header.asset.maxHeightPreviouslyForged;\n        const blocksIncludingCurrent = [header, ...bftApplicableBlocks];\n        while (needleHeight >= searchTillHeight) {\n            if (needleHeight === previousBlockHeight) {\n                const previousBlockHeader = blocksIncludingCurrent.find(bftHeader => bftHeader.height === needleHeight);\n                if (!previousBlockHeader) {\n                    debug('Fail to get cached block header');\n                    return 0;\n                }\n                if (!previousBlockHeader.generatorPublicKey.equals(header.generatorPublicKey) ||\n                    previousBlockHeader.asset.maxHeightPreviouslyForged >= needleHeight) {\n                    return needleHeight + 1;\n                }\n                previousBlockHeight = previousBlockHeader.asset.maxHeightPreviouslyForged;\n                needleHeight = previousBlockHeader.asset.maxHeightPreviouslyForged;\n            }\n            else {\n                needleHeight -= 1;\n            }\n        }\n        return Math.max(needleHeight + 1, searchTillHeight);\n    }\n    async _getVotingLedger(stateStore) {\n        const votingLedgerBuffer = await stateStore.consensus.get(exports.CONSENSUS_STATE_VALIDATOR_LEDGER_KEY);\n        return this._decodeVotingLedger(votingLedgerBuffer);\n    }\n    _decodeVotingLedger(bftVotingLedgerBuffer) {\n        const votingLedger = bftVotingLedgerBuffer === undefined\n            ? {\n                ledger: [],\n                validators: [],\n            }\n            : lisk_codec_1.codec.decode(exports.BFTVotingLedgerSchema, bftVotingLedgerBuffer);\n        const ledger = votingLedger.ledger.reduce((prev, curr) => {\n            prev[curr.height] = {\n                prevotes: curr.prevotes,\n                precommits: curr.precommits,\n            };\n            return prev;\n        }, {});\n        const validators = votingLedger.validators.reduce((prev, curr) => {\n            prev.set(curr.address, {\n                maxPreVoteHeight: curr.maxPreVoteHeight,\n                maxPreCommitHeight: curr.maxPreCommitHeight,\n            });\n            return prev;\n        }, new lisk_utils_1.dataStructures.BufferMap());\n        return { ledger, validators };\n    }\n    async _setVotingLedger(stateStore, votingLedgerMap) {\n        const ledgerState = [];\n        for (const height of Object.keys(votingLedgerMap.ledger)) {\n            const intHeight = parseInt(height, 10);\n            ledgerState.push({\n                height: intHeight,\n                ...votingLedgerMap.ledger[intHeight],\n            });\n        }\n        const validatorsState = [];\n        for (const [key, value] of votingLedgerMap.validators.entries()) {\n            validatorsState.push({\n                address: key,\n                ...value,\n            });\n        }\n        await stateStore.consensus.set(exports.CONSENSUS_STATE_VALIDATOR_LEDGER_KEY, lisk_codec_1.codec.encode(exports.BFTVotingLedgerSchema, {\n            validators: validatorsState,\n            ledger: ledgerState,\n        }));\n    }\n}\nexports.FinalityManager = FinalityManager;\n//# sourceMappingURL=finality_manager.js.map"]},"metadata":{},"sourceType":"script"}