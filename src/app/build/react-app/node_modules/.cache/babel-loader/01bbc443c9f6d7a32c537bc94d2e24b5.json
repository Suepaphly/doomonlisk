{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BlockHeaderInterfaceAdapter = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar schema_1 = require(\"../schema\");\n\nvar BlockHeaderInterfaceAdapter = /*#__PURE__*/function () {\n  function BlockHeaderInterfaceAdapter() {\n    var _this = this;\n\n    var registeredBlocks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, BlockHeaderInterfaceAdapter);\n\n    this._blockSchemaMap = new Map();\n    Object.keys(registeredBlocks).forEach(function (version) {\n      _this._blockSchemaMap.set(Number(version), registeredBlocks[Number(version)]);\n    });\n  }\n\n  _createClass(BlockHeaderInterfaceAdapter, [{\n    key: \"getSchema\",\n    value: function getSchema(version) {\n      var assetSchema = this._blockSchemaMap.get(version);\n\n      if (!assetSchema) {\n        throw new Error(\"Asset Schema not found for block version: \".concat(version, \".\"));\n      }\n\n      return assetSchema;\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(buffer) {\n      var blockHeader = lisk_codec_1.codec.decode(schema_1.blockHeaderSchema, buffer);\n      var assetSchema = this.getSchema(blockHeader.version);\n      var asset = lisk_codec_1.codec.decode(assetSchema, blockHeader.asset);\n      var id = lisk_cryptography_1.hash(buffer);\n      return _objectSpread(_objectSpread({}, blockHeader), {}, {\n        asset: asset,\n        id: id\n      });\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(header) {\n      var skipSignature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var assetSchema = this.getSchema(header.version);\n      var encodedAsset = lisk_codec_1.codec.encode(assetSchema, header.asset);\n\n      var rawHeader = _objectSpread(_objectSpread({}, header), {}, {\n        asset: encodedAsset\n      });\n\n      var schema = skipSignature ? schema_1.signingBlockHeaderSchema : schema_1.blockHeaderSchema;\n      return lisk_codec_1.codec.encode(schema, rawHeader);\n    }\n  }]);\n\n  return BlockHeaderInterfaceAdapter;\n}();\n\nexports.BlockHeaderInterfaceAdapter = BlockHeaderInterfaceAdapter;","map":{"version":3,"sources":["../../src/data_access/block_header_interface_adapter.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAaA,IAAA,YAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AACA,IAAA,mBAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;IAMa,2B;AAGZ,yCAAgE;AAAA;;AAAA,QAA7C,gBAA6C,uEAAF,EAAE;;AAAA;;AAC/D,SAAK,eAAL,GAAuB,IAAI,GAAJ,EAAvB;AACA,IAAA,MAAM,CAAC,IAAP,CAAY,gBAAZ,EAA8B,OAA9B,CAAsC,UAAA,OAAO,EAAG;AAC/C,MAAA,KAAI,CAAC,eAAL,CAAqB,GAArB,CAAyB,MAAM,CAAC,OAAD,CAA/B,EAA0C,gBAAgB,CAAC,MAAM,CAAC,OAAD,CAAP,CAA1D;AACA,KAFD;AAGA;;;;WAEM,mBAAU,OAAV,EAAyB;AAC/B,UAAM,WAAW,GAAG,KAAK,eAAL,CAAqB,GAArB,CAAyB,OAAzB,CAApB;;AACA,UAAI,CAAC,WAAL,EAAkB;AACjB,cAAM,IAAI,KAAJ,qDAAuD,OAAvD,OAAN;AACA;;AACD,aAAO,WAAP;AACA;;;WAEM,gBAAU,MAAV,EAAwB;AAC9B,UAAM,WAAW,GAAG,YAAA,CAAA,KAAA,CAAM,MAAN,CAA6B,QAAA,CAAA,iBAA7B,EAAgD,MAAhD,CAApB;AAEA,UAAM,WAAW,GAAG,KAAK,SAAL,CAAe,WAAW,CAAC,OAA3B,CAApB;AACA,UAAM,KAAK,GAAG,YAAA,CAAA,KAAA,CAAM,MAAN,CAAgB,WAAhB,EAA6B,WAAW,CAAC,KAAzC,CAAd;AACA,UAAM,EAAE,GAAG,mBAAA,CAAA,IAAA,CAAK,MAAL,CAAX;AAEA,6CAAY,WAAZ;AAAyB,QAAA,KAAK,EAAL,KAAzB;AAAgC,QAAA,EAAE,EAAF;AAAhC;AACA;;;WAEM,gBACN,MADM,EAEe;AAAA,UAArB,aAAqB,uEAAL,KAAK;AAErB,UAAM,WAAW,GAAG,KAAK,SAAL,CAAe,MAAM,CAAC,OAAtB,CAApB;AACA,UAAM,YAAY,GAAG,YAAA,CAAA,KAAA,CAAM,MAAN,CAAa,WAAb,EAA0B,MAAM,CAAC,KAAjC,CAArB;;AACA,UAAM,SAAS,mCAAQ,MAAR;AAAgB,QAAA,KAAK,EAAE;AAAvB,QAAf;;AAEA,UAAM,MAAM,GAAG,aAAa,GAAG,QAAA,CAAA,wBAAH,GAA8B,QAAA,CAAA,iBAA1D;AAEA,aAAO,YAAA,CAAA,KAAA,CAAM,MAAN,CAAa,MAAb,EAAqB,SAArB,CAAP;AACA;;;;;;AAvCF,OAAA,CAAA,2BAAA,GAAA,2BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlockHeaderInterfaceAdapter = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst schema_1 = require(\"../schema\");\nclass BlockHeaderInterfaceAdapter {\n    constructor(registeredBlocks = {}) {\n        this._blockSchemaMap = new Map();\n        Object.keys(registeredBlocks).forEach(version => {\n            this._blockSchemaMap.set(Number(version), registeredBlocks[Number(version)]);\n        });\n    }\n    getSchema(version) {\n        const assetSchema = this._blockSchemaMap.get(version);\n        if (!assetSchema) {\n            throw new Error(`Asset Schema not found for block version: ${version}.`);\n        }\n        return assetSchema;\n    }\n    decode(buffer) {\n        const blockHeader = lisk_codec_1.codec.decode(schema_1.blockHeaderSchema, buffer);\n        const assetSchema = this.getSchema(blockHeader.version);\n        const asset = lisk_codec_1.codec.decode(assetSchema, blockHeader.asset);\n        const id = lisk_cryptography_1.hash(buffer);\n        return { ...blockHeader, asset, id };\n    }\n    encode(header, skipSignature = false) {\n        const assetSchema = this.getSchema(header.version);\n        const encodedAsset = lisk_codec_1.codec.encode(assetSchema, header.asset);\n        const rawHeader = { ...header, asset: encodedAsset };\n        const schema = skipSignature ? schema_1.signingBlockHeaderSchema : schema_1.blockHeaderSchema;\n        return lisk_codec_1.codec.encode(schema, rawHeader);\n    }\n}\nexports.BlockHeaderInterfaceAdapter = BlockHeaderInterfaceAdapter;\n//# sourceMappingURL=block_header_interface_adapter.js.map"]},"metadata":{},"sourceType":"script"}