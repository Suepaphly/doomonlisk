{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stringToBuffer = exports.hexToBuffer = exports.bufferToHex = exports.intToBuffer = exports.LITTLE_ENDIAN = exports.BIG_ENDIAN = void 0;\nexports.BIG_ENDIAN = 'big';\nexports.LITTLE_ENDIAN = 'little';\nvar MAX_NUMBER_BYTE_LENGTH = 6;\n\nvar intToBuffer = function intToBuffer(value, byteLength) {\n  var endianness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.BIG_ENDIAN;\n  var signed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (![exports.BIG_ENDIAN, exports.LITTLE_ENDIAN].includes(endianness)) {\n    throw new Error(\"Endianness must be either \".concat(exports.BIG_ENDIAN, \" or \").concat(exports.LITTLE_ENDIAN));\n  }\n\n  var buffer = Buffer.alloc(byteLength);\n\n  if (endianness === 'big') {\n    if (byteLength <= MAX_NUMBER_BYTE_LENGTH) {\n      if (signed) {\n        buffer.writeIntBE(Number(value), 0, byteLength);\n      } else {\n        buffer.writeUIntBE(Number(value), 0, byteLength);\n      }\n    } else {\n      if (signed) {\n        buffer.writeBigInt64BE(BigInt(value));\n      } else {\n        buffer.writeBigUInt64BE(BigInt(value));\n      }\n    }\n  } else {\n    if (byteLength <= MAX_NUMBER_BYTE_LENGTH) {\n      if (signed) {\n        buffer.writeIntLE(Number(value), 0, byteLength);\n      } else {\n        buffer.writeUIntLE(Number(value), 0, byteLength);\n      }\n    } else {\n      if (signed) {\n        buffer.writeBigInt64LE(BigInt(value));\n      } else {\n        buffer.writeBigUInt64LE(BigInt(value));\n      }\n    }\n  }\n\n  return buffer;\n};\n\nexports.intToBuffer = intToBuffer;\n\nvar bufferToHex = function bufferToHex(buffer) {\n  return Buffer.from(buffer).toString('hex');\n};\n\nexports.bufferToHex = bufferToHex;\nvar hexRegex = /^[0-9a-f]+/i;\n\nvar hexToBuffer = function hexToBuffer(hex) {\n  var argumentName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Argument';\n\n  var _a;\n\n  if (typeof hex !== 'string') {\n    throw new TypeError(\"\".concat(argumentName, \" must be a string.\"));\n  }\n\n  var matchedHex = ((_a = hex.match(hexRegex)) !== null && _a !== void 0 ? _a : [])[0];\n\n  if (!matchedHex || matchedHex.length !== hex.length) {\n    throw new TypeError(\"\".concat(argumentName, \" must be a valid hex string.\"));\n  }\n\n  if (matchedHex.length % 2 !== 0) {\n    throw new TypeError(\"\".concat(argumentName, \" must have a valid length of hex string.\"));\n  }\n\n  return Buffer.from(matchedHex, 'hex');\n};\n\nexports.hexToBuffer = hexToBuffer;\n\nvar stringToBuffer = function stringToBuffer(str) {\n  return Buffer.from(str, 'utf8');\n};\n\nexports.stringToBuffer = stringToBuffer;","map":{"version":3,"sources":["../src/buffer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stringToBuffer = exports.hexToBuffer = exports.bufferToHex = exports.intToBuffer = exports.LITTLE_ENDIAN = exports.BIG_ENDIAN = void 0;\nexports.BIG_ENDIAN = 'big';\nexports.LITTLE_ENDIAN = 'little';\nconst MAX_NUMBER_BYTE_LENGTH = 6;\nconst intToBuffer = (value, byteLength, endianness = exports.BIG_ENDIAN, signed = false) => {\n    if (![exports.BIG_ENDIAN, exports.LITTLE_ENDIAN].includes(endianness)) {\n        throw new Error(`Endianness must be either ${exports.BIG_ENDIAN} or ${exports.LITTLE_ENDIAN}`);\n    }\n    const buffer = Buffer.alloc(byteLength);\n    if (endianness === 'big') {\n        if (byteLength <= MAX_NUMBER_BYTE_LENGTH) {\n            if (signed) {\n                buffer.writeIntBE(Number(value), 0, byteLength);\n            }\n            else {\n                buffer.writeUIntBE(Number(value), 0, byteLength);\n            }\n        }\n        else {\n            if (signed) {\n                buffer.writeBigInt64BE(BigInt(value));\n            }\n            else {\n                buffer.writeBigUInt64BE(BigInt(value));\n            }\n        }\n    }\n    else {\n        if (byteLength <= MAX_NUMBER_BYTE_LENGTH) {\n            if (signed) {\n                buffer.writeIntLE(Number(value), 0, byteLength);\n            }\n            else {\n                buffer.writeUIntLE(Number(value), 0, byteLength);\n            }\n        }\n        else {\n            if (signed) {\n                buffer.writeBigInt64LE(BigInt(value));\n            }\n            else {\n                buffer.writeBigUInt64LE(BigInt(value));\n            }\n        }\n    }\n    return buffer;\n};\nexports.intToBuffer = intToBuffer;\nconst bufferToHex = (buffer) => Buffer.from(buffer).toString('hex');\nexports.bufferToHex = bufferToHex;\nconst hexRegex = /^[0-9a-f]+/i;\nconst hexToBuffer = (hex, argumentName = 'Argument') => {\n    var _a;\n    if (typeof hex !== 'string') {\n        throw new TypeError(`${argumentName} must be a string.`);\n    }\n    const matchedHex = ((_a = hex.match(hexRegex)) !== null && _a !== void 0 ? _a : [])[0];\n    if (!matchedHex || matchedHex.length !== hex.length) {\n        throw new TypeError(`${argumentName} must be a valid hex string.`);\n    }\n    if (matchedHex.length % 2 !== 0) {\n        throw new TypeError(`${argumentName} must have a valid length of hex string.`);\n    }\n    return Buffer.from(matchedHex, 'hex');\n};\nexports.hexToBuffer = hexToBuffer;\nconst stringToBuffer = (str) => Buffer.from(str, 'utf8');\nexports.stringToBuffer = stringToBuffer;\n//# sourceMappingURL=buffer.js.map"]},"metadata":{},"sourceType":"script"}