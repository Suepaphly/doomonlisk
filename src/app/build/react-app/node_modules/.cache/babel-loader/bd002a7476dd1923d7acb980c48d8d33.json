{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PeerBook = void 0;\n\nvar constants_1 = require(\"../constants\");\n\nvar errors_1 = require(\"../errors\");\n\nvar utils_1 = require(\"../utils\");\n\nvar new_list_1 = require(\"./new_list\");\n\nvar tried_list_1 = require(\"./tried_list\");\n\nvar shuffle = require(\"lodash.shuffle\");\n\nvar PeerBook = /*#__PURE__*/function () {\n  function PeerBook(_ref) {\n    var _this = this;\n\n    var sanitizedPeerLists = _ref.sanitizedPeerLists,\n        secret = _ref.secret;\n\n    _classCallCheck(this, PeerBook);\n\n    this._newPeers = new new_list_1.NewList({\n      secret: secret,\n      numOfBuckets: constants_1.DEFAULT_NEW_BUCKET_COUNT,\n      bucketSize: constants_1.DEFAULT_NEW_BUCKET_SIZE,\n      peerType: utils_1.PEER_TYPE.NEW_PEER\n    });\n    this._triedPeers = new tried_list_1.TriedList({\n      secret: secret,\n      numOfBuckets: constants_1.DEFAULT_TRIED_BUCKET_COUNT,\n      bucketSize: constants_1.DEFAULT_TRIED_BUCKET_SIZE,\n      peerType: utils_1.PEER_TYPE.TRIED_PEER\n    });\n    this._secret = secret;\n    this._bannedIPs = new Set([]);\n    this._blacklistedIPs = new Set(_toConsumableArray(sanitizedPeerLists.blacklistedIPs));\n    this._seedPeers = _toConsumableArray(sanitizedPeerLists.seedPeers);\n    this._fixedPeers = _toConsumableArray(sanitizedPeerLists.fixedPeers);\n    this._whitelistedPeers = _toConsumableArray(sanitizedPeerLists.whitelisted);\n    this._unbanTimers = [];\n    var newPeersToAdd = [].concat(_toConsumableArray(sanitizedPeerLists.fixedPeers), _toConsumableArray(sanitizedPeerLists.whitelisted), _toConsumableArray(sanitizedPeerLists.previousPeers));\n    newPeersToAdd.forEach(function (peerInfo) {\n      if (!_this.hasPeer(peerInfo)) {\n        _this.addPeer(peerInfo);\n      }\n\n      _this.upgradePeer(peerInfo);\n    });\n  }\n\n  _createClass(PeerBook, [{\n    key: \"newPeers\",\n    get: function get() {\n      return this._newPeers.peerList;\n    }\n  }, {\n    key: \"triedPeers\",\n    get: function get() {\n      return this._triedPeers.peerList;\n    }\n  }, {\n    key: \"allPeers\",\n    get: function get() {\n      return [].concat(_toConsumableArray(this.newPeers), _toConsumableArray(this.triedPeers));\n    }\n  }, {\n    key: \"seedPeers\",\n    get: function get() {\n      return this._seedPeers;\n    }\n  }, {\n    key: \"fixedPeers\",\n    get: function get() {\n      return this._fixedPeers;\n    }\n  }, {\n    key: \"whitelistedPeers\",\n    get: function get() {\n      return this._whitelistedPeers;\n    }\n  }, {\n    key: \"bannedIPs\",\n    get: function get() {\n      return new Set([].concat(_toConsumableArray(this._blacklistedIPs), _toConsumableArray(this._bannedIPs)));\n    }\n  }, {\n    key: \"cleanUpTimers\",\n    value: function cleanUpTimers() {\n      this._unbanTimers.forEach(function (timer) {\n        if (timer) {\n          clearTimeout(timer);\n        }\n      });\n    }\n  }, {\n    key: \"getRandomizedPeerList\",\n    value: function getRandomizedPeerList(minimumPeerDiscoveryThreshold, maxPeerDiscoveryResponseLength) {\n      var allPeers = [].concat(_toConsumableArray(this.newPeers), _toConsumableArray(this.triedPeers));\n      var min = Math.ceil(Math.min(maxPeerDiscoveryResponseLength, allPeers.length * 0.25));\n      var max = Math.floor(Math.min(maxPeerDiscoveryResponseLength, allPeers.length * 0.5));\n      var random = Math.floor(Math.random() * (max - min + 1) + min);\n      var randomPeerCount = Math.max(random, Math.min(minimumPeerDiscoveryThreshold, allPeers.length));\n      return shuffle(allPeers).slice(0, randomPeerCount);\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer(peerInfo) {\n      var triedPeer = this._triedPeers.getPeer(peerInfo.peerId);\n\n      if (triedPeer) {\n        return triedPeer;\n      }\n\n      return this._newPeers.getPeer(peerInfo.peerId);\n    }\n  }, {\n    key: \"hasPeer\",\n    value: function hasPeer(peerInfo) {\n      return this._triedPeers.hasPeer(peerInfo.peerId) || this._newPeers.hasPeer(peerInfo.peerId);\n    }\n  }, {\n    key: \"addPeer\",\n    value: function addPeer(peerInfo) {\n      if (this._bannedIPs.has(peerInfo.ipAddress)) {\n        return false;\n      }\n\n      if (this._triedPeers.getPeer(peerInfo.peerId)) {\n        throw new errors_1.ExistingPeerError(peerInfo);\n      }\n\n      this._newPeers.addPeer(this._assignPeerKind(peerInfo));\n\n      return true;\n    }\n  }, {\n    key: \"removePeer\",\n    value: function removePeer(peerInfo) {\n      this._newPeers.removePeer(peerInfo);\n\n      this._triedPeers.removePeer(peerInfo);\n    }\n  }, {\n    key: \"updatePeer\",\n    value: function updatePeer(peerInfo) {\n      if (this._triedPeers.getPeer(peerInfo.peerId)) {\n        return this._triedPeers.updatePeer(this._assignPeerKind(peerInfo));\n      }\n\n      if (this._newPeers.getPeer(peerInfo.peerId)) {\n        return this._newPeers.updatePeer(this._assignPeerKind(peerInfo));\n      }\n\n      return false;\n    }\n  }, {\n    key: \"upgradePeer\",\n    value: function upgradePeer(peerInfo) {\n      if (this._triedPeers.hasPeer(peerInfo.peerId)) {\n        return true;\n      }\n\n      if (this._newPeers.hasPeer(peerInfo.peerId)) {\n        this.removePeer(peerInfo);\n\n        if (this.bannedIPs.has(peerInfo.ipAddress)) {\n          return false;\n        }\n\n        this._triedPeers.addPeer(this._assignPeerKind(peerInfo));\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"downgradePeer\",\n    value: function downgradePeer(peerInfo) {\n      if (this.isTrustedPeer(peerInfo.peerId)) {\n        return false;\n      }\n\n      if (this._newPeers.hasPeer(peerInfo.peerId)) {\n        return this._newPeers.failedConnectionAction(peerInfo);\n      }\n\n      if (this._triedPeers.hasPeer(peerInfo.peerId)) {\n        var failed = this._triedPeers.failedConnectionAction(peerInfo);\n\n        if (failed) {\n          return this.addPeer(peerInfo);\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isTrustedPeer\",\n    value: function isTrustedPeer(peerId) {\n      var isSeedPeer = this.seedPeers.find(function (peer) {\n        return peer.peerId === peerId;\n      });\n      var isWhitelistedPeer = this.whitelistedPeers.find(function (peer) {\n        return peer.peerId === peerId;\n      });\n      var isFixedPeer = this.fixedPeers.find(function (peer) {\n        return peer.peerId === peerId;\n      });\n      return !!isSeedPeer || !!isWhitelistedPeer || !!isFixedPeer;\n    }\n  }, {\n    key: \"addBannedPeer\",\n    value: function addBannedPeer(peerId, peerBanTime) {\n      var _this2 = this;\n\n      var peerIpAddress = peerId.split(':')[0];\n\n      if (this.bannedIPs.has(peerIpAddress)) {\n        return;\n      }\n\n      if (this.fixedPeers.find(function (peer) {\n        return peer.peerId === peerId;\n      }) || this.whitelistedPeers.find(function (peer) {\n        return peer.peerId === peerId;\n      })) {\n        return;\n      }\n\n      this._bannedIPs.add(peerIpAddress);\n\n      this.allPeers.forEach(function (peer) {\n        if (peer.ipAddress === peerIpAddress) {\n          _this2.removePeer(peer);\n        }\n      });\n      var unbanTimeout = setTimeout(function () {\n        _this2._removeBannedPeer(peerId);\n      }, peerBanTime);\n\n      this._unbanTimers.push(unbanTimeout);\n    }\n  }, {\n    key: \"_removeBannedPeer\",\n    value: function _removeBannedPeer(peerId) {\n      var peerIpAddress = peerId.split(':')[0];\n\n      this._bannedIPs.delete(peerIpAddress);\n    }\n  }, {\n    key: \"_assignPeerKind\",\n    value: function _assignPeerKind(peerInfo) {\n      if (this.fixedPeers.find(function (peer) {\n        return peer.ipAddress === peerInfo.ipAddress;\n      })) {\n        return _objectSpread(_objectSpread({}, peerInfo), {}, {\n          internalState: _objectSpread(_objectSpread({}, utils_1.assignInternalInfo(peerInfo, this._secret)), {}, {\n            peerKind: constants_1.PeerKind.FIXED_PEER\n          })\n        });\n      }\n\n      if (this.whitelistedPeers.find(function (peer) {\n        return peer.ipAddress === peerInfo.ipAddress;\n      })) {\n        return _objectSpread(_objectSpread({}, peerInfo), {}, {\n          internalState: _objectSpread(_objectSpread({}, utils_1.assignInternalInfo(peerInfo, this._secret)), {}, {\n            peerKind: constants_1.PeerKind.WHITELISTED_PEER\n          })\n        });\n      }\n\n      if (this.seedPeers.find(function (peer) {\n        return peer.ipAddress === peerInfo.ipAddress;\n      })) {\n        return _objectSpread(_objectSpread({}, peerInfo), {}, {\n          internalState: _objectSpread(_objectSpread({}, utils_1.assignInternalInfo(peerInfo, this._secret)), {}, {\n            peerKind: constants_1.PeerKind.SEED_PEER\n          })\n        });\n      }\n\n      return _objectSpread(_objectSpread({}, peerInfo), {}, {\n        internalState: _objectSpread(_objectSpread({}, utils_1.assignInternalInfo(peerInfo, this._secret)), {}, {\n          peerKind: constants_1.PeerKind.NONE\n        })\n      });\n    }\n  }]);\n\n  return PeerBook;\n}();\n\nexports.PeerBook = PeerBook;","map":{"version":3,"sources":["../../src/peer_book/peer_book.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PeerBook = void 0;\nconst constants_1 = require(\"../constants\");\nconst errors_1 = require(\"../errors\");\nconst utils_1 = require(\"../utils\");\nconst new_list_1 = require(\"./new_list\");\nconst tried_list_1 = require(\"./tried_list\");\nconst shuffle = require(\"lodash.shuffle\");\nclass PeerBook {\n    constructor({ sanitizedPeerLists, secret }) {\n        this._newPeers = new new_list_1.NewList({\n            secret,\n            numOfBuckets: constants_1.DEFAULT_NEW_BUCKET_COUNT,\n            bucketSize: constants_1.DEFAULT_NEW_BUCKET_SIZE,\n            peerType: utils_1.PEER_TYPE.NEW_PEER,\n        });\n        this._triedPeers = new tried_list_1.TriedList({\n            secret,\n            numOfBuckets: constants_1.DEFAULT_TRIED_BUCKET_COUNT,\n            bucketSize: constants_1.DEFAULT_TRIED_BUCKET_SIZE,\n            peerType: utils_1.PEER_TYPE.TRIED_PEER,\n        });\n        this._secret = secret;\n        this._bannedIPs = new Set([]);\n        this._blacklistedIPs = new Set([...sanitizedPeerLists.blacklistedIPs]);\n        this._seedPeers = [...sanitizedPeerLists.seedPeers];\n        this._fixedPeers = [...sanitizedPeerLists.fixedPeers];\n        this._whitelistedPeers = [...sanitizedPeerLists.whitelisted];\n        this._unbanTimers = [];\n        const newPeersToAdd = [\n            ...sanitizedPeerLists.fixedPeers,\n            ...sanitizedPeerLists.whitelisted,\n            ...sanitizedPeerLists.previousPeers,\n        ];\n        newPeersToAdd.forEach(peerInfo => {\n            if (!this.hasPeer(peerInfo)) {\n                this.addPeer(peerInfo);\n            }\n            this.upgradePeer(peerInfo);\n        });\n    }\n    get newPeers() {\n        return this._newPeers.peerList;\n    }\n    get triedPeers() {\n        return this._triedPeers.peerList;\n    }\n    get allPeers() {\n        return [...this.newPeers, ...this.triedPeers];\n    }\n    get seedPeers() {\n        return this._seedPeers;\n    }\n    get fixedPeers() {\n        return this._fixedPeers;\n    }\n    get whitelistedPeers() {\n        return this._whitelistedPeers;\n    }\n    get bannedIPs() {\n        return new Set([...this._blacklistedIPs, ...this._bannedIPs]);\n    }\n    cleanUpTimers() {\n        this._unbanTimers.forEach(timer => {\n            if (timer) {\n                clearTimeout(timer);\n            }\n        });\n    }\n    getRandomizedPeerList(minimumPeerDiscoveryThreshold, maxPeerDiscoveryResponseLength) {\n        const allPeers = [...this.newPeers, ...this.triedPeers];\n        const min = Math.ceil(Math.min(maxPeerDiscoveryResponseLength, allPeers.length * 0.25));\n        const max = Math.floor(Math.min(maxPeerDiscoveryResponseLength, allPeers.length * 0.5));\n        const random = Math.floor(Math.random() * (max - min + 1) + min);\n        const randomPeerCount = Math.max(random, Math.min(minimumPeerDiscoveryThreshold, allPeers.length));\n        return shuffle(allPeers).slice(0, randomPeerCount);\n    }\n    getPeer(peerInfo) {\n        const triedPeer = this._triedPeers.getPeer(peerInfo.peerId);\n        if (triedPeer) {\n            return triedPeer;\n        }\n        return this._newPeers.getPeer(peerInfo.peerId);\n    }\n    hasPeer(peerInfo) {\n        return this._triedPeers.hasPeer(peerInfo.peerId) || this._newPeers.hasPeer(peerInfo.peerId);\n    }\n    addPeer(peerInfo) {\n        if (this._bannedIPs.has(peerInfo.ipAddress)) {\n            return false;\n        }\n        if (this._triedPeers.getPeer(peerInfo.peerId)) {\n            throw new errors_1.ExistingPeerError(peerInfo);\n        }\n        this._newPeers.addPeer(this._assignPeerKind(peerInfo));\n        return true;\n    }\n    removePeer(peerInfo) {\n        this._newPeers.removePeer(peerInfo);\n        this._triedPeers.removePeer(peerInfo);\n    }\n    updatePeer(peerInfo) {\n        if (this._triedPeers.getPeer(peerInfo.peerId)) {\n            return this._triedPeers.updatePeer(this._assignPeerKind(peerInfo));\n        }\n        if (this._newPeers.getPeer(peerInfo.peerId)) {\n            return this._newPeers.updatePeer(this._assignPeerKind(peerInfo));\n        }\n        return false;\n    }\n    upgradePeer(peerInfo) {\n        if (this._triedPeers.hasPeer(peerInfo.peerId)) {\n            return true;\n        }\n        if (this._newPeers.hasPeer(peerInfo.peerId)) {\n            this.removePeer(peerInfo);\n            if (this.bannedIPs.has(peerInfo.ipAddress)) {\n                return false;\n            }\n            this._triedPeers.addPeer(this._assignPeerKind(peerInfo));\n            return true;\n        }\n        return false;\n    }\n    downgradePeer(peerInfo) {\n        if (this.isTrustedPeer(peerInfo.peerId)) {\n            return false;\n        }\n        if (this._newPeers.hasPeer(peerInfo.peerId)) {\n            return this._newPeers.failedConnectionAction(peerInfo);\n        }\n        if (this._triedPeers.hasPeer(peerInfo.peerId)) {\n            const failed = this._triedPeers.failedConnectionAction(peerInfo);\n            if (failed) {\n                return this.addPeer(peerInfo);\n            }\n        }\n        return false;\n    }\n    isTrustedPeer(peerId) {\n        const isSeedPeer = this.seedPeers.find(peer => peer.peerId === peerId);\n        const isWhitelistedPeer = this.whitelistedPeers.find(peer => peer.peerId === peerId);\n        const isFixedPeer = this.fixedPeers.find(peer => peer.peerId === peerId);\n        return !!isSeedPeer || !!isWhitelistedPeer || !!isFixedPeer;\n    }\n    addBannedPeer(peerId, peerBanTime) {\n        const peerIpAddress = peerId.split(':')[0];\n        if (this.bannedIPs.has(peerIpAddress)) {\n            return;\n        }\n        if (this.fixedPeers.find(peer => peer.peerId === peerId) ||\n            this.whitelistedPeers.find(peer => peer.peerId === peerId)) {\n            return;\n        }\n        this._bannedIPs.add(peerIpAddress);\n        this.allPeers.forEach((peer) => {\n            if (peer.ipAddress === peerIpAddress) {\n                this.removePeer(peer);\n            }\n        });\n        const unbanTimeout = setTimeout(() => {\n            this._removeBannedPeer(peerId);\n        }, peerBanTime);\n        this._unbanTimers.push(unbanTimeout);\n    }\n    _removeBannedPeer(peerId) {\n        const peerIpAddress = peerId.split(':')[0];\n        this._bannedIPs.delete(peerIpAddress);\n    }\n    _assignPeerKind(peerInfo) {\n        if (this.fixedPeers.find(peer => peer.ipAddress === peerInfo.ipAddress)) {\n            return {\n                ...peerInfo,\n                internalState: {\n                    ...utils_1.assignInternalInfo(peerInfo, this._secret),\n                    peerKind: constants_1.PeerKind.FIXED_PEER,\n                },\n            };\n        }\n        if (this.whitelistedPeers.find(peer => peer.ipAddress === peerInfo.ipAddress)) {\n            return {\n                ...peerInfo,\n                internalState: {\n                    ...utils_1.assignInternalInfo(peerInfo, this._secret),\n                    peerKind: constants_1.PeerKind.WHITELISTED_PEER,\n                },\n            };\n        }\n        if (this.seedPeers.find(peer => peer.ipAddress === peerInfo.ipAddress)) {\n            return {\n                ...peerInfo,\n                internalState: {\n                    ...utils_1.assignInternalInfo(peerInfo, this._secret),\n                    peerKind: constants_1.PeerKind.SEED_PEER,\n                },\n            };\n        }\n        return {\n            ...peerInfo,\n            internalState: {\n                ...utils_1.assignInternalInfo(peerInfo, this._secret),\n                peerKind: constants_1.PeerKind.NONE,\n            },\n        };\n    }\n}\nexports.PeerBook = PeerBook;\n//# sourceMappingURL=peer_book.js.map"]},"metadata":{},"sourceType":"script"}