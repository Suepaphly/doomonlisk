{"ast":null,"code":"'use strict';\n\nvar _wrapRegExp = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/wrapRegExp\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar util = require('util');\n\nvar path = require('path');\n\nvar childProcess = require('child_process');\n\nvar TEN_MEGABYTES = 1000 * 1000 * 10;\nvar execFile = util.promisify(childProcess.execFile);\n\nvar windows = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var bin, _yield$execFile, stdout;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // Source: https://github.com/MarkTiedemann/fastlist\n            bin = path.join(__dirname, 'fastlist.exe');\n            _context.next = 3;\n            return execFile(bin, {\n              maxBuffer: TEN_MEGABYTES,\n              windowsHide: true\n            });\n\n          case 3:\n            _yield$execFile = _context.sent;\n            stdout = _yield$execFile.stdout;\n            return _context.abrupt(\"return\", stdout.trim().split('\\r\\n').map(function (line) {\n              return line.split('\\t');\n            }).map(function (_ref2) {\n              var _ref3 = _slicedToArray(_ref2, 3),\n                  name = _ref3[0],\n                  pid = _ref3[1],\n                  ppid = _ref3[2];\n\n              return {\n                name: name,\n                pid: Number.parseInt(pid, 10),\n                ppid: Number.parseInt(ppid, 10)\n              };\n            }));\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function windows() {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar nonWindowsMultipleCalls = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var options,\n        flags,\n        ret,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n            flags = (options.all === false ? '' : 'a') + 'wwxo';\n            ret = {};\n            _context3.next = 5;\n            return Promise.all(['comm', 'args', 'ppid', 'uid', '%cpu', '%mem'].map( /*#__PURE__*/function () {\n              var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(cmd) {\n                var _yield$execFile2, stdout, _iterator, _step, line, _line$split, _line$split2, pid, val;\n\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.next = 2;\n                        return execFile('ps', [flags, \"pid,\".concat(cmd)], {\n                          maxBuffer: TEN_MEGABYTES\n                        });\n\n                      case 2:\n                        _yield$execFile2 = _context2.sent;\n                        stdout = _yield$execFile2.stdout;\n                        _iterator = _createForOfIteratorHelper(stdout.trim().split('\\n').slice(1));\n\n                        try {\n                          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                            line = _step.value;\n                            line = line.trim();\n                            _line$split = line.split(' ', 1), _line$split2 = _slicedToArray(_line$split, 1), pid = _line$split2[0];\n                            val = line.slice(pid.length + 1).trim();\n\n                            if (ret[pid] === undefined) {\n                              ret[pid] = {};\n                            }\n\n                            ret[pid][cmd] = val;\n                          }\n                        } catch (err) {\n                          _iterator.e(err);\n                        } finally {\n                          _iterator.f();\n                        }\n\n                      case 6:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function (_x) {\n                return _ref5.apply(this, arguments);\n              };\n            }()));\n\n          case 5:\n            return _context3.abrupt(\"return\", Object.entries(ret).filter(function (_ref6) {\n              var _ref7 = _slicedToArray(_ref6, 2),\n                  value = _ref7[1];\n\n              return value.comm && value.args && value.ppid && value.uid && value['%cpu'] && value['%mem'];\n            }).map(function (_ref8) {\n              var _ref9 = _slicedToArray(_ref8, 2),\n                  key = _ref9[0],\n                  value = _ref9[1];\n\n              return {\n                pid: Number.parseInt(key, 10),\n                name: path.basename(value.comm),\n                cmd: value.args,\n                ppid: Number.parseInt(value.ppid, 10),\n                uid: Number.parseInt(value.uid, 10),\n                cpu: Number.parseFloat(value['%cpu']),\n                memory: Number.parseFloat(value['%mem'])\n              };\n            }));\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function nonWindowsMultipleCalls() {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar ERROR_MESSAGE_PARSING_FAILED = 'ps output parsing failed';\nvar psFields = 'pid,ppid,uid,%cpu,%mem,comm,args'; // TODO: Use named capture groups when targeting Node.js 10\n\nvar psOutputRegex = /*#__PURE__*/_wrapRegExp(/^[\\t ]*([0-9]+)[\\t ]+([0-9]+)[\\t ]+([0-9]+)[\\t ]+([0-9]+\\.[0-9]+)[\\t ]+([0-9]+\\.[0-9]+)[\\t ]+/, {\n  pid: 1,\n  ppid: 2,\n  uid: 3,\n  cpu: 4,\n  memory: 5\n});\n\nvar nonWindowsSingleCall = /*#__PURE__*/function () {\n  var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var options,\n        flags,\n        _yield$Promise,\n        _yield$Promise2,\n        psPid,\n        stdout,\n        lines,\n        psIndex,\n        commPosition,\n        argsPosition,\n        processes,\n        commLength,\n        _iterator2,\n        _step2,\n        _step2$value,\n        index,\n        line,\n        _args4 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};\n            flags = options.all === false ? 'wwxo' : 'awwxo'; // TODO: Use the promise version of `execFile` when https://github.com/nodejs/node/issues/28244 is fixed.\n\n            _context4.next = 4;\n            return new Promise(function (resolve, reject) {\n              var child = childProcess.execFile('ps', [flags, psFields], {\n                maxBuffer: TEN_MEGABYTES\n              }, function (error, stdout) {\n                if (error === null) {\n                  resolve([child.pid, stdout]);\n                } else {\n                  reject(error);\n                }\n              });\n            });\n\n          case 4:\n            _yield$Promise = _context4.sent;\n            _yield$Promise2 = _slicedToArray(_yield$Promise, 2);\n            psPid = _yield$Promise2[0];\n            stdout = _yield$Promise2[1];\n            lines = stdout.trim().split('\\n');\n            lines.shift();\n            processes = lines.map(function (line, index) {\n              var match = psOutputRegex.exec(line);\n\n              if (match === null) {\n                throw new Error(ERROR_MESSAGE_PARSING_FAILED);\n              }\n\n              var _match$groups = match.groups,\n                  pid = _match$groups.pid,\n                  ppid = _match$groups.ppid,\n                  uid = _match$groups.uid,\n                  cpu = _match$groups.cpu,\n                  memory = _match$groups.memory;\n              var processInfo = {\n                pid: Number.parseInt(pid, 10),\n                ppid: Number.parseInt(ppid, 10),\n                uid: Number.parseInt(uid, 10),\n                cpu: Number.parseFloat(cpu),\n                memory: Number.parseFloat(memory),\n                name: undefined,\n                cmd: undefined\n              };\n\n              if (processInfo.pid === psPid) {\n                psIndex = index;\n                commPosition = line.indexOf('ps', match[0].length);\n                argsPosition = line.indexOf('ps', commPosition + 2);\n              }\n\n              return processInfo;\n            });\n\n            if (!(psIndex === undefined || commPosition === -1 || argsPosition === -1)) {\n              _context4.next = 13;\n              break;\n            }\n\n            throw new Error(ERROR_MESSAGE_PARSING_FAILED);\n\n          case 13:\n            commLength = argsPosition - commPosition;\n            _iterator2 = _createForOfIteratorHelper(lines.entries());\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                _step2$value = _slicedToArray(_step2.value, 2), index = _step2$value[0], line = _step2$value[1];\n                processes[index].name = line.slice(commPosition, commPosition + commLength).trim();\n                processes[index].cmd = line.slice(argsPosition).trim();\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            processes.splice(psIndex, 1);\n            return _context4.abrupt(\"return\", processes);\n\n          case 18:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function nonWindowsSingleCall() {\n    return _ref10.apply(this, arguments);\n  };\n}();\n\nvar nonWindows = /*#__PURE__*/function () {\n  var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var options,\n        _args5 = arguments;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            options = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};\n            _context5.prev = 1;\n            _context5.next = 4;\n            return nonWindowsSingleCall(options);\n\n          case 4:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 7:\n            _context5.prev = 7;\n            _context5.t0 = _context5[\"catch\"](1);\n            return _context5.abrupt(\"return\", nonWindowsMultipleCalls(options));\n\n          case 10:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[1, 7]]);\n  }));\n\n  return function nonWindows() {\n    return _ref11.apply(this, arguments);\n  };\n}();\n\nmodule.exports = process.platform === 'win32' ? windows : nonWindows;","map":{"version":3,"sources":["/home/lisk/doomonlisk/node_modules/ps-list/index.js"],"names":["util","require","path","childProcess","TEN_MEGABYTES","execFile","promisify","windows","bin","join","__dirname","maxBuffer","windowsHide","stdout","trim","split","map","line","name","pid","ppid","Number","parseInt","nonWindowsMultipleCalls","options","flags","all","ret","Promise","cmd","slice","val","length","undefined","Object","entries","filter","value","comm","args","uid","key","basename","cpu","parseFloat","memory","ERROR_MESSAGE_PARSING_FAILED","psFields","psOutputRegex","nonWindowsSingleCall","resolve","reject","child","error","psPid","lines","shift","processes","index","match","exec","Error","groups","processInfo","psIndex","commPosition","indexOf","argsPosition","commLength","splice","nonWindows","module","exports","process","platform"],"mappings":"AAAA;;;;;;;;;;;;AACA,IAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,IAAME,YAAY,GAAGF,OAAO,CAAC,eAAD,CAA5B;;AAEA,IAAMG,aAAa,GAAG,OAAO,IAAP,GAAc,EAApC;AACA,IAAMC,QAAQ,GAAGL,IAAI,CAACM,SAAL,CAAeH,YAAY,CAACE,QAA5B,CAAjB;;AAEA,IAAME,OAAO;AAAA,sEAAG;AAAA;;AAAA;AAAA;AAAA;AAAA;AACf;AACMC,YAAAA,GAFS,GAEHN,IAAI,CAACO,IAAL,CAAUC,SAAV,EAAqB,cAArB,CAFG;AAAA;AAAA,mBAIQL,QAAQ,CAACG,GAAD,EAAM;AACpCG,cAAAA,SAAS,EAAEP,aADyB;AAEpCQ,cAAAA,WAAW,EAAE;AAFuB,aAAN,CAJhB;;AAAA;AAAA;AAIRC,YAAAA,MAJQ,mBAIRA,MAJQ;AAAA,6CASRA,MAAM,CACXC,IADK,GAELC,KAFK,CAEC,MAFD,EAGLC,GAHK,CAGD,UAAAC,IAAI;AAAA,qBAAIA,IAAI,CAACF,KAAL,CAAW,IAAX,CAAJ;AAAA,aAHH,EAILC,GAJK,CAID;AAAA;AAAA,kBAAEE,IAAF;AAAA,kBAAQC,GAAR;AAAA,kBAAaC,IAAb;;AAAA,qBAAwB;AAC5BF,gBAAAA,IAAI,EAAJA,IAD4B;AAE5BC,gBAAAA,GAAG,EAAEE,MAAM,CAACC,QAAP,CAAgBH,GAAhB,EAAqB,EAArB,CAFuB;AAG5BC,gBAAAA,IAAI,EAAEC,MAAM,CAACC,QAAP,CAAgBF,IAAhB,EAAsB,EAAtB;AAHsB,eAAxB;AAAA,aAJC,CATQ;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAPb,OAAO;AAAA;AAAA;AAAA,GAAb;;AAoBA,IAAMgB,uBAAuB;AAAA,uEAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAOC,YAAAA,OAAP,8DAAiB,EAAjB;AACzBC,YAAAA,KADyB,GACjB,CAACD,OAAO,CAACE,GAAR,KAAgB,KAAhB,GAAwB,EAAxB,GAA6B,GAA9B,IAAqC,MADpB;AAEzBC,YAAAA,GAFyB,GAEnB,EAFmB;AAAA;AAAA,mBAIzBC,OAAO,CAACF,GAAR,CAAY,CAAC,MAAD,EAAS,MAAT,EAAiB,MAAjB,EAAyB,KAAzB,EAAgC,MAAhC,EAAwC,MAAxC,EAAgDV,GAAhD;AAAA,mFAAoD,kBAAMa,GAAN;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAC9CxB,QAAQ,CAAC,IAAD,EAAO,CAACoB,KAAD,gBAAeI,GAAf,EAAP,EAA8B;AAAClB,0BAAAA,SAAS,EAAEP;AAAZ,yBAA9B,CADsC;;AAAA;AAAA;AAC9DS,wBAAAA,MAD8D,oBAC9DA,MAD8D;AAAA,+DAGpDA,MAAM,CAACC,IAAP,GAAcC,KAAd,CAAoB,IAApB,EAA0Be,KAA1B,CAAgC,CAAhC,CAHoD;;AAAA;AAGrE,8EAAqD;AAA5Cb,4BAAAA,IAA4C;AACpDA,4BAAAA,IAAI,GAAGA,IAAI,CAACH,IAAL,EAAP;AADoD,0CAEtCG,IAAI,CAACF,KAAL,CAAW,GAAX,EAAgB,CAAhB,CAFsC,iDAE7CI,GAF6C;AAG9CY,4BAAAA,GAH8C,GAGxCd,IAAI,CAACa,KAAL,CAAWX,GAAG,CAACa,MAAJ,GAAa,CAAxB,EAA2BlB,IAA3B,EAHwC;;AAKpD,gCAAIa,GAAG,CAACR,GAAD,CAAH,KAAac,SAAjB,EAA4B;AAC3BN,8BAAAA,GAAG,CAACR,GAAD,CAAH,GAAW,EAAX;AACA;;AAEDQ,4BAAAA,GAAG,CAACR,GAAD,CAAH,CAASU,GAAT,IAAgBE,GAAhB;AACA;AAboE;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAApD;;AAAA;AAAA;AAAA;AAAA,gBAAZ,CAJyB;;AAAA;AAAA,8CAsBxBG,MAAM,CAACC,OAAP,CAAeR,GAAf,EACLS,MADK,CACE;AAAA;AAAA,kBAAIC,KAAJ;;AAAA,qBAAeA,KAAK,CAACC,IAAN,IAAcD,KAAK,CAACE,IAApB,IAA4BF,KAAK,CAACjB,IAAlC,IAA0CiB,KAAK,CAACG,GAAhD,IAAuDH,KAAK,CAAC,MAAD,CAA5D,IAAwEA,KAAK,CAAC,MAAD,CAA5F;AAAA,aADF,EAELrB,GAFK,CAED;AAAA;AAAA,kBAAEyB,GAAF;AAAA,kBAAOJ,KAAP;;AAAA,qBAAmB;AACvBlB,gBAAAA,GAAG,EAAEE,MAAM,CAACC,QAAP,CAAgBmB,GAAhB,EAAqB,EAArB,CADkB;AAEvBvB,gBAAAA,IAAI,EAAEhB,IAAI,CAACwC,QAAL,CAAcL,KAAK,CAACC,IAApB,CAFiB;AAGvBT,gBAAAA,GAAG,EAAEQ,KAAK,CAACE,IAHY;AAIvBnB,gBAAAA,IAAI,EAAEC,MAAM,CAACC,QAAP,CAAgBe,KAAK,CAACjB,IAAtB,EAA4B,EAA5B,CAJiB;AAKvBoB,gBAAAA,GAAG,EAAEnB,MAAM,CAACC,QAAP,CAAgBe,KAAK,CAACG,GAAtB,EAA2B,EAA3B,CALkB;AAMvBG,gBAAAA,GAAG,EAAEtB,MAAM,CAACuB,UAAP,CAAkBP,KAAK,CAAC,MAAD,CAAvB,CANkB;AAOvBQ,gBAAAA,MAAM,EAAExB,MAAM,CAACuB,UAAP,CAAkBP,KAAK,CAAC,MAAD,CAAvB;AAPe,eAAnB;AAAA,aAFC,CAtBwB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAvBd,uBAAuB;AAAA;AAAA;AAAA,GAA7B;;AAmCA,IAAMuB,4BAA4B,GAAG,0BAArC;AAEA,IAAMC,QAAQ,GAAG,kCAAjB,C,CAEA;;AACA,IAAMC,aAAa,4BAAG,+FAAH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAAnB;;AAEA,IAAMC,oBAAoB;AAAA,wEAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAOzB,YAAAA,OAAP,8DAAiB,EAAjB;AACtBC,YAAAA,KADsB,GACdD,OAAO,CAACE,GAAR,KAAgB,KAAhB,GAAwB,MAAxB,GAAiC,OADnB,EAG5B;;AAH4B;AAAA,mBAIE,IAAIE,OAAJ,CAAY,UAACsB,OAAD,EAAUC,MAAV,EAAqB;AAC9D,kBAAMC,KAAK,GAAGjD,YAAY,CAACE,QAAb,CAAsB,IAAtB,EAA4B,CAACoB,KAAD,EAAQsB,QAAR,CAA5B,EAA+C;AAACpC,gBAAAA,SAAS,EAAEP;AAAZ,eAA/C,EAA2E,UAACiD,KAAD,EAAQxC,MAAR,EAAmB;AAC3G,oBAAIwC,KAAK,KAAK,IAAd,EAAoB;AACnBH,kBAAAA,OAAO,CAAC,CAACE,KAAK,CAACjC,GAAP,EAAYN,MAAZ,CAAD,CAAP;AACA,iBAFD,MAEO;AACNsC,kBAAAA,MAAM,CAACE,KAAD,CAAN;AACA;AACD,eANa,CAAd;AAOA,aAR6B,CAJF;;AAAA;AAAA;AAAA;AAIrBC,YAAAA,KAJqB;AAIdzC,YAAAA,MAJc;AActB0C,YAAAA,KAdsB,GAcd1C,MAAM,CAACC,IAAP,GAAcC,KAAd,CAAoB,IAApB,CAdc;AAe5BwC,YAAAA,KAAK,CAACC,KAAN;AAMMC,YAAAA,SArBsB,GAqBVF,KAAK,CAACvC,GAAN,CAAU,UAACC,IAAD,EAAOyC,KAAP,EAAiB;AAC5C,kBAAMC,KAAK,GAAGX,aAAa,CAACY,IAAd,CAAmB3C,IAAnB,CAAd;;AACA,kBAAI0C,KAAK,KAAK,IAAd,EAAoB;AACnB,sBAAM,IAAIE,KAAJ,CAAUf,4BAAV,CAAN;AACA;;AAED,kCAAsCa,KAAK,CAACG,MAA5C;AAAA,kBAAO3C,GAAP,iBAAOA,GAAP;AAAA,kBAAYC,IAAZ,iBAAYA,IAAZ;AAAA,kBAAkBoB,GAAlB,iBAAkBA,GAAlB;AAAA,kBAAuBG,GAAvB,iBAAuBA,GAAvB;AAAA,kBAA4BE,MAA5B,iBAA4BA,MAA5B;AAEA,kBAAMkB,WAAW,GAAG;AACnB5C,gBAAAA,GAAG,EAAEE,MAAM,CAACC,QAAP,CAAgBH,GAAhB,EAAqB,EAArB,CADc;AAEnBC,gBAAAA,IAAI,EAAEC,MAAM,CAACC,QAAP,CAAgBF,IAAhB,EAAsB,EAAtB,CAFa;AAGnBoB,gBAAAA,GAAG,EAAEnB,MAAM,CAACC,QAAP,CAAgBkB,GAAhB,EAAqB,EAArB,CAHc;AAInBG,gBAAAA,GAAG,EAAEtB,MAAM,CAACuB,UAAP,CAAkBD,GAAlB,CAJc;AAKnBE,gBAAAA,MAAM,EAAExB,MAAM,CAACuB,UAAP,CAAkBC,MAAlB,CALW;AAMnB3B,gBAAAA,IAAI,EAAEe,SANa;AAOnBJ,gBAAAA,GAAG,EAAEI;AAPc,eAApB;;AAUA,kBAAI8B,WAAW,CAAC5C,GAAZ,KAAoBmC,KAAxB,EAA+B;AAC9BU,gBAAAA,OAAO,GAAGN,KAAV;AACAO,gBAAAA,YAAY,GAAGhD,IAAI,CAACiD,OAAL,CAAa,IAAb,EAAmBP,KAAK,CAAC,CAAD,CAAL,CAAS3B,MAA5B,CAAf;AACAmC,gBAAAA,YAAY,GAAGlD,IAAI,CAACiD,OAAL,CAAa,IAAb,EAAmBD,YAAY,GAAG,CAAlC,CAAf;AACA;;AAED,qBAAOF,WAAP;AACA,aAzBiB,CArBU;;AAAA,kBAgDxBC,OAAO,KAAK/B,SAAZ,IAAyBgC,YAAY,KAAK,CAAC,CAA3C,IAAgDE,YAAY,KAAK,CAAC,CAhD1C;AAAA;AAAA;AAAA;;AAAA,kBAiDrB,IAAIN,KAAJ,CAAUf,4BAAV,CAjDqB;;AAAA;AAoDtBsB,YAAAA,UApDsB,GAoDTD,YAAY,GAAGF,YApDN;AAAA,oDAqDAV,KAAK,CAACpB,OAAN,EArDA;;AAAA;AAqD5B,qEAA6C;AAAA,gEAAjCuB,KAAiC,oBAA1BzC,IAA0B;AAC5CwC,gBAAAA,SAAS,CAACC,KAAD,CAAT,CAAiBxC,IAAjB,GAAwBD,IAAI,CAACa,KAAL,CAAWmC,YAAX,EAAyBA,YAAY,GAAGG,UAAxC,EAAoDtD,IAApD,EAAxB;AACA2C,gBAAAA,SAAS,CAACC,KAAD,CAAT,CAAiB7B,GAAjB,GAAuBZ,IAAI,CAACa,KAAL,CAAWqC,YAAX,EAAyBrD,IAAzB,EAAvB;AACA;AAxD2B;AAAA;AAAA;AAAA;AAAA;;AA0D5B2C,YAAAA,SAAS,CAACY,MAAV,CAAiBL,OAAjB,EAA0B,CAA1B;AA1D4B,8CA2DrBP,SA3DqB;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAApBR,oBAAoB;AAAA;AAAA;AAAA,GAA1B;;AA8DA,IAAMqB,UAAU;AAAA,wEAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO9C,YAAAA,OAAP,8DAAiB,EAAjB;AAAA;AAAA;AAAA,mBAEJyB,oBAAoB,CAACzB,OAAD,CAFhB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,8CAIVD,uBAAuB,CAACC,OAAD,CAJb;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAV8C,UAAU;AAAA;AAAA;AAAA,GAAhB;;AAQAC,MAAM,CAACC,OAAP,GAAiBC,OAAO,CAACC,QAAR,KAAqB,OAArB,GAA+BnE,OAA/B,GAAyC+D,UAA1D","sourcesContent":["'use strict';\nconst util = require('util');\nconst path = require('path');\nconst childProcess = require('child_process');\n\nconst TEN_MEGABYTES = 1000 * 1000 * 10;\nconst execFile = util.promisify(childProcess.execFile);\n\nconst windows = async () => {\n\t// Source: https://github.com/MarkTiedemann/fastlist\n\tconst bin = path.join(__dirname, 'fastlist.exe');\n\n\tconst {stdout} = await execFile(bin, {\n\t\tmaxBuffer: TEN_MEGABYTES,\n\t\twindowsHide: true\n\t});\n\n\treturn stdout\n\t\t.trim()\n\t\t.split('\\r\\n')\n\t\t.map(line => line.split('\\t'))\n\t\t.map(([name, pid, ppid]) => ({\n\t\t\tname,\n\t\t\tpid: Number.parseInt(pid, 10),\n\t\t\tppid: Number.parseInt(ppid, 10)\n\t\t}));\n};\n\nconst nonWindowsMultipleCalls = async (options = {}) => {\n\tconst flags = (options.all === false ? '' : 'a') + 'wwxo';\n\tconst ret = {};\n\n\tawait Promise.all(['comm', 'args', 'ppid', 'uid', '%cpu', '%mem'].map(async cmd => {\n\t\tconst {stdout} = await execFile('ps', [flags, `pid,${cmd}`], {maxBuffer: TEN_MEGABYTES});\n\n\t\tfor (let line of stdout.trim().split('\\n').slice(1)) {\n\t\t\tline = line.trim();\n\t\t\tconst [pid] = line.split(' ', 1);\n\t\t\tconst val = line.slice(pid.length + 1).trim();\n\n\t\t\tif (ret[pid] === undefined) {\n\t\t\t\tret[pid] = {};\n\t\t\t}\n\n\t\t\tret[pid][cmd] = val;\n\t\t}\n\t}));\n\n\t// Filter out inconsistencies as there might be race\n\t// issues due to differences in `ps` between the spawns\n\treturn Object.entries(ret)\n\t\t.filter(([, value]) => value.comm && value.args && value.ppid && value.uid && value['%cpu'] && value['%mem'])\n\t\t.map(([key, value]) => ({\n\t\t\tpid: Number.parseInt(key, 10),\n\t\t\tname: path.basename(value.comm),\n\t\t\tcmd: value.args,\n\t\t\tppid: Number.parseInt(value.ppid, 10),\n\t\t\tuid: Number.parseInt(value.uid, 10),\n\t\t\tcpu: Number.parseFloat(value['%cpu']),\n\t\t\tmemory: Number.parseFloat(value['%mem'])\n\t\t}));\n};\n\nconst ERROR_MESSAGE_PARSING_FAILED = 'ps output parsing failed';\n\nconst psFields = 'pid,ppid,uid,%cpu,%mem,comm,args';\n\n// TODO: Use named capture groups when targeting Node.js 10\nconst psOutputRegex = /^[ \\t]*(?<pid>\\d+)[ \\t]+(?<ppid>\\d+)[ \\t]+(?<uid>\\d+)[ \\t]+(?<cpu>\\d+\\.\\d+)[ \\t]+(?<memory>\\d+\\.\\d+)[ \\t]+/;\n\nconst nonWindowsSingleCall = async (options = {}) => {\n\tconst flags = options.all === false ? 'wwxo' : 'awwxo';\n\n\t// TODO: Use the promise version of `execFile` when https://github.com/nodejs/node/issues/28244 is fixed.\n\tconst [psPid, stdout] = await new Promise((resolve, reject) => {\n\t\tconst child = childProcess.execFile('ps', [flags, psFields], {maxBuffer: TEN_MEGABYTES}, (error, stdout) => {\n\t\t\tif (error === null) {\n\t\t\t\tresolve([child.pid, stdout]);\n\t\t\t} else {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t});\n\n\tconst lines = stdout.trim().split('\\n');\n\tlines.shift();\n\n\tlet psIndex;\n\tlet commPosition;\n\tlet argsPosition;\n\n\tconst processes = lines.map((line, index) => {\n\t\tconst match = psOutputRegex.exec(line);\n\t\tif (match === null) {\n\t\t\tthrow new Error(ERROR_MESSAGE_PARSING_FAILED);\n\t\t}\n\n\t\tconst {pid, ppid, uid, cpu, memory} = match.groups;\n\n\t\tconst processInfo = {\n\t\t\tpid: Number.parseInt(pid, 10),\n\t\t\tppid: Number.parseInt(ppid, 10),\n\t\t\tuid: Number.parseInt(uid, 10),\n\t\t\tcpu: Number.parseFloat(cpu),\n\t\t\tmemory: Number.parseFloat(memory),\n\t\t\tname: undefined,\n\t\t\tcmd: undefined\n\t\t};\n\n\t\tif (processInfo.pid === psPid) {\n\t\t\tpsIndex = index;\n\t\t\tcommPosition = line.indexOf('ps', match[0].length);\n\t\t\targsPosition = line.indexOf('ps', commPosition + 2);\n\t\t}\n\n\t\treturn processInfo;\n\t});\n\n\tif (psIndex === undefined || commPosition === -1 || argsPosition === -1) {\n\t\tthrow new Error(ERROR_MESSAGE_PARSING_FAILED);\n\t}\n\n\tconst commLength = argsPosition - commPosition;\n\tfor (const [index, line] of lines.entries()) {\n\t\tprocesses[index].name = line.slice(commPosition, commPosition + commLength).trim();\n\t\tprocesses[index].cmd = line.slice(argsPosition).trim();\n\t}\n\n\tprocesses.splice(psIndex, 1);\n\treturn processes;\n};\n\nconst nonWindows = async (options = {}) => {\n\ttry {\n\t\treturn await nonWindowsSingleCall(options);\n\t} catch (_) { // If the error is not a parsing error, it should manifest itself in multicall version too.\n\t\treturn nonWindowsMultipleCalls(options);\n\t}\n};\n\nmodule.exports = process.platform === 'win32' ? windows : nonWindows;\n"]},"metadata":{},"sourceType":"script"}