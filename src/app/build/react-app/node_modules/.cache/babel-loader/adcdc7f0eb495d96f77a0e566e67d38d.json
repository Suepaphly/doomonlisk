{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isEmptyMessage = exports.validatePacket = exports.validateProtocolMessage = exports.validateRPCRequest = exports.validatePeerInfoList = exports.validatePayloadSize = exports.validatePeerInfo = exports.validatePeerAddress = exports.validatePeerCompatibility = void 0;\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nvar constants_1 = require(\"../constants\");\n\nvar errors_1 = require(\"../errors\");\n\nvar _1 = require(\".\");\n\nvar schemas_1 = require(\"./schemas\");\n\nvar validateNetworkCompatibility = function validateNetworkCompatibility(peerInfo, nodeInfo) {\n  if (!peerInfo.sharedState) {\n    return false;\n  }\n\n  if (!peerInfo.sharedState.networkIdentifier) {\n    return false;\n  }\n\n  return peerInfo.sharedState.networkIdentifier === nodeInfo.networkIdentifier;\n};\n\nvar validateNetworkVersionCompatibility = function validateNetworkVersionCompatibility(peerInfo, nodeInfo) {\n  if (!peerInfo.sharedState) {\n    return false;\n  }\n\n  if (typeof peerInfo.sharedState.networkVersion !== 'string') {\n    return false;\n  }\n\n  var peerHardForks = parseInt(peerInfo.sharedState.networkVersion.split('.')[0], 10);\n  var systemHardForks = parseInt(nodeInfo.networkVersion.split('.')[0], 10);\n  return systemHardForks === peerHardForks && peerHardForks >= 1;\n};\n\nvar validatePeerCompatibility = function validatePeerCompatibility(peerInfo, nodeInfo) {\n  if (!validateNetworkCompatibility(peerInfo, nodeInfo)) {\n    return {\n      success: false,\n      error: constants_1.INCOMPATIBLE_NETWORK_REASON\n    };\n  }\n\n  if (!validateNetworkVersionCompatibility(peerInfo, nodeInfo)) {\n    return {\n      success: false,\n      error: constants_1.INCOMPATIBLE_PROTOCOL_VERSION_REASON\n    };\n  }\n\n  return {\n    success: true\n  };\n};\n\nexports.validatePeerCompatibility = validatePeerCompatibility;\n\nvar validatePeerAddress = function validatePeerAddress(ipAddress, port) {\n  if (!lisk_validator_1.isIPV4(ipAddress) || !lisk_validator_1.isPort(port.toString())) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.validatePeerAddress = validatePeerAddress;\n\nvar validatePeerInfo = function validatePeerInfo(peerInfo, maxByteSize) {\n  if (!peerInfo) {\n    throw new errors_1.InvalidPeerInfoError('Invalid peer object');\n  }\n\n  if (!peerInfo.ipAddress || !peerInfo.port || !exports.validatePeerAddress(peerInfo.ipAddress, peerInfo.port)) {\n    throw new errors_1.InvalidPeerInfoError(\"Invalid peer ipAddress or port for peer with ip: \".concat(peerInfo.ipAddress, \" and port \").concat(peerInfo.port));\n  }\n\n  var byteSize = _1.getByteSize(peerInfo);\n\n  if (byteSize > maxByteSize) {\n    throw new errors_1.InvalidPeerInfoError(\"PeerInfo is larger than the maximum allowed size \".concat(maxByteSize, \" bytes\"));\n  }\n\n  return peerInfo;\n};\n\nexports.validatePeerInfo = validatePeerInfo;\n\nvar validatePayloadSize = function validatePayloadSize(nodeInfo, maxByteSize) {\n  if (nodeInfo === undefined) {\n    return;\n  }\n\n  if (_1.getByteSize(nodeInfo) > maxByteSize) {\n    throw new errors_1.InvalidNodeInfoError(\"Invalid NodeInfo was larger than the maximum allowed \".concat(maxByteSize, \" bytes\"));\n  }\n};\n\nexports.validatePayloadSize = validatePayloadSize;\n\nvar validatePeerInfoList = function validatePeerInfoList(peersList, maxPeerInfoListLength, maxPeerInfoByteSize) {\n  if (peersList.length > maxPeerInfoListLength) {\n    throw new errors_1.InvalidPeerInfoListError(constants_1.PEER_INFO_LIST_TOO_LONG_REASON);\n  }\n\n  peersList.map(function (peerInfo) {\n    return exports.validatePeerInfo(peerInfo, maxPeerInfoByteSize);\n  });\n};\n\nexports.validatePeerInfoList = validatePeerInfoList;\n\nvar validateRPCRequest = function validateRPCRequest(request) {\n  var errors = lisk_validator_1.validator.validate(schemas_1.rpcRequestSchema, request);\n\n  if (errors.length) {\n    throw new Error('RPC request format is invalid.');\n  }\n};\n\nexports.validateRPCRequest = validateRPCRequest;\n\nvar validateProtocolMessage = function validateProtocolMessage(message) {\n  var errors = lisk_validator_1.validator.validate(schemas_1.protocolMessageSchema, message);\n\n  if (errors.length) {\n    throw new Error('Protocol message format is invalid.');\n  }\n};\n\nexports.validateProtocolMessage = validateProtocolMessage;\n\nvar validatePacket = function validatePacket(packet) {\n  var errors = lisk_validator_1.validator.validate(schemas_1.packetSchema, packet);\n\n  if (errors.length) {\n    throw new Error('Packet format is invalid.');\n  }\n};\n\nexports.validatePacket = validatePacket;\n\nvar isEmptyMessage = function isEmptyMessage(data) {\n  if (data === undefined || data === null) {\n    return true;\n  }\n\n  if (typeof data === 'object' && !Array.isArray(data) && Object.keys(data).length === 0) {\n    return true;\n  }\n\n  if (Array.isArray(data) && data.length === 0) {\n    return true;\n  }\n\n  return false;\n};\n\nexports.isEmptyMessage = isEmptyMessage;","map":{"version":3,"sources":["../../src/utils/validate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isEmptyMessage = exports.validatePacket = exports.validateProtocolMessage = exports.validateRPCRequest = exports.validatePeerInfoList = exports.validatePayloadSize = exports.validatePeerInfo = exports.validatePeerAddress = exports.validatePeerCompatibility = void 0;\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst constants_1 = require(\"../constants\");\nconst errors_1 = require(\"../errors\");\nconst _1 = require(\".\");\nconst schemas_1 = require(\"./schemas\");\nconst validateNetworkCompatibility = (peerInfo, nodeInfo) => {\n    if (!peerInfo.sharedState) {\n        return false;\n    }\n    if (!peerInfo.sharedState.networkIdentifier) {\n        return false;\n    }\n    return peerInfo.sharedState.networkIdentifier === nodeInfo.networkIdentifier;\n};\nconst validateNetworkVersionCompatibility = (peerInfo, nodeInfo) => {\n    if (!peerInfo.sharedState) {\n        return false;\n    }\n    if (typeof peerInfo.sharedState.networkVersion !== 'string') {\n        return false;\n    }\n    const peerHardForks = parseInt(peerInfo.sharedState.networkVersion.split('.')[0], 10);\n    const systemHardForks = parseInt(nodeInfo.networkVersion.split('.')[0], 10);\n    return systemHardForks === peerHardForks && peerHardForks >= 1;\n};\nconst validatePeerCompatibility = (peerInfo, nodeInfo) => {\n    if (!validateNetworkCompatibility(peerInfo, nodeInfo)) {\n        return {\n            success: false,\n            error: constants_1.INCOMPATIBLE_NETWORK_REASON,\n        };\n    }\n    if (!validateNetworkVersionCompatibility(peerInfo, nodeInfo)) {\n        return {\n            success: false,\n            error: constants_1.INCOMPATIBLE_PROTOCOL_VERSION_REASON,\n        };\n    }\n    return {\n        success: true,\n    };\n};\nexports.validatePeerCompatibility = validatePeerCompatibility;\nconst validatePeerAddress = (ipAddress, port) => {\n    if (!lisk_validator_1.isIPV4(ipAddress) || !lisk_validator_1.isPort(port.toString())) {\n        return false;\n    }\n    return true;\n};\nexports.validatePeerAddress = validatePeerAddress;\nconst validatePeerInfo = (peerInfo, maxByteSize) => {\n    if (!peerInfo) {\n        throw new errors_1.InvalidPeerInfoError('Invalid peer object');\n    }\n    if (!peerInfo.ipAddress ||\n        !peerInfo.port ||\n        !exports.validatePeerAddress(peerInfo.ipAddress, peerInfo.port)) {\n        throw new errors_1.InvalidPeerInfoError(`Invalid peer ipAddress or port for peer with ip: ${peerInfo.ipAddress} and port ${peerInfo.port}`);\n    }\n    const byteSize = _1.getByteSize(peerInfo);\n    if (byteSize > maxByteSize) {\n        throw new errors_1.InvalidPeerInfoError(`PeerInfo is larger than the maximum allowed size ${maxByteSize} bytes`);\n    }\n    return peerInfo;\n};\nexports.validatePeerInfo = validatePeerInfo;\nconst validatePayloadSize = (nodeInfo, maxByteSize) => {\n    if (nodeInfo === undefined) {\n        return;\n    }\n    if (_1.getByteSize(nodeInfo) > maxByteSize) {\n        throw new errors_1.InvalidNodeInfoError(`Invalid NodeInfo was larger than the maximum allowed ${maxByteSize} bytes`);\n    }\n};\nexports.validatePayloadSize = validatePayloadSize;\nconst validatePeerInfoList = (peersList, maxPeerInfoListLength, maxPeerInfoByteSize) => {\n    if (peersList.length > maxPeerInfoListLength) {\n        throw new errors_1.InvalidPeerInfoListError(constants_1.PEER_INFO_LIST_TOO_LONG_REASON);\n    }\n    peersList.map(peerInfo => exports.validatePeerInfo(peerInfo, maxPeerInfoByteSize));\n};\nexports.validatePeerInfoList = validatePeerInfoList;\nconst validateRPCRequest = (request) => {\n    const errors = lisk_validator_1.validator.validate(schemas_1.rpcRequestSchema, request);\n    if (errors.length) {\n        throw new Error('RPC request format is invalid.');\n    }\n};\nexports.validateRPCRequest = validateRPCRequest;\nconst validateProtocolMessage = (message) => {\n    const errors = lisk_validator_1.validator.validate(schemas_1.protocolMessageSchema, message);\n    if (errors.length) {\n        throw new Error('Protocol message format is invalid.');\n    }\n};\nexports.validateProtocolMessage = validateProtocolMessage;\nconst validatePacket = (packet) => {\n    const errors = lisk_validator_1.validator.validate(schemas_1.packetSchema, packet);\n    if (errors.length) {\n        throw new Error('Packet format is invalid.');\n    }\n};\nexports.validatePacket = validatePacket;\nconst isEmptyMessage = (data) => {\n    if (data === undefined || data === null) {\n        return true;\n    }\n    if (typeof data === 'object' &&\n        !Array.isArray(data) &&\n        Object.keys(data).length === 0) {\n        return true;\n    }\n    if (Array.isArray(data) && data.length === 0) {\n        return true;\n    }\n    return false;\n};\nexports.isEmptyMessage = isEmptyMessage;\n//# sourceMappingURL=validate.js.map"]},"metadata":{},"sourceType":"script"}