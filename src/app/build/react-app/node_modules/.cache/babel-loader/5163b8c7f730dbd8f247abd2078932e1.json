{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readSInt64 = exports.readSInt32 = exports.readUInt64 = exports.readUInt32 = exports.writeSInt64 = exports.writeUInt64 = exports.writeSInt32 = exports.writeUInt32 = void 0;\nvar msg = 0x80;\nvar rest = 0x7f;\n\nvar writeUInt32 = function writeUInt32(value) {\n  var result = [];\n  var index = 0;\n\n  while (value > rest) {\n    result[index] = msg | (value & rest) >>> 0;\n    value = value >>> 7 >>> 0;\n    index += 1;\n  }\n\n  result[index] = value;\n  return Buffer.from(result);\n};\n\nexports.writeUInt32 = writeUInt32;\n\nvar writeSInt32 = function writeSInt32(value) {\n  if (value >= 0) {\n    return exports.writeUInt32(2 * value);\n  }\n\n  return exports.writeUInt32(-2 * value - 1);\n};\n\nexports.writeSInt32 = writeSInt32;\n\nvar writeUInt64 = function writeUInt64(value) {\n  var result = [];\n  var index = 0;\n\n  while (value > BigInt(rest)) {\n    result[index] = Number(BigInt(msg) | value & BigInt(rest));\n    value >>= BigInt(7);\n    index += 1;\n  }\n\n  result[Number(index)] = Number(value);\n  return Buffer.from(result);\n};\n\nexports.writeUInt64 = writeUInt64;\n\nvar writeSInt64 = function writeSInt64(value) {\n  if (value >= BigInt(0)) {\n    return exports.writeUInt64(BigInt(2) * value);\n  }\n\n  return exports.writeUInt64(BigInt(-2) * value - BigInt(1));\n};\n\nexports.writeSInt64 = writeSInt64;\n\nvar readUInt32 = function readUInt32(buffer, offset) {\n  var result = 0;\n  var index = offset;\n\n  for (var shift = 0; shift < 32; shift += 7) {\n    if (index >= buffer.length) {\n      throw new Error('Invalid buffer length');\n    }\n\n    var bit = buffer[index];\n    index += 1;\n\n    if (index === offset + 5 && bit > 0x0f) {\n      throw new Error('Value out of range of uint32');\n    }\n\n    result = (result | (bit & rest) << shift) >>> 0;\n\n    if ((bit & msg) === 0) {\n      return [result, index - offset];\n    }\n  }\n\n  throw new Error('Terminating bit not found');\n};\n\nexports.readUInt32 = readUInt32;\n\nvar readUInt64 = function readUInt64(buffer, offset) {\n  var result = BigInt(0);\n  var index = offset;\n\n  for (var shift = BigInt(0); shift < BigInt(64); shift += BigInt(7)) {\n    if (index >= buffer.length) {\n      throw new Error('Invalid buffer length');\n    }\n\n    var bit = BigInt(buffer[index]);\n    index += 1;\n\n    if (index === 10 + offset && bit > 0x01) {\n      throw new Error('Value out of range of uint64');\n    }\n\n    result |= (bit & BigInt(rest)) << shift;\n\n    if ((bit & BigInt(msg)) === BigInt(0)) {\n      return [result, index - offset];\n    }\n  }\n\n  throw new Error('Terminating bit not found');\n};\n\nexports.readUInt64 = readUInt64;\n\nvar readSInt32 = function readSInt32(buffer, offset) {\n  var _exports$readUInt = exports.readUInt32(buffer, offset),\n      _exports$readUInt2 = _slicedToArray(_exports$readUInt, 2),\n      varInt = _exports$readUInt2[0],\n      size = _exports$readUInt2[1];\n\n  if (varInt % 2 === 0) {\n    return [varInt / 2, size];\n  }\n\n  return [-(varInt + 1) / 2, size];\n};\n\nexports.readSInt32 = readSInt32;\n\nvar readSInt64 = function readSInt64(buffer, offset) {\n  var _exports$readUInt3 = exports.readUInt64(buffer, offset),\n      _exports$readUInt4 = _slicedToArray(_exports$readUInt3, 2),\n      varInt = _exports$readUInt4[0],\n      size = _exports$readUInt4[1];\n\n  if (varInt % BigInt(2) === BigInt(0)) {\n    return [varInt / BigInt(2), size];\n  }\n\n  return [-(varInt + BigInt(1)) / BigInt(2), size];\n};\n\nexports.readSInt64 = readSInt64;","map":{"version":3,"sources":["../src/varint.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readSInt64 = exports.readSInt32 = exports.readUInt64 = exports.readUInt32 = exports.writeSInt64 = exports.writeUInt64 = exports.writeSInt32 = exports.writeUInt32 = void 0;\nconst msg = 0x80;\nconst rest = 0x7f;\nconst writeUInt32 = (value) => {\n    const result = [];\n    let index = 0;\n    while (value > rest) {\n        result[index] = msg | ((value & rest) >>> 0);\n        value = (value >>> 7) >>> 0;\n        index += 1;\n    }\n    result[index] = value;\n    return Buffer.from(result);\n};\nexports.writeUInt32 = writeUInt32;\nconst writeSInt32 = (value) => {\n    if (value >= 0) {\n        return exports.writeUInt32(2 * value);\n    }\n    return exports.writeUInt32(-2 * value - 1);\n};\nexports.writeSInt32 = writeSInt32;\nconst writeUInt64 = (value) => {\n    const result = [];\n    let index = 0;\n    while (value > BigInt(rest)) {\n        result[index] = Number(BigInt(msg) | (value & BigInt(rest)));\n        value >>= BigInt(7);\n        index += 1;\n    }\n    result[Number(index)] = Number(value);\n    return Buffer.from(result);\n};\nexports.writeUInt64 = writeUInt64;\nconst writeSInt64 = (value) => {\n    if (value >= BigInt(0)) {\n        return exports.writeUInt64(BigInt(2) * value);\n    }\n    return exports.writeUInt64(BigInt(-2) * value - BigInt(1));\n};\nexports.writeSInt64 = writeSInt64;\nconst readUInt32 = (buffer, offset) => {\n    let result = 0;\n    let index = offset;\n    for (let shift = 0; shift < 32; shift += 7) {\n        if (index >= buffer.length) {\n            throw new Error('Invalid buffer length');\n        }\n        const bit = buffer[index];\n        index += 1;\n        if (index === offset + 5 && bit > 0x0f) {\n            throw new Error('Value out of range of uint32');\n        }\n        result = (result | ((bit & rest) << shift)) >>> 0;\n        if ((bit & msg) === 0) {\n            return [result, index - offset];\n        }\n    }\n    throw new Error('Terminating bit not found');\n};\nexports.readUInt32 = readUInt32;\nconst readUInt64 = (buffer, offset) => {\n    let result = BigInt(0);\n    let index = offset;\n    for (let shift = BigInt(0); shift < BigInt(64); shift += BigInt(7)) {\n        if (index >= buffer.length) {\n            throw new Error('Invalid buffer length');\n        }\n        const bit = BigInt(buffer[index]);\n        index += 1;\n        if (index === 10 + offset && bit > 0x01) {\n            throw new Error('Value out of range of uint64');\n        }\n        result |= (bit & BigInt(rest)) << shift;\n        if ((bit & BigInt(msg)) === BigInt(0)) {\n            return [result, index - offset];\n        }\n    }\n    throw new Error('Terminating bit not found');\n};\nexports.readUInt64 = readUInt64;\nconst readSInt32 = (buffer, offset) => {\n    const [varInt, size] = exports.readUInt32(buffer, offset);\n    if (varInt % 2 === 0) {\n        return [varInt / 2, size];\n    }\n    return [-(varInt + 1) / 2, size];\n};\nexports.readSInt32 = readSInt32;\nconst readSInt64 = (buffer, offset) => {\n    const [varInt, size] = exports.readUInt64(buffer, offset);\n    if (varInt % BigInt(2) === BigInt(0)) {\n        return [varInt / BigInt(2), size];\n    }\n    return [-(varInt + BigInt(1)) / BigInt(2), size];\n};\nexports.readSInt64 = readSInt64;\n//# sourceMappingURL=varint.js.map"]},"metadata":{},"sourceType":"script"}