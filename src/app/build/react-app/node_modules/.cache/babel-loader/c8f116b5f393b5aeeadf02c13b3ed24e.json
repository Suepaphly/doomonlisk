{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getForgerInfo = exports.setForgerInfo = exports.setForgerSyncInfo = exports.getForgerSyncInfo = exports.getDBInstance = void 0;\n\nvar createDebug = require(\"debug\");\n\nvar lisk_db_1 = require(\"@liskhq/lisk-db\");\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar os = require(\"os\");\n\nvar path_1 = require(\"path\");\n\nvar fs_extra_1 = require(\"fs-extra\");\n\nvar constants_1 = require(\"./constants\");\n\nvar schema_1 = require(\"./schema\");\n\nvar debug = createDebug('plugin:forger:db');\n\nvar getDBInstance = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dataPath) {\n    var dbName,\n        dirPath,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            dbName = _args.length > 1 && _args[1] !== undefined ? _args[1] : 'lisk-framework-forger-plugin.db';\n            dirPath = path_1.join(dataPath.replace('~', os.homedir()), 'plugins/data', dbName);\n            _context.next = 4;\n            return fs_extra_1.ensureDir(dirPath);\n\n          case 4:\n            return _context.abrupt(\"return\", new lisk_db_1.KVStore(dirPath));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getDBInstance(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.getDBInstance = getDBInstance;\n\nvar getForgerSyncInfo = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(db) {\n    var encodedSyncInfo;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return db.get(constants_1.DB_KEY_FORGER_SYNC_INFO);\n\n          case 3:\n            encodedSyncInfo = _context2.sent;\n            return _context2.abrupt(\"return\", lisk_codec_1.codec.decode(schema_1.forgerSyncSchema, encodedSyncInfo));\n\n          case 7:\n            _context2.prev = 7;\n            _context2.t0 = _context2[\"catch\"](0);\n            debug('Forger sync info does not exists');\n            return _context2.abrupt(\"return\", {\n              syncUptoHeight: 0\n            });\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 7]]);\n  }));\n\n  return function getForgerSyncInfo(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.getForgerSyncInfo = getForgerSyncInfo;\n\nvar setForgerSyncInfo = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(db, blockHeight) {\n    var encodedSyncInfo;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            encodedSyncInfo = lisk_codec_1.codec.encode(schema_1.forgerSyncSchema, {\n              syncUptoHeight: blockHeight\n            });\n            _context3.next = 3;\n            return db.put(constants_1.DB_KEY_FORGER_SYNC_INFO, encodedSyncInfo);\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function setForgerSyncInfo(_x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.setForgerSyncInfo = setForgerSyncInfo;\n\nvar setForgerInfo = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(db, forgerAddress, forgerInfo) {\n    var encodedForgerInfo;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            encodedForgerInfo = lisk_codec_1.codec.encode(schema_1.forgerInfoSchema, forgerInfo);\n            _context4.next = 3;\n            return db.put(\"\".concat(constants_1.DB_KEY_FORGER_INFO, \":\").concat(forgerAddress), encodedForgerInfo);\n\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function setForgerInfo(_x5, _x6, _x7) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.setForgerInfo = setForgerInfo;\n\nvar getForgerInfo = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(db, forgerAddress) {\n    var forgerInfo;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.prev = 0;\n            _context5.next = 3;\n            return db.get(\"\".concat(constants_1.DB_KEY_FORGER_INFO, \":\").concat(forgerAddress));\n\n          case 3:\n            forgerInfo = _context5.sent;\n            _context5.next = 10;\n            break;\n\n          case 6:\n            _context5.prev = 6;\n            _context5.t0 = _context5[\"catch\"](0);\n            debug(\"Forger info does not exists for delegate: \".concat(forgerAddress));\n            return _context5.abrupt(\"return\", {\n              totalProducedBlocks: 0,\n              totalReceivedFees: BigInt(0),\n              totalReceivedRewards: BigInt(0),\n              votesReceived: []\n            });\n\n          case 10:\n            return _context5.abrupt(\"return\", lisk_codec_1.codec.decode(schema_1.forgerInfoSchema, forgerInfo));\n\n          case 11:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[0, 6]]);\n  }));\n\n  return function getForgerInfo(_x8, _x9) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexports.getForgerInfo = getForgerInfo;","map":{"version":3,"sources":["../src/db.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getForgerInfo = exports.setForgerInfo = exports.setForgerSyncInfo = exports.getForgerSyncInfo = exports.getDBInstance = void 0;\nconst createDebug = require(\"debug\");\nconst lisk_db_1 = require(\"@liskhq/lisk-db\");\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst os = require(\"os\");\nconst path_1 = require(\"path\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst constants_1 = require(\"./constants\");\nconst schema_1 = require(\"./schema\");\nconst debug = createDebug('plugin:forger:db');\nconst getDBInstance = async (dataPath, dbName = 'lisk-framework-forger-plugin.db') => {\n    const dirPath = path_1.join(dataPath.replace('~', os.homedir()), 'plugins/data', dbName);\n    await fs_extra_1.ensureDir(dirPath);\n    return new lisk_db_1.KVStore(dirPath);\n};\nexports.getDBInstance = getDBInstance;\nconst getForgerSyncInfo = async (db) => {\n    try {\n        const encodedSyncInfo = await db.get(constants_1.DB_KEY_FORGER_SYNC_INFO);\n        return lisk_codec_1.codec.decode(schema_1.forgerSyncSchema, encodedSyncInfo);\n    }\n    catch (error) {\n        debug('Forger sync info does not exists');\n        return {\n            syncUptoHeight: 0,\n        };\n    }\n};\nexports.getForgerSyncInfo = getForgerSyncInfo;\nconst setForgerSyncInfo = async (db, blockHeight) => {\n    const encodedSyncInfo = lisk_codec_1.codec.encode(schema_1.forgerSyncSchema, { syncUptoHeight: blockHeight });\n    await db.put(constants_1.DB_KEY_FORGER_SYNC_INFO, encodedSyncInfo);\n};\nexports.setForgerSyncInfo = setForgerSyncInfo;\nconst setForgerInfo = async (db, forgerAddress, forgerInfo) => {\n    const encodedForgerInfo = lisk_codec_1.codec.encode(schema_1.forgerInfoSchema, forgerInfo);\n    await db.put(`${constants_1.DB_KEY_FORGER_INFO}:${forgerAddress}`, encodedForgerInfo);\n};\nexports.setForgerInfo = setForgerInfo;\nconst getForgerInfo = async (db, forgerAddress) => {\n    let forgerInfo;\n    try {\n        forgerInfo = await db.get(`${constants_1.DB_KEY_FORGER_INFO}:${forgerAddress}`);\n    }\n    catch (error) {\n        debug(`Forger info does not exists for delegate: ${forgerAddress}`);\n        return {\n            totalProducedBlocks: 0,\n            totalReceivedFees: BigInt(0),\n            totalReceivedRewards: BigInt(0),\n            votesReceived: [],\n        };\n    }\n    return lisk_codec_1.codec.decode(schema_1.forgerInfoSchema, forgerInfo);\n};\nexports.getForgerInfo = getForgerInfo;\n//# sourceMappingURL=db.js.map"]},"metadata":{},"sourceType":"script"}