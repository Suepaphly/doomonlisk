{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WSServer = void 0;\n\nvar WebSocket = require(\"ws\");\n\nvar WSServer = /*#__PURE__*/function () {\n  function WSServer(options) {\n    _classCallCheck(this, WSServer);\n\n    this.port = options.port;\n    this.host = options.host;\n    this.path = options.path;\n    this.logger = options.logger;\n  }\n\n  _createClass(WSServer, [{\n    key: \"start\",\n    value: function start(messageHandler) {\n      var _this = this;\n\n      this.server = new WebSocket.Server({\n        path: this.path,\n        port: this.port,\n        host: this.host,\n        clientTracking: true\n      });\n      this.server.on('connection', function (socket) {\n        return _this._handleConnection(socket, messageHandler);\n      });\n      this.server.on('error', function (error) {\n        _this.logger.error(error);\n      });\n      this.server.on('listening', function () {\n        _this.logger.info('Websocket Server Ready');\n      });\n      this.server.on('close', function () {\n        clearInterval(_this.pingTimer);\n      });\n      this.pingTimer = this._setUpPing();\n      return this.server;\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.server) {\n        this.server.close();\n      }\n    }\n  }, {\n    key: \"broadcast\",\n    value: function broadcast(message) {\n      var _iterator = _createForOfIteratorHelper(this.server.clients),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var client = _step.value;\n\n          if (client.readyState === WebSocket.OPEN) {\n            client.send(message);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_handleConnection\",\n    value: function _handleConnection(socket, messageHandler) {\n      var _this2 = this;\n\n      socket.isAlive = true;\n      socket.on('message', function (message) {\n        return messageHandler(socket, message);\n      });\n      socket.on('pong', function () {\n        return _this2._handleHeartbeat(socket);\n      });\n      this.logger.info('New web socket client connected');\n    }\n  }, {\n    key: \"_handleHeartbeat\",\n    value: function _handleHeartbeat(socket) {\n      socket.isAlive = true;\n    }\n  }, {\n    key: \"_setUpPing\",\n    value: function _setUpPing() {\n      var _this3 = this;\n\n      return setInterval(function () {\n        var _iterator2 = _createForOfIteratorHelper(_this3.server.clients),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var socket = _step2.value;\n            var aClient = socket;\n\n            if (aClient.isAlive === false) {\n              return socket.terminate();\n            }\n\n            aClient.isAlive = false;\n            aClient.ping(function () {});\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return null;\n      }, 3000);\n    }\n  }]);\n\n  return WSServer;\n}();\n\nexports.WSServer = WSServer;","map":{"version":3,"sources":["../../../src/controller/ws/ws_server.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WSServer = void 0;\nconst WebSocket = require(\"ws\");\nclass WSServer {\n    constructor(options) {\n        this.port = options.port;\n        this.host = options.host;\n        this.path = options.path;\n        this.logger = options.logger;\n    }\n    start(messageHandler) {\n        this.server = new WebSocket.Server({\n            path: this.path,\n            port: this.port,\n            host: this.host,\n            clientTracking: true,\n        });\n        this.server.on('connection', socket => this._handleConnection(socket, messageHandler));\n        this.server.on('error', error => {\n            this.logger.error(error);\n        });\n        this.server.on('listening', () => {\n            this.logger.info('Websocket Server Ready');\n        });\n        this.server.on('close', () => {\n            clearInterval(this.pingTimer);\n        });\n        this.pingTimer = this._setUpPing();\n        return this.server;\n    }\n    stop() {\n        if (this.server) {\n            this.server.close();\n        }\n    }\n    broadcast(message) {\n        for (const client of this.server.clients) {\n            if (client.readyState === WebSocket.OPEN) {\n                client.send(message);\n            }\n        }\n    }\n    _handleConnection(socket, messageHandler) {\n        socket.isAlive = true;\n        socket.on('message', (message) => messageHandler(socket, message));\n        socket.on('pong', () => this._handleHeartbeat(socket));\n        this.logger.info('New web socket client connected');\n    }\n    _handleHeartbeat(socket) {\n        socket.isAlive = true;\n    }\n    _setUpPing() {\n        return setInterval(() => {\n            for (const socket of this.server.clients) {\n                const aClient = socket;\n                if (aClient.isAlive === false) {\n                    return socket.terminate();\n                }\n                aClient.isAlive = false;\n                aClient.ping(() => { });\n            }\n            return null;\n        }, 3000);\n    }\n}\nexports.WSServer = WSServer;\n//# sourceMappingURL=ws_server.js.map"]},"metadata":{},"sourceType":"script"}