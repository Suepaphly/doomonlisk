{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar fs = require('../fs');\n\nvar path = require('path');\n\nvar util = require('util');\n\nvar atLeastNode = require('at-least-node');\n\nvar nodeSupportsBigInt = atLeastNode('10.5.0');\n\nvar stat = function stat(file) {\n  return nodeSupportsBigInt ? fs.stat(file, {\n    bigint: true\n  }) : fs.stat(file);\n};\n\nvar statSync = function statSync(file) {\n  return nodeSupportsBigInt ? fs.statSync(file, {\n    bigint: true\n  }) : fs.statSync(file);\n};\n\nfunction getStats(src, dest) {\n  return Promise.all([stat(src), stat(dest).catch(function (err) {\n    if (err.code === 'ENOENT') return null;\n    throw err;\n  })]).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        srcStat = _ref2[0],\n        destStat = _ref2[1];\n\n    return {\n      srcStat: srcStat,\n      destStat: destStat\n    };\n  });\n}\n\nfunction getStatsSync(src, dest) {\n  var destStat;\n  var srcStat = statSync(src);\n\n  try {\n    destStat = statSync(dest);\n  } catch (err) {\n    if (err.code === 'ENOENT') return {\n      srcStat: srcStat,\n      destStat: null\n    };\n    throw err;\n  }\n\n  return {\n    srcStat: srcStat,\n    destStat: destStat\n  };\n}\n\nfunction checkPaths(src, dest, funcName, cb) {\n  util.callbackify(getStats)(src, dest, function (err, stats) {\n    if (err) return cb(err);\n    var srcStat = stats.srcStat,\n        destStat = stats.destStat;\n\n    if (destStat && areIdentical(srcStat, destStat)) {\n      return cb(new Error('Source and destination must not be the same.'));\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n\n    return cb(null, {\n      srcStat: srcStat,\n      destStat: destStat\n    });\n  });\n}\n\nfunction checkPathsSync(src, dest, funcName) {\n  var _getStatsSync = getStatsSync(src, dest),\n      srcStat = _getStatsSync.srcStat,\n      destStat = _getStatsSync.destStat;\n\n  if (destStat && areIdentical(srcStat, destStat)) {\n    throw new Error('Source and destination must not be the same.');\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n\n  return {\n    srcStat: srcStat,\n    destStat: destStat\n  };\n} // recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\n\n\nfunction checkParentPaths(src, srcStat, dest, funcName, cb) {\n  var srcParent = path.resolve(path.dirname(src));\n  var destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();\n\n  var callback = function callback(err, destStat) {\n    if (err) {\n      if (err.code === 'ENOENT') return cb();\n      return cb(err);\n    }\n\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n\n    return checkParentPaths(src, srcStat, destParent, funcName, cb);\n  };\n\n  if (nodeSupportsBigInt) fs.stat(destParent, {\n    bigint: true\n  }, callback);else fs.stat(destParent, callback);\n}\n\nfunction checkParentPathsSync(src, srcStat, dest, funcName) {\n  var srcParent = path.resolve(path.dirname(src));\n  var destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return;\n  var destStat;\n\n  try {\n    destStat = statSync(destParent);\n  } catch (err) {\n    if (err.code === 'ENOENT') return;\n    throw err;\n  }\n\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n\n  return checkParentPathsSync(src, srcStat, destParent, funcName);\n}\n\nfunction areIdentical(srcStat, destStat) {\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {\n      // definitive answer\n      return true;\n    } // Use additional heuristics if we can't use 'bigint'.\n    // Different 'ino' could be represented the same if they are >= Number.MAX_SAFE_INTEGER\n    // See issue 657\n\n\n    if (destStat.size === srcStat.size && destStat.mode === srcStat.mode && destStat.nlink === srcStat.nlink && destStat.atimeMs === srcStat.atimeMs && destStat.mtimeMs === srcStat.mtimeMs && destStat.ctimeMs === srcStat.ctimeMs && destStat.birthtimeMs === srcStat.birthtimeMs) {\n      // heuristic answer\n      return true;\n    }\n  }\n\n  return false;\n} // return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\n\n\nfunction isSrcSubdir(src, dest) {\n  var srcArr = path.resolve(src).split(path.sep).filter(function (i) {\n    return i;\n  });\n  var destArr = path.resolve(dest).split(path.sep).filter(function (i) {\n    return i;\n  });\n  return srcArr.reduce(function (acc, cur, i) {\n    return acc && destArr[i] === cur;\n  }, true);\n}\n\nfunction errMsg(src, dest, funcName) {\n  return \"Cannot \".concat(funcName, \" '\").concat(src, \"' to a subdirectory of itself, '\").concat(dest, \"'.\");\n}\n\nmodule.exports = {\n  checkPaths: checkPaths,\n  checkPathsSync: checkPathsSync,\n  checkParentPaths: checkParentPaths,\n  checkParentPathsSync: checkParentPathsSync,\n  isSrcSubdir: isSrcSubdir\n};","map":{"version":3,"sources":["/home/lisk/doomonlisk/node_modules/lisk-framework/node_modules/fs-extra/lib/util/stat.js"],"names":["fs","require","path","util","atLeastNode","nodeSupportsBigInt","stat","file","bigint","statSync","getStats","src","dest","Promise","all","catch","err","code","then","srcStat","destStat","getStatsSync","checkPaths","funcName","cb","callbackify","stats","areIdentical","Error","isDirectory","isSrcSubdir","errMsg","checkPathsSync","checkParentPaths","srcParent","resolve","dirname","destParent","parse","root","callback","checkParentPathsSync","ino","dev","Number","MAX_SAFE_INTEGER","size","mode","nlink","atimeMs","mtimeMs","ctimeMs","birthtimeMs","srcArr","split","sep","filter","i","destArr","reduce","acc","cur","module","exports"],"mappings":"AAAA;;;;AAEA,IAAMA,EAAE,GAAGC,OAAO,CAAC,OAAD,CAAlB;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,IAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMG,WAAW,GAAGH,OAAO,CAAC,eAAD,CAA3B;;AAEA,IAAMI,kBAAkB,GAAGD,WAAW,CAAC,QAAD,CAAtC;;AACA,IAAME,IAAI,GAAG,SAAPA,IAAO,CAACC,IAAD;AAAA,SAAUF,kBAAkB,GAAGL,EAAE,CAACM,IAAH,CAAQC,IAAR,EAAc;AAAEC,IAAAA,MAAM,EAAE;AAAV,GAAd,CAAH,GAAqCR,EAAE,CAACM,IAAH,CAAQC,IAAR,CAAjE;AAAA,CAAb;;AACA,IAAME,QAAQ,GAAG,SAAXA,QAAW,CAACF,IAAD;AAAA,SAAUF,kBAAkB,GAAGL,EAAE,CAACS,QAAH,CAAYF,IAAZ,EAAkB;AAAEC,IAAAA,MAAM,EAAE;AAAV,GAAlB,CAAH,GAAyCR,EAAE,CAACS,QAAH,CAAYF,IAAZ,CAArE;AAAA,CAAjB;;AAEA,SAASG,QAAT,CAAmBC,GAAnB,EAAwBC,IAAxB,EAA8B;AAC5B,SAAOC,OAAO,CAACC,GAAR,CAAY,CACjBR,IAAI,CAACK,GAAD,CADa,EAEjBL,IAAI,CAACM,IAAD,CAAJ,CAAWG,KAAX,CAAiB,UAAAC,GAAG,EAAI;AACtB,QAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B,OAAO,IAAP;AAC3B,UAAMD,GAAN;AACD,GAHD,CAFiB,CAAZ,EAMJE,IANI,CAMC;AAAA;AAAA,QAAEC,OAAF;AAAA,QAAWC,QAAX;;AAAA,WAA0B;AAAED,MAAAA,OAAO,EAAPA,OAAF;AAAWC,MAAAA,QAAQ,EAARA;AAAX,KAA1B;AAAA,GAND,CAAP;AAOD;;AAED,SAASC,YAAT,CAAuBV,GAAvB,EAA4BC,IAA5B,EAAkC;AAChC,MAAIQ,QAAJ;AACA,MAAMD,OAAO,GAAGV,QAAQ,CAACE,GAAD,CAAxB;;AACA,MAAI;AACFS,IAAAA,QAAQ,GAAGX,QAAQ,CAACG,IAAD,CAAnB;AACD,GAFD,CAEE,OAAOI,GAAP,EAAY;AACZ,QAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B,OAAO;AAAEE,MAAAA,OAAO,EAAPA,OAAF;AAAWC,MAAAA,QAAQ,EAAE;AAArB,KAAP;AAC3B,UAAMJ,GAAN;AACD;;AACD,SAAO;AAAEG,IAAAA,OAAO,EAAPA,OAAF;AAAWC,IAAAA,QAAQ,EAARA;AAAX,GAAP;AACD;;AAED,SAASE,UAAT,CAAqBX,GAArB,EAA0BC,IAA1B,EAAgCW,QAAhC,EAA0CC,EAA1C,EAA8C;AAC5CrB,EAAAA,IAAI,CAACsB,WAAL,CAAiBf,QAAjB,EAA2BC,GAA3B,EAAgCC,IAAhC,EAAsC,UAACI,GAAD,EAAMU,KAAN,EAAgB;AACpD,QAAIV,GAAJ,EAAS,OAAOQ,EAAE,CAACR,GAAD,CAAT;AACT,QAAQG,OAAR,GAA8BO,KAA9B,CAAQP,OAAR;AAAA,QAAiBC,QAAjB,GAA8BM,KAA9B,CAAiBN,QAAjB;;AACA,QAAIA,QAAQ,IAAIO,YAAY,CAACR,OAAD,EAAUC,QAAV,CAA5B,EAAiD;AAC/C,aAAOI,EAAE,CAAC,IAAII,KAAJ,CAAU,8CAAV,CAAD,CAAT;AACD;;AACD,QAAIT,OAAO,CAACU,WAAR,MAAyBC,WAAW,CAACnB,GAAD,EAAMC,IAAN,CAAxC,EAAqD;AACnD,aAAOY,EAAE,CAAC,IAAII,KAAJ,CAAUG,MAAM,CAACpB,GAAD,EAAMC,IAAN,EAAYW,QAAZ,CAAhB,CAAD,CAAT;AACD;;AACD,WAAOC,EAAE,CAAC,IAAD,EAAO;AAAEL,MAAAA,OAAO,EAAPA,OAAF;AAAWC,MAAAA,QAAQ,EAARA;AAAX,KAAP,CAAT;AACD,GAVD;AAWD;;AAED,SAASY,cAAT,CAAyBrB,GAAzB,EAA8BC,IAA9B,EAAoCW,QAApC,EAA8C;AAC5C,sBAA8BF,YAAY,CAACV,GAAD,EAAMC,IAAN,CAA1C;AAAA,MAAQO,OAAR,iBAAQA,OAAR;AAAA,MAAiBC,QAAjB,iBAAiBA,QAAjB;;AACA,MAAIA,QAAQ,IAAIO,YAAY,CAACR,OAAD,EAAUC,QAAV,CAA5B,EAAiD;AAC/C,UAAM,IAAIQ,KAAJ,CAAU,8CAAV,CAAN;AACD;;AACD,MAAIT,OAAO,CAACU,WAAR,MAAyBC,WAAW,CAACnB,GAAD,EAAMC,IAAN,CAAxC,EAAqD;AACnD,UAAM,IAAIgB,KAAJ,CAAUG,MAAM,CAACpB,GAAD,EAAMC,IAAN,EAAYW,QAAZ,CAAhB,CAAN;AACD;;AACD,SAAO;AAAEJ,IAAAA,OAAO,EAAPA,OAAF;AAAWC,IAAAA,QAAQ,EAARA;AAAX,GAAP;AACD,C,CAED;AACA;AACA;AACA;;;AACA,SAASa,gBAAT,CAA2BtB,GAA3B,EAAgCQ,OAAhC,EAAyCP,IAAzC,EAA+CW,QAA/C,EAAyDC,EAAzD,EAA6D;AAC3D,MAAMU,SAAS,GAAGhC,IAAI,CAACiC,OAAL,CAAajC,IAAI,CAACkC,OAAL,CAAazB,GAAb,CAAb,CAAlB;AACA,MAAM0B,UAAU,GAAGnC,IAAI,CAACiC,OAAL,CAAajC,IAAI,CAACkC,OAAL,CAAaxB,IAAb,CAAb,CAAnB;AACA,MAAIyB,UAAU,KAAKH,SAAf,IAA4BG,UAAU,KAAKnC,IAAI,CAACoC,KAAL,CAAWD,UAAX,EAAuBE,IAAtE,EAA4E,OAAOf,EAAE,EAAT;;AAC5E,MAAMgB,QAAQ,GAAG,SAAXA,QAAW,CAACxB,GAAD,EAAMI,QAAN,EAAmB;AAClC,QAAIJ,GAAJ,EAAS;AACP,UAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B,OAAOO,EAAE,EAAT;AAC3B,aAAOA,EAAE,CAACR,GAAD,CAAT;AACD;;AACD,QAAIW,YAAY,CAACR,OAAD,EAAUC,QAAV,CAAhB,EAAqC;AACnC,aAAOI,EAAE,CAAC,IAAII,KAAJ,CAAUG,MAAM,CAACpB,GAAD,EAAMC,IAAN,EAAYW,QAAZ,CAAhB,CAAD,CAAT;AACD;;AACD,WAAOU,gBAAgB,CAACtB,GAAD,EAAMQ,OAAN,EAAekB,UAAf,EAA2Bd,QAA3B,EAAqCC,EAArC,CAAvB;AACD,GATD;;AAUA,MAAInB,kBAAJ,EAAwBL,EAAE,CAACM,IAAH,CAAQ+B,UAAR,EAAoB;AAAE7B,IAAAA,MAAM,EAAE;AAAV,GAApB,EAAsCgC,QAAtC,EAAxB,KACKxC,EAAE,CAACM,IAAH,CAAQ+B,UAAR,EAAoBG,QAApB;AACN;;AAED,SAASC,oBAAT,CAA+B9B,GAA/B,EAAoCQ,OAApC,EAA6CP,IAA7C,EAAmDW,QAAnD,EAA6D;AAC3D,MAAMW,SAAS,GAAGhC,IAAI,CAACiC,OAAL,CAAajC,IAAI,CAACkC,OAAL,CAAazB,GAAb,CAAb,CAAlB;AACA,MAAM0B,UAAU,GAAGnC,IAAI,CAACiC,OAAL,CAAajC,IAAI,CAACkC,OAAL,CAAaxB,IAAb,CAAb,CAAnB;AACA,MAAIyB,UAAU,KAAKH,SAAf,IAA4BG,UAAU,KAAKnC,IAAI,CAACoC,KAAL,CAAWD,UAAX,EAAuBE,IAAtE,EAA4E;AAC5E,MAAInB,QAAJ;;AACA,MAAI;AACFA,IAAAA,QAAQ,GAAGX,QAAQ,CAAC4B,UAAD,CAAnB;AACD,GAFD,CAEE,OAAOrB,GAAP,EAAY;AACZ,QAAIA,GAAG,CAACC,IAAJ,KAAa,QAAjB,EAA2B;AAC3B,UAAMD,GAAN;AACD;;AACD,MAAIW,YAAY,CAACR,OAAD,EAAUC,QAAV,CAAhB,EAAqC;AACnC,UAAM,IAAIQ,KAAJ,CAAUG,MAAM,CAACpB,GAAD,EAAMC,IAAN,EAAYW,QAAZ,CAAhB,CAAN;AACD;;AACD,SAAOkB,oBAAoB,CAAC9B,GAAD,EAAMQ,OAAN,EAAekB,UAAf,EAA2Bd,QAA3B,CAA3B;AACD;;AAED,SAASI,YAAT,CAAuBR,OAAvB,EAAgCC,QAAhC,EAA0C;AACxC,MAAIA,QAAQ,CAACsB,GAAT,IAAgBtB,QAAQ,CAACuB,GAAzB,IAAgCvB,QAAQ,CAACsB,GAAT,KAAiBvB,OAAO,CAACuB,GAAzD,IAAgEtB,QAAQ,CAACuB,GAAT,KAAiBxB,OAAO,CAACwB,GAA7F,EAAkG;AAChG,QAAItC,kBAAkB,IAAIe,QAAQ,CAACsB,GAAT,GAAeE,MAAM,CAACC,gBAAhD,EAAkE;AAChE;AACA,aAAO,IAAP;AACD,KAJ+F,CAKhG;AACA;AACA;;;AACA,QAAIzB,QAAQ,CAAC0B,IAAT,KAAkB3B,OAAO,CAAC2B,IAA1B,IACA1B,QAAQ,CAAC2B,IAAT,KAAkB5B,OAAO,CAAC4B,IAD1B,IAEA3B,QAAQ,CAAC4B,KAAT,KAAmB7B,OAAO,CAAC6B,KAF3B,IAGA5B,QAAQ,CAAC6B,OAAT,KAAqB9B,OAAO,CAAC8B,OAH7B,IAIA7B,QAAQ,CAAC8B,OAAT,KAAqB/B,OAAO,CAAC+B,OAJ7B,IAKA9B,QAAQ,CAAC+B,OAAT,KAAqBhC,OAAO,CAACgC,OAL7B,IAMA/B,QAAQ,CAACgC,WAAT,KAAyBjC,OAAO,CAACiC,WANrC,EAMkD;AAChD;AACA,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD,C,CAED;AACA;;;AACA,SAAStB,WAAT,CAAsBnB,GAAtB,EAA2BC,IAA3B,EAAiC;AAC/B,MAAMyC,MAAM,GAAGnD,IAAI,CAACiC,OAAL,CAAaxB,GAAb,EAAkB2C,KAAlB,CAAwBpD,IAAI,CAACqD,GAA7B,EAAkCC,MAAlC,CAAyC,UAAAC,CAAC;AAAA,WAAIA,CAAJ;AAAA,GAA1C,CAAf;AACA,MAAMC,OAAO,GAAGxD,IAAI,CAACiC,OAAL,CAAavB,IAAb,EAAmB0C,KAAnB,CAAyBpD,IAAI,CAACqD,GAA9B,EAAmCC,MAAnC,CAA0C,UAAAC,CAAC;AAAA,WAAIA,CAAJ;AAAA,GAA3C,CAAhB;AACA,SAAOJ,MAAM,CAACM,MAAP,CAAc,UAACC,GAAD,EAAMC,GAAN,EAAWJ,CAAX;AAAA,WAAiBG,GAAG,IAAIF,OAAO,CAACD,CAAD,CAAP,KAAeI,GAAvC;AAAA,GAAd,EAA0D,IAA1D,CAAP;AACD;;AAED,SAAS9B,MAAT,CAAiBpB,GAAjB,EAAsBC,IAAtB,EAA4BW,QAA5B,EAAsC;AACpC,0BAAiBA,QAAjB,eAA8BZ,GAA9B,6CAAoEC,IAApE;AACD;;AAEDkD,MAAM,CAACC,OAAP,GAAiB;AACfzC,EAAAA,UAAU,EAAVA,UADe;AAEfU,EAAAA,cAAc,EAAdA,cAFe;AAGfC,EAAAA,gBAAgB,EAAhBA,gBAHe;AAIfQ,EAAAA,oBAAoB,EAApBA,oBAJe;AAKfX,EAAAA,WAAW,EAAXA;AALe,CAAjB","sourcesContent":["'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\nconst atLeastNode = require('at-least-node')\n\nconst nodeSupportsBigInt = atLeastNode('10.5.0')\nconst stat = (file) => nodeSupportsBigInt ? fs.stat(file, { bigint: true }) : fs.stat(file)\nconst statSync = (file) => nodeSupportsBigInt ? fs.statSync(file, { bigint: true }) : fs.statSync(file)\n\nfunction getStats (src, dest) {\n  return Promise.all([\n    stat(src),\n    stat(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest) {\n  let destStat\n  const srcStat = statSync(src)\n  try {\n    destStat = statSync(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  util.callbackify(getStats)(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && areIdentical(srcStat, destStat)) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && areIdentical(srcStat, destStat)) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  const callback = (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  }\n  if (nodeSupportsBigInt) fs.stat(destParent, { bigint: true }, callback)\n  else fs.stat(destParent, callback)\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = statSync(destParent)\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {\n      // definitive answer\n      return true\n    }\n    // Use additional heuristics if we can't use 'bigint'.\n    // Different 'ino' could be represented the same if they are >= Number.MAX_SAFE_INTEGER\n    // See issue 657\n    if (destStat.size === srcStat.size &&\n        destStat.mode === srcStat.mode &&\n        destStat.nlink === srcStat.nlink &&\n        destStat.atimeMs === srcStat.atimeMs &&\n        destStat.mtimeMs === srcStat.mtimeMs &&\n        destStat.ctimeMs === srcStat.ctimeMs &&\n        destStat.birthtimeMs === srcStat.birthtimeMs) {\n      // heuristic answer\n      return true\n    }\n  }\n  return false\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n"]},"metadata":{},"sourceType":"script"}