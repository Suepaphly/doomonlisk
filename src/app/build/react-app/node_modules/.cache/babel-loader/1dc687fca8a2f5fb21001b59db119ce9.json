{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BFT = exports.BFTFinalizedHeightCodecSchema = exports.EVENT_BFT_BLOCK_FINALIZED = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar assert = require(\"assert\");\n\nvar events_1 = require(\"events\");\n\nvar lisk_chain_1 = require(\"@liskhq/lisk-chain\");\n\nvar finality_manager_1 = require(\"./finality_manager\");\n\nvar forkChoiceRule = require(\"./fork_choice_rule\");\n\nvar types_1 = require(\"./types\");\n\nvar constant_1 = require(\"./constant\");\n\nexports.EVENT_BFT_BLOCK_FINALIZED = 'EVENT_BFT_BLOCK_FINALIZED';\nexports.BFTFinalizedHeightCodecSchema = {\n  type: 'object',\n  $id: '/BFT/FinalizedHeight',\n  title: 'Lisk BFT Finalized Height',\n  properties: {\n    finalizedHeight: {\n      dataType: 'uint32',\n      fieldNumber: 1\n    }\n  },\n  required: ['finalizedHeight']\n};\nlisk_codec_1.codec.addSchema(exports.BFTFinalizedHeightCodecSchema);\n\nvar BFT = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(BFT, _events_1$EventEmitte);\n\n  var _super = _createSuper(BFT);\n\n  function BFT(_ref) {\n    var _this;\n\n    var chain = _ref.chain,\n        threshold = _ref.threshold,\n        genesisHeight = _ref.genesisHeight;\n\n    _classCallCheck(this, BFT);\n\n    _this = _super.call(this);\n    _this._chain = chain;\n    _this.constants = {\n      threshold: threshold,\n      genesisHeight: genesisHeight\n    };\n    return _this;\n  }\n\n  _createClass(BFT, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(stateStore) {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._initFinalityManager(stateStore);\n\n              case 2:\n                this._finalityManager = _context.sent;\n                this.finalityManager.on(finality_manager_1.EVENT_BFT_FINALIZED_HEIGHT_CHANGED, function (updatedFinalizedHeight) {\n                  _this2.emit(finality_manager_1.EVENT_BFT_FINALIZED_HEIGHT_CHANGED, updatedFinalizedHeight);\n                });\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"finalityManager\",\n    get: function get() {\n      return this._finalityManager;\n    }\n  }, {\n    key: \"applyBlockHeader\",\n    value: function () {\n      var _applyBlockHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(block, stateStore) {\n        var finalizedHeight;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.finalityManager.addBlockHeader(block, stateStore);\n\n              case 2:\n                finalizedHeight = this.finalityManager.finalizedHeight;\n                _context2.next = 5;\n                return stateStore.consensus.set(lisk_chain_1.CONSENSUS_STATE_FINALIZED_HEIGHT_KEY, lisk_codec_1.codec.encode(exports.BFTFinalizedHeightCodecSchema, {\n                  finalizedHeight: finalizedHeight\n                }));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function applyBlockHeader(_x2, _x3) {\n        return _applyBlockHeader.apply(this, arguments);\n      }\n\n      return applyBlockHeader;\n    }()\n  }, {\n    key: \"verifyBlockHeader\",\n    value: function () {\n      var _verifyBlockHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(blockHeader, stateStore) {\n        var isCompliant, reward, expectedReward;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.isBFTProtocolCompliant(blockHeader, stateStore);\n\n              case 2:\n                isCompliant = _context3.sent;\n                reward = this._chain.calculateExpectedReward(blockHeader, stateStore);\n                expectedReward = isCompliant ? reward : reward / BigInt(4);\n\n                if (!(blockHeader.reward !== expectedReward)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Invalid block reward: \".concat(blockHeader.reward.toString(), \" expected: \").concat(expectedReward.toString()));\n\n              case 7:\n                _context3.next = 9;\n                return this.finalityManager.verifyBlockHeaders(blockHeader, stateStore);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function verifyBlockHeader(_x4, _x5) {\n        return _verifyBlockHeader.apply(this, arguments);\n      }\n\n      return verifyBlockHeader;\n    }()\n  }, {\n    key: \"forkChoice\",\n    value: function forkChoice(blockHeader, lastBlockHeader) {\n      var receivedBlock = _objectSpread(_objectSpread({}, blockHeader), {}, {\n        receivedAt: this._chain.slots.timeSinceGenesis()\n      });\n\n      if (forkChoiceRule.isValidBlock(lastBlockHeader, receivedBlock)) {\n        return types_1.ForkStatus.VALID_BLOCK;\n      }\n\n      if (forkChoiceRule.isIdenticalBlock(lastBlockHeader, receivedBlock)) {\n        return types_1.ForkStatus.IDENTICAL_BLOCK;\n      }\n\n      if (forkChoiceRule.isDoubleForging(lastBlockHeader, receivedBlock)) {\n        return types_1.ForkStatus.DOUBLE_FORGING;\n      }\n\n      if (forkChoiceRule.isTieBreak({\n        slots: this._chain.slots,\n        lastAppliedBlock: lastBlockHeader,\n        receivedBlock: receivedBlock\n      })) {\n        return types_1.ForkStatus.TIE_BREAK;\n      }\n\n      if (forkChoiceRule.isDifferentChain(lastBlockHeader, receivedBlock)) {\n        return types_1.ForkStatus.DIFFERENT_CHAIN;\n      }\n\n      return types_1.ForkStatus.DISCARD;\n    }\n  }, {\n    key: \"isBFTProtocolCompliant\",\n    value: function () {\n      var _isBFTProtocolCompliant = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(blockHeader, stateStore) {\n        var validators, numberOfVotingValidators, heightThreshold, maxHeightPreviouslyForgedBlock;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                assert(blockHeader, 'No block was provided to be verified');\n                _context4.next = 3;\n                return lisk_chain_1.getValidators(stateStore);\n\n              case 3:\n                validators = _context4.sent;\n                numberOfVotingValidators = validators.filter(function (validator) {\n                  return validator.isConsensusParticipant;\n                }).length;\n                heightThreshold = numberOfVotingValidators * constant_1.BFT_ROUND_THRESHOLD;\n\n                if (!(blockHeader.asset.maxHeightPreviouslyForged === 0)) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", true);\n\n              case 8:\n                if (!(blockHeader.height <= blockHeader.asset.maxHeightPreviouslyForged)) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", false);\n\n              case 10:\n                if (!(blockHeader.height - blockHeader.asset.maxHeightPreviouslyForged > heightThreshold)) {\n                  _context4.next = 12;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", true);\n\n              case 12:\n                maxHeightPreviouslyForgedBlock = stateStore.chain.lastBlockHeaders.find(function (bftHeader) {\n                  return bftHeader.height === blockHeader.asset.maxHeightPreviouslyForged;\n                });\n\n                if (maxHeightPreviouslyForgedBlock) {\n                  _context4.next = 15;\n                  break;\n                }\n\n                throw new Error(\"Block at height \".concat(blockHeader.asset.maxHeightPreviouslyForged, \" must be in the lastBlockHeaders.\"));\n\n              case 15:\n                if (blockHeader.generatorPublicKey.equals(maxHeightPreviouslyForgedBlock.generatorPublicKey)) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", false);\n\n              case 17:\n                return _context4.abrupt(\"return\", true);\n\n              case 18:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function isBFTProtocolCompliant(_x6, _x7) {\n        return _isBFTProtocolCompliant.apply(this, arguments);\n      }\n\n      return isBFTProtocolCompliant;\n    }()\n  }, {\n    key: \"getMaxHeightPrevoted\",\n    value: function () {\n      var _getMaxHeightPrevoted = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(lastMaxHeightPrevoted) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", this.finalityManager.getMaxHeightPrevoted(lastMaxHeightPrevoted));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getMaxHeightPrevoted(_x8) {\n        return _getMaxHeightPrevoted.apply(this, arguments);\n      }\n\n      return getMaxHeightPrevoted;\n    }()\n  }, {\n    key: \"finalizedHeight\",\n    get: function get() {\n      return this.finalityManager.finalizedHeight;\n    }\n  }, {\n    key: \"_initFinalityManager\",\n    value: function () {\n      var _initFinalityManager2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(stateStore) {\n        var storedFinalizedHeightBuffer, finalizedHeight, finalityManager;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return stateStore.consensus.get(lisk_chain_1.CONSENSUS_STATE_FINALIZED_HEIGHT_KEY);\n\n              case 2:\n                storedFinalizedHeightBuffer = _context6.sent;\n                finalizedHeight = storedFinalizedHeightBuffer === undefined ? this.constants.genesisHeight : lisk_codec_1.codec.decode(exports.BFTFinalizedHeightCodecSchema, storedFinalizedHeightBuffer).finalizedHeight;\n                finalityManager = new finality_manager_1.FinalityManager({\n                  chain: this._chain,\n                  finalizedHeight: finalizedHeight,\n                  genesisHeight: this.constants.genesisHeight,\n                  threshold: this.constants.threshold\n                });\n                return _context6.abrupt(\"return\", finalityManager);\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _initFinalityManager(_x9) {\n        return _initFinalityManager2.apply(this, arguments);\n      }\n\n      return _initFinalityManager;\n    }()\n  }]);\n\n  return BFT;\n}(events_1.EventEmitter);\n\nexports.BFT = BFT;","map":{"version":3,"sources":["../src/bft.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BFT = exports.BFTFinalizedHeightCodecSchema = exports.EVENT_BFT_BLOCK_FINALIZED = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst assert = require(\"assert\");\nconst events_1 = require(\"events\");\nconst lisk_chain_1 = require(\"@liskhq/lisk-chain\");\nconst finality_manager_1 = require(\"./finality_manager\");\nconst forkChoiceRule = require(\"./fork_choice_rule\");\nconst types_1 = require(\"./types\");\nconst constant_1 = require(\"./constant\");\nexports.EVENT_BFT_BLOCK_FINALIZED = 'EVENT_BFT_BLOCK_FINALIZED';\nexports.BFTFinalizedHeightCodecSchema = {\n    type: 'object',\n    $id: '/BFT/FinalizedHeight',\n    title: 'Lisk BFT Finalized Height',\n    properties: {\n        finalizedHeight: {\n            dataType: 'uint32',\n            fieldNumber: 1,\n        },\n    },\n    required: ['finalizedHeight'],\n};\nlisk_codec_1.codec.addSchema(exports.BFTFinalizedHeightCodecSchema);\nclass BFT extends events_1.EventEmitter {\n    constructor({ chain, threshold, genesisHeight, }) {\n        super();\n        this._chain = chain;\n        this.constants = {\n            threshold,\n            genesisHeight,\n        };\n    }\n    async init(stateStore) {\n        this._finalityManager = await this._initFinalityManager(stateStore);\n        this.finalityManager.on(finality_manager_1.EVENT_BFT_FINALIZED_HEIGHT_CHANGED, updatedFinalizedHeight => {\n            this.emit(finality_manager_1.EVENT_BFT_FINALIZED_HEIGHT_CHANGED, updatedFinalizedHeight);\n        });\n    }\n    get finalityManager() {\n        return this._finalityManager;\n    }\n    async applyBlockHeader(block, stateStore) {\n        await this.finalityManager.addBlockHeader(block, stateStore);\n        const { finalizedHeight } = this.finalityManager;\n        await stateStore.consensus.set(lisk_chain_1.CONSENSUS_STATE_FINALIZED_HEIGHT_KEY, lisk_codec_1.codec.encode(exports.BFTFinalizedHeightCodecSchema, { finalizedHeight }));\n    }\n    async verifyBlockHeader(blockHeader, stateStore) {\n        const isCompliant = await this.isBFTProtocolCompliant(blockHeader, stateStore);\n        const reward = this._chain.calculateExpectedReward(blockHeader, stateStore);\n        const expectedReward = isCompliant ? reward : reward / BigInt(4);\n        if (blockHeader.reward !== expectedReward) {\n            throw new Error(`Invalid block reward: ${blockHeader.reward.toString()} expected: ${expectedReward.toString()}`);\n        }\n        await this.finalityManager.verifyBlockHeaders(blockHeader, stateStore);\n    }\n    forkChoice(blockHeader, lastBlockHeader) {\n        const receivedBlock = {\n            ...blockHeader,\n            receivedAt: this._chain.slots.timeSinceGenesis(),\n        };\n        if (forkChoiceRule.isValidBlock(lastBlockHeader, receivedBlock)) {\n            return types_1.ForkStatus.VALID_BLOCK;\n        }\n        if (forkChoiceRule.isIdenticalBlock(lastBlockHeader, receivedBlock)) {\n            return types_1.ForkStatus.IDENTICAL_BLOCK;\n        }\n        if (forkChoiceRule.isDoubleForging(lastBlockHeader, receivedBlock)) {\n            return types_1.ForkStatus.DOUBLE_FORGING;\n        }\n        if (forkChoiceRule.isTieBreak({\n            slots: this._chain.slots,\n            lastAppliedBlock: lastBlockHeader,\n            receivedBlock,\n        })) {\n            return types_1.ForkStatus.TIE_BREAK;\n        }\n        if (forkChoiceRule.isDifferentChain(lastBlockHeader, receivedBlock)) {\n            return types_1.ForkStatus.DIFFERENT_CHAIN;\n        }\n        return types_1.ForkStatus.DISCARD;\n    }\n    async isBFTProtocolCompliant(blockHeader, stateStore) {\n        assert(blockHeader, 'No block was provided to be verified');\n        const validators = await lisk_chain_1.getValidators(stateStore);\n        const numberOfVotingValidators = validators.filter(validator => validator.isConsensusParticipant).length;\n        const heightThreshold = numberOfVotingValidators * constant_1.BFT_ROUND_THRESHOLD;\n        if (blockHeader.asset.maxHeightPreviouslyForged === 0) {\n            return true;\n        }\n        if (blockHeader.height <= blockHeader.asset.maxHeightPreviouslyForged) {\n            return false;\n        }\n        if (blockHeader.height - blockHeader.asset.maxHeightPreviouslyForged > heightThreshold) {\n            return true;\n        }\n        const maxHeightPreviouslyForgedBlock = stateStore.chain.lastBlockHeaders.find(bftHeader => bftHeader.height === blockHeader.asset.maxHeightPreviouslyForged);\n        if (!maxHeightPreviouslyForgedBlock) {\n            throw new Error(`Block at height ${blockHeader.asset.maxHeightPreviouslyForged} must be in the lastBlockHeaders.`);\n        }\n        if (!blockHeader.generatorPublicKey.equals(maxHeightPreviouslyForgedBlock.generatorPublicKey)) {\n            return false;\n        }\n        return true;\n    }\n    async getMaxHeightPrevoted(lastMaxHeightPrevoted) {\n        return this.finalityManager.getMaxHeightPrevoted(lastMaxHeightPrevoted);\n    }\n    get finalizedHeight() {\n        return this.finalityManager.finalizedHeight;\n    }\n    async _initFinalityManager(stateStore) {\n        const storedFinalizedHeightBuffer = await stateStore.consensus.get(lisk_chain_1.CONSENSUS_STATE_FINALIZED_HEIGHT_KEY);\n        const finalizedHeight = storedFinalizedHeightBuffer === undefined\n            ? this.constants.genesisHeight\n            : lisk_codec_1.codec.decode(exports.BFTFinalizedHeightCodecSchema, storedFinalizedHeightBuffer).finalizedHeight;\n        const finalityManager = new finality_manager_1.FinalityManager({\n            chain: this._chain,\n            finalizedHeight,\n            genesisHeight: this.constants.genesisHeight,\n            threshold: this.constants.threshold,\n        });\n        return finalityManager;\n    }\n}\nexports.BFT = BFT;\n//# sourceMappingURL=bft.js.map"]},"metadata":{},"sourceType":"script"}