{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KeysModule = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nvar utils_1 = require(\"./utils\");\n\nvar base_module_1 = require(\"../base_module\");\n\nvar register_asset_1 = require(\"./register_asset\");\n\nvar schemas_1 = require(\"./schemas\");\n\nvar _lisk_utils_1$objects = lisk_utils_1.objects,\n    bufferArrayOrderByLex = _lisk_utils_1$objects.bufferArrayOrderByLex,\n    bufferArrayUniqueItems = _lisk_utils_1$objects.bufferArrayUniqueItems,\n    bufferArrayContainsSome = _lisk_utils_1$objects.bufferArrayContainsSome;\n\nvar KeysModule = /*#__PURE__*/function (_base_module_1$BaseMo) {\n  _inherits(KeysModule, _base_module_1$BaseMo);\n\n  var _super = _createSuper(KeysModule);\n\n  function KeysModule() {\n    var _this;\n\n    _classCallCheck(this, KeysModule);\n\n    _this = _super.apply(this, arguments);\n    _this.name = 'keys';\n    _this.id = 4;\n    _this.accountSchema = {\n      type: 'object',\n      properties: {\n        numberOfSignatures: {\n          dataType: 'uint32',\n          fieldNumber: 1\n        },\n        mandatoryKeys: {\n          type: 'array',\n          items: {\n            dataType: 'bytes'\n          },\n          fieldNumber: 2\n        },\n        optionalKeys: {\n          type: 'array',\n          items: {\n            dataType: 'bytes'\n          },\n          fieldNumber: 3\n        }\n      },\n      default: {\n        mandatoryKeys: [],\n        optionalKeys: [],\n        numberOfSignatures: 0\n      }\n    };\n    _this.transactionAssets = [new register_asset_1.RegisterAsset()];\n    return _this;\n  }\n\n  _createClass(KeysModule, [{\n    key: \"beforeTransactionApply\",\n    value: function () {\n      var _beforeTransactionApply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n        var stateStore, transaction, sender, networkIdentifier, transactionBytes, transactionWithNetworkIdentifierBytes, _lisk_codec_1$codec$d, mandatoryKeys, optionalKeys, numberOfExpectedKeys;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                stateStore = _ref.stateStore, transaction = _ref.transaction;\n                _context.next = 3;\n                return stateStore.account.get(transaction.senderAddress);\n\n              case 3:\n                sender = _context.sent;\n                networkIdentifier = stateStore.chain.networkIdentifier;\n                transactionBytes = transaction.getSigningBytes();\n                transactionWithNetworkIdentifierBytes = Buffer.concat([networkIdentifier, transactionBytes]);\n\n                if (!(transaction.moduleID === this.id && transaction.assetID === register_asset_1.RegisterAssetID)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                _lisk_codec_1$codec$d = lisk_codec_1.codec.decode(schemas_1.keysSchema, transaction.asset), mandatoryKeys = _lisk_codec_1$codec$d.mandatoryKeys, optionalKeys = _lisk_codec_1$codec$d.optionalKeys;\n                numberOfExpectedKeys = mandatoryKeys.length + optionalKeys.length + 1;\n\n                if (!(numberOfExpectedKeys !== transaction.signatures.length)) {\n                  _context.next = 12;\n                  break;\n                }\n\n                throw new Error(\"There are missing signatures. Expected: \".concat(numberOfExpectedKeys, \" signatures but got: \").concat(transaction.signatures.length, \".\"));\n\n              case 12:\n                if (transaction.signatures.every(function (signature) {\n                  return signature.length > 0;\n                })) {\n                  _context.next = 14;\n                  break;\n                }\n\n                throw new Error('A valid signature is required for each registered key.');\n\n              case 14:\n                utils_1.validateSignature(transaction.senderPublicKey, transaction.signatures[0], transactionWithNetworkIdentifierBytes, transaction.id);\n                utils_1.validateKeysSignatures(mandatoryKeys, transaction.signatures.slice(1, mandatoryKeys.length + 1), transactionWithNetworkIdentifierBytes, transaction.id);\n                utils_1.validateKeysSignatures(optionalKeys, transaction.signatures.slice(mandatoryKeys.length + 1), transactionWithNetworkIdentifierBytes, transaction.id);\n                return _context.abrupt(\"return\");\n\n              case 18:\n                if (utils_1.isMultisignatureAccount(sender)) {\n                  _context.next = 23;\n                  break;\n                }\n\n                if (!(transaction.signatures.length !== 1)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                throw new Error(\"Transactions from a single signature account should have exactly one signature. Found \".concat(transaction.signatures.length, \" signatures.\"));\n\n              case 21:\n                utils_1.validateSignature(transaction.senderPublicKey, transaction.signatures[0], transactionWithNetworkIdentifierBytes, transaction.id);\n                return _context.abrupt(\"return\");\n\n              case 23:\n                utils_1.verifyMultiSignatureTransaction(transaction.id, sender, transaction.signatures, transactionWithNetworkIdentifierBytes);\n\n              case 24:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function beforeTransactionApply(_x) {\n        return _beforeTransactionApply.apply(this, arguments);\n      }\n\n      return beforeTransactionApply;\n    }()\n  }, {\n    key: \"afterGenesisBlockApply\",\n    value: function () {\n      var _afterGenesisBlockApply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n        var genesisBlock, errors, accountsLength, index, account;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                genesisBlock = _ref2.genesisBlock;\n                errors = [];\n                accountsLength = genesisBlock.header.asset.accounts.length;\n\n                for (index = 0; index < accountsLength; index += 1) {\n                  account = genesisBlock.header.asset.accounts[index];\n\n                  if (!bufferArrayOrderByLex(account.keys.mandatoryKeys)) {\n                    errors.push({\n                      message: 'should be lexicographically ordered',\n                      keyword: 'mandatoryKeys',\n                      dataPath: \".accounts[\".concat(index, \"].keys.mandatoryKeys\"),\n                      schemaPath: '#/properties/accounts/items/properties/keys/properties/mandatoryKeys',\n                      params: {\n                        keys: account.keys,\n                        address: account.address\n                      }\n                    });\n                  }\n\n                  if (!bufferArrayUniqueItems(account.keys.mandatoryKeys)) {\n                    errors.push({\n                      dataPath: \".accounts[\".concat(index, \"].keys.mandatoryKeys\"),\n                      keyword: 'uniqueItems',\n                      message: 'must NOT have duplicate items',\n                      params: {\n                        keys: account.keys,\n                        address: account.address\n                      },\n                      schemaPath: '#/properties/accounts/items/properties/keys/properties/mandatoryKeys/uniqueItems'\n                    });\n                  }\n\n                  if (!bufferArrayOrderByLex(account.keys.optionalKeys)) {\n                    errors.push({\n                      message: 'should be lexicographically ordered',\n                      keyword: 'optionalKeys',\n                      dataPath: \".accounts[\".concat(index, \"].keys.optionalKeys\"),\n                      schemaPath: '#/properties/accounts/items/properties/keys/properties/optionalKeys',\n                      params: {\n                        keys: account.keys,\n                        address: account.address\n                      }\n                    });\n                  }\n\n                  if (!bufferArrayUniqueItems(account.keys.optionalKeys)) {\n                    errors.push({\n                      dataPath: \".accounts[\".concat(index, \"].keys.optionalKeys\"),\n                      keyword: 'uniqueItems',\n                      message: 'must NOT have duplicate items',\n                      params: {\n                        keys: account.keys,\n                        address: account.address\n                      },\n                      schemaPath: '#/properties/accounts/items/properties/keys/properties/optionalKeys/uniqueItems'\n                    });\n                  }\n\n                  if (bufferArrayContainsSome(account.keys.mandatoryKeys, account.keys.optionalKeys)) {\n                    errors.push({\n                      dataPath: \".accounts[\".concat(index, \"].keys.mandatoryKeys, .accounts[\").concat(index, \"].keys.optionalKeys\"),\n                      keyword: 'uniqueItems',\n                      message: 'must NOT have duplicate items among mandatoryKeys and optionalKeys',\n                      params: {\n                        keys: account.keys,\n                        address: account.address\n                      },\n                      schemaPath: '#/properties/accounts/items/properties/keys'\n                    });\n                  }\n\n                  if (account.keys.mandatoryKeys.length + account.keys.optionalKeys.length > 64) {\n                    errors.push({\n                      dataPath: \".accounts[\".concat(index, \"].keys.mandatoryKeys, .accounts[\").concat(index, \"].keys.optionalKeys\"),\n                      keyword: 'maxItems',\n                      message: 'should not have more than 64 keys',\n                      params: {\n                        keys: account.keys,\n                        address: account.address,\n                        maxItems: 64\n                      },\n                      schemaPath: '#/properties/accounts/items/properties/keys'\n                    });\n                  }\n\n                  if (account.keys.numberOfSignatures < account.keys.mandatoryKeys.length) {\n                    errors.push({\n                      dataPath: \".accounts[\".concat(index, \"].keys.numberOfSignatures\"),\n                      keyword: 'min',\n                      message: 'should be minimum of length of mandatoryKeys',\n                      params: {\n                        keys: account.keys,\n                        address: account.address,\n                        min: account.keys.mandatoryKeys.length\n                      },\n                      schemaPath: '#/properties/accounts/items/properties/keys/properties/numberOfSignatures'\n                    });\n                  }\n\n                  if (account.keys.numberOfSignatures > account.keys.mandatoryKeys.length + account.keys.optionalKeys.length) {\n                    errors.push({\n                      dataPath: \".accounts[\".concat(index, \"].keys.numberOfSignatures\"),\n                      keyword: 'max',\n                      message: 'should be maximum of length of mandatoryKeys and optionalKeys',\n                      params: {\n                        keys: account.keys,\n                        address: account.address,\n                        max: account.keys.mandatoryKeys.length + account.keys.optionalKeys.length\n                      },\n                      schemaPath: '#/properties/accounts/items/properties/keys/properties/numberOfSignatures'\n                    });\n                  }\n                }\n\n                if (!errors.length) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw new lisk_validator_1.LiskValidationError(errors);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function afterGenesisBlockApply(_x2) {\n        return _afterGenesisBlockApply.apply(this, arguments);\n      }\n\n      return afterGenesisBlockApply;\n    }()\n  }]);\n\n  return KeysModule;\n}(base_module_1.BaseModule);\n\nexports.KeysModule = KeysModule;","map":{"version":3,"sources":["../../../src/modules/keys/keys_module.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KeysModule = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst utils_1 = require(\"./utils\");\nconst base_module_1 = require(\"../base_module\");\nconst register_asset_1 = require(\"./register_asset\");\nconst schemas_1 = require(\"./schemas\");\nconst { bufferArrayOrderByLex, bufferArrayUniqueItems, bufferArrayContainsSome } = lisk_utils_1.objects;\nclass KeysModule extends base_module_1.BaseModule {\n    constructor() {\n        super(...arguments);\n        this.name = 'keys';\n        this.id = 4;\n        this.accountSchema = {\n            type: 'object',\n            properties: {\n                numberOfSignatures: { dataType: 'uint32', fieldNumber: 1 },\n                mandatoryKeys: {\n                    type: 'array',\n                    items: { dataType: 'bytes' },\n                    fieldNumber: 2,\n                },\n                optionalKeys: {\n                    type: 'array',\n                    items: { dataType: 'bytes' },\n                    fieldNumber: 3,\n                },\n            },\n            default: {\n                mandatoryKeys: [],\n                optionalKeys: [],\n                numberOfSignatures: 0,\n            },\n        };\n        this.transactionAssets = [new register_asset_1.RegisterAsset()];\n    }\n    async beforeTransactionApply({ stateStore, transaction, }) {\n        const sender = await stateStore.account.get(transaction.senderAddress);\n        const { networkIdentifier } = stateStore.chain;\n        const transactionBytes = transaction.getSigningBytes();\n        const transactionWithNetworkIdentifierBytes = Buffer.concat([\n            networkIdentifier,\n            transactionBytes,\n        ]);\n        if (transaction.moduleID === this.id && transaction.assetID === register_asset_1.RegisterAssetID) {\n            const { mandatoryKeys, optionalKeys } = lisk_codec_1.codec.decode(schemas_1.keysSchema, transaction.asset);\n            const numberOfExpectedKeys = mandatoryKeys.length + optionalKeys.length + 1;\n            if (numberOfExpectedKeys !== transaction.signatures.length) {\n                throw new Error(`There are missing signatures. Expected: ${numberOfExpectedKeys} signatures but got: ${transaction.signatures.length}.`);\n            }\n            if (!transaction.signatures.every(signature => signature.length > 0)) {\n                throw new Error('A valid signature is required for each registered key.');\n            }\n            utils_1.validateSignature(transaction.senderPublicKey, transaction.signatures[0], transactionWithNetworkIdentifierBytes, transaction.id);\n            utils_1.validateKeysSignatures(mandatoryKeys, transaction.signatures.slice(1, mandatoryKeys.length + 1), transactionWithNetworkIdentifierBytes, transaction.id);\n            utils_1.validateKeysSignatures(optionalKeys, transaction.signatures.slice(mandatoryKeys.length + 1), transactionWithNetworkIdentifierBytes, transaction.id);\n            return;\n        }\n        if (!utils_1.isMultisignatureAccount(sender)) {\n            if (transaction.signatures.length !== 1) {\n                throw new Error(`Transactions from a single signature account should have exactly one signature. Found ${transaction.signatures.length} signatures.`);\n            }\n            utils_1.validateSignature(transaction.senderPublicKey, transaction.signatures[0], transactionWithNetworkIdentifierBytes, transaction.id);\n            return;\n        }\n        utils_1.verifyMultiSignatureTransaction(transaction.id, sender, transaction.signatures, transactionWithNetworkIdentifierBytes);\n    }\n    async afterGenesisBlockApply({ genesisBlock, }) {\n        const errors = [];\n        const accountsLength = genesisBlock.header.asset.accounts.length;\n        for (let index = 0; index < accountsLength; index += 1) {\n            const account = genesisBlock.header.asset.accounts[index];\n            if (!bufferArrayOrderByLex(account.keys.mandatoryKeys)) {\n                errors.push({\n                    message: 'should be lexicographically ordered',\n                    keyword: 'mandatoryKeys',\n                    dataPath: `.accounts[${index}].keys.mandatoryKeys`,\n                    schemaPath: '#/properties/accounts/items/properties/keys/properties/mandatoryKeys',\n                    params: { keys: account.keys, address: account.address },\n                });\n            }\n            if (!bufferArrayUniqueItems(account.keys.mandatoryKeys)) {\n                errors.push({\n                    dataPath: `.accounts[${index}].keys.mandatoryKeys`,\n                    keyword: 'uniqueItems',\n                    message: 'must NOT have duplicate items',\n                    params: { keys: account.keys, address: account.address },\n                    schemaPath: '#/properties/accounts/items/properties/keys/properties/mandatoryKeys/uniqueItems',\n                });\n            }\n            if (!bufferArrayOrderByLex(account.keys.optionalKeys)) {\n                errors.push({\n                    message: 'should be lexicographically ordered',\n                    keyword: 'optionalKeys',\n                    dataPath: `.accounts[${index}].keys.optionalKeys`,\n                    schemaPath: '#/properties/accounts/items/properties/keys/properties/optionalKeys',\n                    params: { keys: account.keys, address: account.address },\n                });\n            }\n            if (!bufferArrayUniqueItems(account.keys.optionalKeys)) {\n                errors.push({\n                    dataPath: `.accounts[${index}].keys.optionalKeys`,\n                    keyword: 'uniqueItems',\n                    message: 'must NOT have duplicate items',\n                    params: { keys: account.keys, address: account.address },\n                    schemaPath: '#/properties/accounts/items/properties/keys/properties/optionalKeys/uniqueItems',\n                });\n            }\n            if (bufferArrayContainsSome(account.keys.mandatoryKeys, account.keys.optionalKeys)) {\n                errors.push({\n                    dataPath: `.accounts[${index}].keys.mandatoryKeys, .accounts[${index}].keys.optionalKeys`,\n                    keyword: 'uniqueItems',\n                    message: 'must NOT have duplicate items among mandatoryKeys and optionalKeys',\n                    params: { keys: account.keys, address: account.address },\n                    schemaPath: '#/properties/accounts/items/properties/keys',\n                });\n            }\n            if (account.keys.mandatoryKeys.length + account.keys.optionalKeys.length > 64) {\n                errors.push({\n                    dataPath: `.accounts[${index}].keys.mandatoryKeys, .accounts[${index}].keys.optionalKeys`,\n                    keyword: 'maxItems',\n                    message: 'should not have more than 64 keys',\n                    params: { keys: account.keys, address: account.address, maxItems: 64 },\n                    schemaPath: '#/properties/accounts/items/properties/keys',\n                });\n            }\n            if (account.keys.numberOfSignatures < account.keys.mandatoryKeys.length) {\n                errors.push({\n                    dataPath: `.accounts[${index}].keys.numberOfSignatures`,\n                    keyword: 'min',\n                    message: 'should be minimum of length of mandatoryKeys',\n                    params: {\n                        keys: account.keys,\n                        address: account.address,\n                        min: account.keys.mandatoryKeys.length,\n                    },\n                    schemaPath: '#/properties/accounts/items/properties/keys/properties/numberOfSignatures',\n                });\n            }\n            if (account.keys.numberOfSignatures >\n                account.keys.mandatoryKeys.length + account.keys.optionalKeys.length) {\n                errors.push({\n                    dataPath: `.accounts[${index}].keys.numberOfSignatures`,\n                    keyword: 'max',\n                    message: 'should be maximum of length of mandatoryKeys and optionalKeys',\n                    params: {\n                        keys: account.keys,\n                        address: account.address,\n                        max: account.keys.mandatoryKeys.length + account.keys.optionalKeys.length,\n                    },\n                    schemaPath: '#/properties/accounts/items/properties/keys/properties/numberOfSignatures',\n                });\n            }\n        }\n        if (errors.length) {\n            throw new lisk_validator_1.LiskValidationError(errors);\n        }\n    }\n}\nexports.KeysModule = KeysModule;\n//# sourceMappingURL=keys_module.js.map"]},"metadata":{},"sourceType":"script"}