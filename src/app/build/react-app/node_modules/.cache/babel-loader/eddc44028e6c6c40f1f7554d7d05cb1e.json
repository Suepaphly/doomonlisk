{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeLargestSubsetMaxBy = exports.computeBlockHeightsList = exports.restoreBlocksUponStartup = exports.deleteBlocksAfterHeight = exports.clearBlocksTempTable = exports.restoreBlocks = void 0;\n\nvar lisk_bft_1 = require(\"@liskhq/lisk-bft\");\n\nvar restoreBlocks = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(chainModule, processorModule) {\n    var tempBlocks, _iterator, _step, tempBlock;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return chainModule.dataAccess.getTempBlocks();\n\n          case 2:\n            tempBlocks = _context.sent;\n\n            if (!(tempBlocks.length === 0)) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt(\"return\", false);\n\n          case 5:\n            _iterator = _createForOfIteratorHelper(tempBlocks.reverse());\n            _context.prev = 6;\n\n            _iterator.s();\n\n          case 8:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 14;\n              break;\n            }\n\n            tempBlock = _step.value;\n            _context.next = 12;\n            return processorModule.processValidated(tempBlock, {\n              removeFromTempTable: true\n            });\n\n          case 12:\n            _context.next = 8;\n            break;\n\n          case 14:\n            _context.next = 19;\n            break;\n\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](6);\n\n            _iterator.e(_context.t0);\n\n          case 19:\n            _context.prev = 19;\n\n            _iterator.f();\n\n            return _context.finish(19);\n\n          case 22:\n            return _context.abrupt(\"return\", true);\n\n          case 23:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[6, 16, 19, 22]]);\n  }));\n\n  return function restoreBlocks(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.restoreBlocks = restoreBlocks;\n\nvar clearBlocksTempTable = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(chainModule) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", chainModule.dataAccess.clearTempBlocks());\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function clearBlocksTempTable(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.clearBlocksTempTable = clearBlocksTempTable;\n\nvar deleteBlocksAfterHeight = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(processorModule, chainModule, logger, desiredHeight) {\n    var backup,\n        currentHeight,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            backup = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : false;\n            currentHeight = chainModule.lastBlock.header.height;\n            logger.debug({\n              desiredHeight: desiredHeight,\n              lastBlockHeight: currentHeight\n            }, 'Deleting blocks after height');\n\n          case 3:\n            if (!(desiredHeight < currentHeight)) {\n              _context3.next = 10;\n              break;\n            }\n\n            logger.trace({\n              height: chainModule.lastBlock.header.height,\n              blockId: chainModule.lastBlock.header.id\n            }, 'Deleting block and backing it up to temporary table');\n            _context3.next = 7;\n            return processorModule.deleteLastBlock({\n              saveTempBlock: backup\n            });\n\n          case 7:\n            currentHeight = chainModule.lastBlock.header.height;\n            _context3.next = 3;\n            break;\n\n          case 10:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function deleteBlocksAfterHeight(_x4, _x5, _x6, _x7) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.deleteBlocksAfterHeight = deleteBlocksAfterHeight;\n\nvar restoreBlocksUponStartup = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(logger, chainModule, bftModule, processorModule) {\n    var tempBlocks, blockLowestHeight, blockHighestHeight, forkStatus, blockHasPriority;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return chainModule.dataAccess.getTempBlocks();\n\n          case 2:\n            tempBlocks = _context4.sent;\n            blockLowestHeight = tempBlocks[tempBlocks.length - 1];\n            blockHighestHeight = tempBlocks[0];\n            forkStatus = bftModule.forkChoice(blockHighestHeight.header, chainModule.lastBlock.header);\n            blockHasPriority = forkStatus === lisk_bft_1.ForkStatus.DIFFERENT_CHAIN || forkStatus === lisk_bft_1.ForkStatus.VALID_BLOCK;\n\n            if (!blockHasPriority) {\n              _context4.next = 16;\n              break;\n            }\n\n            logger.info('Restoring blocks from temporary table');\n            _context4.next = 11;\n            return exports.deleteBlocksAfterHeight(processorModule, chainModule, logger, blockLowestHeight.header.height - 1, false);\n\n          case 11:\n            _context4.next = 13;\n            return exports.restoreBlocks(chainModule, processorModule);\n\n          case 13:\n            logger.info('Chain successfully restored');\n            _context4.next = 18;\n            break;\n\n          case 16:\n            _context4.next = 18;\n            return exports.clearBlocksTempTable(chainModule);\n\n          case 18:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function restoreBlocksUponStartup(_x8, _x9, _x10, _x11) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.restoreBlocksUponStartup = restoreBlocksUponStartup;\n\nvar computeBlockHeightsList = function computeBlockHeightsList(finalizedHeight, activeDelegates, listSizeLimit, currentRound) {\n  var startingHeight = Math.max((currentRound - 1) * activeDelegates, 0);\n  var heightList = new Array(listSizeLimit).fill(0).map(function (_, i) {\n    return startingHeight - i * activeDelegates;\n  }).filter(function (height) {\n    return height >= 0;\n  });\n  var heightListAfterFinalized = heightList.filter(function (height) {\n    return height > finalizedHeight;\n  });\n  return heightList.length !== heightListAfterFinalized.length ? [].concat(_toConsumableArray(heightListAfterFinalized), [finalizedHeight]) : heightListAfterFinalized;\n};\n\nexports.computeBlockHeightsList = computeBlockHeightsList;\n\nvar computeLargestSubsetMaxBy = function computeLargestSubsetMaxBy(arrayOfObjects, propertySelectorFunc) {\n  var comparableValues = arrayOfObjects.map(propertySelectorFunc);\n  var absoluteMax = Math.max.apply(Math, _toConsumableArray(comparableValues));\n  var largestSubset = [];\n\n  var _iterator2 = _createForOfIteratorHelper(arrayOfObjects),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n\n      if (propertySelectorFunc(item) === absoluteMax) {\n        largestSubset.push(item);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return largestSubset;\n};\n\nexports.computeLargestSubsetMaxBy = computeLargestSubsetMaxBy;","map":{"version":3,"sources":["../../../src/node/synchronizer/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeLargestSubsetMaxBy = exports.computeBlockHeightsList = exports.restoreBlocksUponStartup = exports.deleteBlocksAfterHeight = exports.clearBlocksTempTable = exports.restoreBlocks = void 0;\nconst lisk_bft_1 = require(\"@liskhq/lisk-bft\");\nconst restoreBlocks = async (chainModule, processorModule) => {\n    const tempBlocks = await chainModule.dataAccess.getTempBlocks();\n    if (tempBlocks.length === 0) {\n        return false;\n    }\n    for (const tempBlock of tempBlocks.reverse()) {\n        await processorModule.processValidated(tempBlock, {\n            removeFromTempTable: true,\n        });\n    }\n    return true;\n};\nexports.restoreBlocks = restoreBlocks;\nconst clearBlocksTempTable = async (chainModule) => chainModule.dataAccess.clearTempBlocks();\nexports.clearBlocksTempTable = clearBlocksTempTable;\nconst deleteBlocksAfterHeight = async (processorModule, chainModule, logger, desiredHeight, backup = false) => {\n    let { height: currentHeight } = chainModule.lastBlock.header;\n    logger.debug({ desiredHeight, lastBlockHeight: currentHeight }, 'Deleting blocks after height');\n    while (desiredHeight < currentHeight) {\n        logger.trace({\n            height: chainModule.lastBlock.header.height,\n            blockId: chainModule.lastBlock.header.id,\n        }, 'Deleting block and backing it up to temporary table');\n        await processorModule.deleteLastBlock({\n            saveTempBlock: backup,\n        });\n        currentHeight = chainModule.lastBlock.header.height;\n    }\n};\nexports.deleteBlocksAfterHeight = deleteBlocksAfterHeight;\nconst restoreBlocksUponStartup = async (logger, chainModule, bftModule, processorModule) => {\n    const tempBlocks = await chainModule.dataAccess.getTempBlocks();\n    const blockLowestHeight = tempBlocks[tempBlocks.length - 1];\n    const blockHighestHeight = tempBlocks[0];\n    const forkStatus = bftModule.forkChoice(blockHighestHeight.header, chainModule.lastBlock.header);\n    const blockHasPriority = forkStatus === lisk_bft_1.ForkStatus.DIFFERENT_CHAIN || forkStatus === lisk_bft_1.ForkStatus.VALID_BLOCK;\n    if (blockHasPriority) {\n        logger.info('Restoring blocks from temporary table');\n        await exports.deleteBlocksAfterHeight(processorModule, chainModule, logger, blockLowestHeight.header.height - 1, false);\n        await exports.restoreBlocks(chainModule, processorModule);\n        logger.info('Chain successfully restored');\n    }\n    else {\n        await exports.clearBlocksTempTable(chainModule);\n    }\n};\nexports.restoreBlocksUponStartup = restoreBlocksUponStartup;\nconst computeBlockHeightsList = (finalizedHeight, activeDelegates, listSizeLimit, currentRound) => {\n    const startingHeight = Math.max((currentRound - 1) * activeDelegates, 0);\n    const heightList = new Array(listSizeLimit)\n        .fill(0)\n        .map((_, i) => startingHeight - i * activeDelegates)\n        .filter(height => height >= 0);\n    const heightListAfterFinalized = heightList.filter(height => height > finalizedHeight);\n    return heightList.length !== heightListAfterFinalized.length\n        ? [...heightListAfterFinalized, finalizedHeight]\n        : heightListAfterFinalized;\n};\nexports.computeBlockHeightsList = computeBlockHeightsList;\nconst computeLargestSubsetMaxBy = (arrayOfObjects, propertySelectorFunc) => {\n    const comparableValues = arrayOfObjects.map(propertySelectorFunc);\n    const absoluteMax = Math.max(...comparableValues);\n    const largestSubset = [];\n    for (const item of arrayOfObjects) {\n        if (propertySelectorFunc(item) === absoluteMax) {\n            largestSubset.push(item);\n        }\n    }\n    return largestSubset;\n};\nexports.computeLargestSubsetMaxBy = computeLargestSubsetMaxBy;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}