{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MinHeap = void 0;\n\nvar node_1 = require(\"./node\");\n\nvar MinHeap = /*#__PURE__*/function () {\n  function MinHeap(heap) {\n    _classCallCheck(this, MinHeap);\n\n    this._nodes = [];\n\n    if (heap) {\n      this._insertAll(heap);\n    }\n  }\n\n  _createClass(MinHeap, [{\n    key: \"push\",\n    value: function push(key, value) {\n      var node = new node_1.Node(key, value);\n\n      this._nodes.push(node);\n\n      this._moveUp(this._nodes.length - 1);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      if (this.count <= 0) {\n        return undefined;\n      }\n\n      if (this.count === 1) {\n        var node = this._nodes[0];\n        this.clear();\n        return node;\n      }\n\n      var rootNode = this._nodes[0];\n      this._nodes[0] = this._nodes.pop();\n\n      this._moveDown(0);\n\n      return rootNode;\n    }\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      if (this._nodes.length <= 0) {\n        return undefined;\n      }\n\n      return this._nodes[0];\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new MinHeap(this);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._nodes = [];\n    }\n  }, {\n    key: \"count\",\n    get: function get() {\n      return this._nodes.length;\n    }\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return this._nodes.map(function (n) {\n        return n.key;\n      });\n    }\n  }, {\n    key: \"values\",\n    get: function get() {\n      return this._nodes.map(function (n) {\n        return n.value;\n      });\n    }\n  }, {\n    key: \"_moveUp\",\n    value: function _moveUp(originalIndex) {\n      var index = originalIndex;\n      var node = this._nodes[index];\n\n      while (index > 0) {\n        var parentIndex = this._parentIndex(index);\n\n        if (this._nodes[parentIndex].key > node.key) {\n          this._nodes[index] = this._nodes[parentIndex];\n          index = parentIndex;\n          continue;\n        }\n\n        break;\n      }\n\n      this._nodes[index] = node;\n    }\n  }, {\n    key: \"_moveDown\",\n    value: function _moveDown(originalIndex) {\n      var index = originalIndex;\n      var node = this._nodes[index];\n      var halfCount = this.count >> 1;\n\n      while (index < halfCount) {\n        var leftChild = this._leftChildIndex(index);\n\n        var rightChild = this._rightChildIndex(index);\n\n        var nextPath = rightChild < this.count && this._nodes[rightChild].key < this._nodes[leftChild].key ? rightChild : leftChild;\n\n        if (this._nodes[nextPath].key > node.key) {\n          break;\n        }\n\n        this._nodes[index] = this._nodes[nextPath];\n        index = nextPath;\n      }\n\n      this._nodes[index] = node;\n    }\n  }, {\n    key: \"_parentIndex\",\n    value: function _parentIndex(index) {\n      return index - 1 >> 1;\n    }\n  }, {\n    key: \"_leftChildIndex\",\n    value: function _leftChildIndex(index) {\n      return index * 2 + 1;\n    }\n  }, {\n    key: \"_rightChildIndex\",\n    value: function _rightChildIndex(index) {\n      return index * 2 + 2;\n    }\n  }, {\n    key: \"_insertAll\",\n    value: function _insertAll(heap) {\n      if (!(heap instanceof MinHeap)) {\n        throw new Error('Only heap instance can be inserted');\n      }\n\n      this._insertAllFromHeap(heap);\n    }\n  }, {\n    key: \"_insertAllFromHeap\",\n    value: function _insertAllFromHeap(heap) {\n      var keys = heap.keys,\n          values = heap.values;\n\n      if (this.count <= 0) {\n        for (var i = 0; i < heap.count; i += 1) {\n          this._nodes.push(new node_1.Node(keys[i], values[i]));\n        }\n\n        return;\n      }\n\n      for (var _i = 0; _i < heap.count; _i += 1) {\n        this.push(keys[_i], values[_i]);\n      }\n    }\n  }]);\n\n  return MinHeap;\n}();\n\nexports.MinHeap = MinHeap;","map":{"version":3,"sources":["../../src/data_structures/min_heap.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MinHeap = void 0;\nconst node_1 = require(\"./node\");\nclass MinHeap {\n    constructor(heap) {\n        this._nodes = [];\n        if (heap) {\n            this._insertAll(heap);\n        }\n    }\n    push(key, value) {\n        const node = new node_1.Node(key, value);\n        this._nodes.push(node);\n        this._moveUp(this._nodes.length - 1);\n    }\n    pop() {\n        if (this.count <= 0) {\n            return undefined;\n        }\n        if (this.count === 1) {\n            const node = this._nodes[0];\n            this.clear();\n            return node;\n        }\n        const rootNode = this._nodes[0];\n        this._nodes[0] = this._nodes.pop();\n        this._moveDown(0);\n        return rootNode;\n    }\n    peek() {\n        if (this._nodes.length <= 0) {\n            return undefined;\n        }\n        return this._nodes[0];\n    }\n    clone() {\n        return new MinHeap(this);\n    }\n    clear() {\n        this._nodes = [];\n    }\n    get count() {\n        return this._nodes.length;\n    }\n    get keys() {\n        return this._nodes.map(n => n.key);\n    }\n    get values() {\n        return this._nodes.map(n => n.value);\n    }\n    _moveUp(originalIndex) {\n        let index = originalIndex;\n        const node = this._nodes[index];\n        while (index > 0) {\n            const parentIndex = this._parentIndex(index);\n            if (this._nodes[parentIndex].key > node.key) {\n                this._nodes[index] = this._nodes[parentIndex];\n                index = parentIndex;\n                continue;\n            }\n            break;\n        }\n        this._nodes[index] = node;\n    }\n    _moveDown(originalIndex) {\n        let index = originalIndex;\n        const node = this._nodes[index];\n        const halfCount = this.count >> 1;\n        while (index < halfCount) {\n            const leftChild = this._leftChildIndex(index);\n            const rightChild = this._rightChildIndex(index);\n            const nextPath = rightChild < this.count && this._nodes[rightChild].key < this._nodes[leftChild].key\n                ? rightChild\n                : leftChild;\n            if (this._nodes[nextPath].key > node.key) {\n                break;\n            }\n            this._nodes[index] = this._nodes[nextPath];\n            index = nextPath;\n        }\n        this._nodes[index] = node;\n    }\n    _parentIndex(index) {\n        return (index - 1) >> 1;\n    }\n    _leftChildIndex(index) {\n        return index * 2 + 1;\n    }\n    _rightChildIndex(index) {\n        return index * 2 + 2;\n    }\n    _insertAll(heap) {\n        if (!(heap instanceof MinHeap)) {\n            throw new Error('Only heap instance can be inserted');\n        }\n        this._insertAllFromHeap(heap);\n    }\n    _insertAllFromHeap(heap) {\n        const { keys, values } = heap;\n        if (this.count <= 0) {\n            for (let i = 0; i < heap.count; i += 1) {\n                this._nodes.push(new node_1.Node(keys[i], values[i]));\n            }\n            return;\n        }\n        for (let i = 0; i < heap.count; i += 1) {\n            this.push(keys[i], values[i]);\n        }\n    }\n}\nexports.MinHeap = MinHeap;\n//# sourceMappingURL=min_heap.js.map"]},"metadata":{},"sourceType":"script"}