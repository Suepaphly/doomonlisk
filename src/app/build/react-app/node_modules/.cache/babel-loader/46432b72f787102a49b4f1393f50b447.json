{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyReward = exports.isValidSeedReveal = exports.verifyBlockGenerator = exports.matchGenesisBlock = exports.verifyPreviousBlockId = exports.verifyBlockNotExists = void 0;\n\nvar createDebug = require(\"debug\");\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar constants_1 = require(\"./constants\");\n\nvar schema_1 = require(\"./schema\");\n\nvar debug = createDebug('lisk:chain:verify');\n\nvar verifyBlockNotExists = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dataAccess, block) {\n    var isPersisted;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return dataAccess.isBlockPersisted(block.header.id);\n\n          case 2:\n            isPersisted = _context.sent;\n\n            if (!isPersisted) {\n              _context.next = 5;\n              break;\n            }\n\n            throw new Error(\"Block \".concat(block.header.id.toString('hex'), \" already exists\"));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function verifyBlockNotExists(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.verifyBlockNotExists = verifyBlockNotExists;\n\nvar verifyPreviousBlockId = function verifyPreviousBlockId(block, lastBlock) {\n  var isConsecutiveBlock = lastBlock.header.height + 1 === block.header.height && block.header.previousBlockID.equals(lastBlock.header.id);\n\n  if (!isConsecutiveBlock) {\n    throw new Error('Invalid previous block');\n  }\n};\n\nexports.verifyPreviousBlockId = verifyPreviousBlockId;\n\nvar matchGenesisBlock = function matchGenesisBlock(genesisBlock, block) {\n  return block.id.equals(genesisBlock.header.id) && block.version === genesisBlock.header.version && block.transactionRoot.equals(genesisBlock.header.transactionRoot) && block.signature.equals(genesisBlock.header.signature);\n};\n\nexports.matchGenesisBlock = matchGenesisBlock;\n\nvar verifyBlockGenerator = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(header, slots, stateStore) {\n    var currentSlot, validatorsBuffer, _lisk_codec_1$codec$d, validators, expectedValidator, generatorAddress;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            currentSlot = slots.getSlotNumber(header.timestamp);\n            _context2.next = 3;\n            return stateStore.consensus.get(constants_1.CONSENSUS_STATE_VALIDATORS_KEY);\n\n          case 3:\n            validatorsBuffer = _context2.sent;\n\n            if (validatorsBuffer) {\n              _context2.next = 6;\n              break;\n            }\n\n            throw new Error(\"Failed to verify slot: \".concat(currentSlot.toString(), \" for block Height: \").concat(header.height, \" - No validator was found\"));\n\n          case 6:\n            _lisk_codec_1$codec$d = lisk_codec_1.codec.decode(schema_1.validatorsSchema, validatorsBuffer), validators = _lisk_codec_1$codec$d.validators;\n            expectedValidator = validators[currentSlot % validators.length];\n            generatorAddress = lisk_cryptography_1.getAddressFromPublicKey(header.generatorPublicKey);\n\n            if (generatorAddress.equals(expectedValidator.address)) {\n              _context2.next = 11;\n              break;\n            }\n\n            throw new Error(\"Failed to verify generator: \".concat(generatorAddress.toString('hex'), \" Expected: \").concat(expectedValidator.address.toString('hex'), \". Block Height: \").concat(header.height));\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function verifyBlockGenerator(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.verifyBlockGenerator = verifyBlockGenerator;\n\nvar lastValidatorsSetHeight = function lastValidatorsSetHeight(height, numberOfValidators) {\n  return Math.max(Math.ceil(height / numberOfValidators) - 2, 0) * numberOfValidators + 1;\n};\n\nvar isValidSeedReveal = function isValidSeedReveal(blockHeader, stateStore, numberOfValidators) {\n  var lastBlockHeaders = stateStore.chain.lastBlockHeaders;\n  var lastForgedBlock = lastBlockHeaders.filter(function (block) {\n    return block.generatorPublicKey.equals(blockHeader.generatorPublicKey) && block.height >= lastValidatorsSetHeight(blockHeader.height, numberOfValidators);\n  });\n\n  if (!lastForgedBlock.length) {\n    debug('Validator did not create any block in current or last validator set', {\n      generatorPublicKey: blockHeader.generatorPublicKey,\n      height: blockHeader.height\n    });\n    return true;\n  }\n\n  var previousBlockSeedReveal = lastForgedBlock[0].asset.seedReveal;\n  var newBlockSeedReveal = blockHeader.asset.seedReveal;\n  var SEED_REVEAL_BYTE_SIZE = 16;\n  var newBlockSeedRevealBuffer = lisk_cryptography_1.hash(newBlockSeedReveal).slice(0, SEED_REVEAL_BYTE_SIZE);\n\n  if (previousBlockSeedReveal.equals(newBlockSeedRevealBuffer)) {\n    return true;\n  }\n\n  debug('New block SeedReveal is not the preimage of last block', {\n    newBlockSeedReveal: newBlockSeedRevealBuffer.toString('hex'),\n    previousBlockSeedReveal: previousBlockSeedReveal,\n    delegate: blockHeader.generatorPublicKey,\n    height: blockHeader.height\n  });\n  return false;\n};\n\nexports.isValidSeedReveal = isValidSeedReveal;\n\nvar verifyReward = function verifyReward(blockHeader, stateStore, numberOfValidators) {\n  if (!exports.isValidSeedReveal(blockHeader, stateStore, numberOfValidators) && blockHeader.reward !== BigInt(0)) {\n    throw new Error(\"Invalid block reward: \".concat(blockHeader.reward.toString(), \" expected: 0\"));\n  }\n};\n\nexports.verifyReward = verifyReward;","map":{"version":3,"sources":["../src/verify.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifyReward = exports.isValidSeedReveal = exports.verifyBlockGenerator = exports.matchGenesisBlock = exports.verifyPreviousBlockId = exports.verifyBlockNotExists = void 0;\nconst createDebug = require(\"debug\");\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst constants_1 = require(\"./constants\");\nconst schema_1 = require(\"./schema\");\nconst debug = createDebug('lisk:chain:verify');\nconst verifyBlockNotExists = async (dataAccess, block) => {\n    const isPersisted = await dataAccess.isBlockPersisted(block.header.id);\n    if (isPersisted) {\n        throw new Error(`Block ${block.header.id.toString('hex')} already exists`);\n    }\n};\nexports.verifyBlockNotExists = verifyBlockNotExists;\nconst verifyPreviousBlockId = (block, lastBlock) => {\n    const isConsecutiveBlock = lastBlock.header.height + 1 === block.header.height &&\n        block.header.previousBlockID.equals(lastBlock.header.id);\n    if (!isConsecutiveBlock) {\n        throw new Error('Invalid previous block');\n    }\n};\nexports.verifyPreviousBlockId = verifyPreviousBlockId;\nconst matchGenesisBlock = (genesisBlock, block) => block.id.equals(genesisBlock.header.id) &&\n    block.version === genesisBlock.header.version &&\n    block.transactionRoot.equals(genesisBlock.header.transactionRoot) &&\n    block.signature.equals(genesisBlock.header.signature);\nexports.matchGenesisBlock = matchGenesisBlock;\nconst verifyBlockGenerator = async (header, slots, stateStore) => {\n    const currentSlot = slots.getSlotNumber(header.timestamp);\n    const validatorsBuffer = await stateStore.consensus.get(constants_1.CONSENSUS_STATE_VALIDATORS_KEY);\n    if (!validatorsBuffer) {\n        throw new Error(`Failed to verify slot: ${currentSlot.toString()} for block Height: ${header.height} - No validator was found`);\n    }\n    const { validators } = lisk_codec_1.codec.decode(schema_1.validatorsSchema, validatorsBuffer);\n    const expectedValidator = validators[currentSlot % validators.length];\n    const generatorAddress = lisk_cryptography_1.getAddressFromPublicKey(header.generatorPublicKey);\n    if (!generatorAddress.equals(expectedValidator.address)) {\n        throw new Error(`Failed to verify generator: ${generatorAddress.toString('hex')} Expected: ${expectedValidator.address.toString('hex')}. Block Height: ${header.height}`);\n    }\n};\nexports.verifyBlockGenerator = verifyBlockGenerator;\nconst lastValidatorsSetHeight = (height, numberOfValidators) => Math.max(Math.ceil(height / numberOfValidators) - 2, 0) * numberOfValidators + 1;\nconst isValidSeedReveal = (blockHeader, stateStore, numberOfValidators) => {\n    const { lastBlockHeaders } = stateStore.chain;\n    const lastForgedBlock = lastBlockHeaders.filter(block => block.generatorPublicKey.equals(blockHeader.generatorPublicKey) &&\n        block.height >= lastValidatorsSetHeight(blockHeader.height, numberOfValidators));\n    if (!lastForgedBlock.length) {\n        debug('Validator did not create any block in current or last validator set', {\n            generatorPublicKey: blockHeader.generatorPublicKey,\n            height: blockHeader.height,\n        });\n        return true;\n    }\n    const { asset: { seedReveal: previousBlockSeedReveal }, } = lastForgedBlock[0];\n    const { asset: { seedReveal: newBlockSeedReveal }, } = blockHeader;\n    const SEED_REVEAL_BYTE_SIZE = 16;\n    const newBlockSeedRevealBuffer = lisk_cryptography_1.hash(newBlockSeedReveal).slice(0, SEED_REVEAL_BYTE_SIZE);\n    if (previousBlockSeedReveal.equals(newBlockSeedRevealBuffer)) {\n        return true;\n    }\n    debug('New block SeedReveal is not the preimage of last block', {\n        newBlockSeedReveal: newBlockSeedRevealBuffer.toString('hex'),\n        previousBlockSeedReveal,\n        delegate: blockHeader.generatorPublicKey,\n        height: blockHeader.height,\n    });\n    return false;\n};\nexports.isValidSeedReveal = isValidSeedReveal;\nconst verifyReward = (blockHeader, stateStore, numberOfValidators) => {\n    if (!exports.isValidSeedReveal(blockHeader, stateStore, numberOfValidators) &&\n        blockHeader.reward !== BigInt(0)) {\n        throw new Error(`Invalid block reward: ${blockHeader.reward.toString()} expected: 0`);\n    }\n};\nexports.verifyReward = verifyReward;\n//# sourceMappingURL=verify.js.map"]},"metadata":{},"sourceType":"script"}