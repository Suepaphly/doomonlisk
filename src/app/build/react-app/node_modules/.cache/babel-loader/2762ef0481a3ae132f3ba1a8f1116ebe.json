{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyProof = void 0;\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar constants_1 = require(\"./constants\");\n\nvar utils_1 = require(\"./utils\");\n\nvar verifyProof = function verifyProof(options) {\n  var _options$proof = options.proof,\n      path = _options$proof.path,\n      indexes = _options$proof.indexes,\n      dataLength = _options$proof.dataLength;\n  var treeHeight = Math.ceil(Math.log2(dataLength)) + 1;\n  var results = new lisk_utils_1.dataStructures.BufferMap();\n\n  if (dataLength === 0 || options.queryData.length === 0) {\n    return [{\n      hash: options.rootHash,\n      verified: true\n    }];\n  }\n\n  var locationToPathMap = {};\n\n  var _iterator = _createForOfIteratorHelper(path),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var p = _step.value;\n\n      if (p.layerIndex !== undefined && p.nodeIndex !== undefined) {\n        locationToPathMap[\"\".concat(utils_1.getBinaryString(p.nodeIndex, treeHeight - p.layerIndex))] = p.hash;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _loop = function _loop(i) {\n    var queryHash = options.queryData[i];\n    var _indexes$i = indexes[i],\n        nodeIndex = _indexes$i.nodeIndex,\n        layerIndex = _indexes$i.layerIndex;\n\n    if (nodeIndex === undefined || layerIndex === undefined) {\n      results.set(queryHash, false);\n      return \"continue\";\n    }\n\n    if (dataLength === 1) {\n      if (path.some(function (p) {\n        return p.hash.equals(queryHash);\n      })) {\n        results.set(queryHash, true);\n      } else {\n        results.set(queryHash, false);\n      }\n\n      return \"continue\";\n    }\n\n    var currentHash = queryHash;\n\n    while (layerIndex !== treeHeight) {\n      var _utils_1$getPairLocat = utils_1.getPairLocation({\n        layerIndex: layerIndex,\n        nodeIndex: nodeIndex,\n        dataLength: dataLength\n      }),\n          pairLayerIndex = _utils_1$getPairLocat.layerIndex,\n          pairNodeIndex = _utils_1$getPairLocat.nodeIndex,\n          pairSide = _utils_1$getPairLocat.side;\n\n      var nextPath = locationToPathMap[\"\".concat(utils_1.getBinaryString(pairNodeIndex, treeHeight - pairLayerIndex))];\n\n      if (nextPath === undefined) {\n        break;\n      }\n\n      var leftHashBuffer = pairSide === 0 ? nextPath : currentHash;\n      var rightHashBuffer = pairSide === 1 ? nextPath : currentHash;\n      currentHash = utils_1.generateHash(constants_1.BRANCH_PREFIX, leftHashBuffer, rightHashBuffer);\n      layerIndex = pairLayerIndex > layerIndex ? pairLayerIndex + 1 : layerIndex + 1;\n      nodeIndex = dataLength === Math.pow(2, treeHeight - 1) ? Math.floor(pairNodeIndex / 2) : Math.floor(pairNodeIndex / Math.pow(2, layerIndex - pairLayerIndex));\n    }\n\n    if (!currentHash.equals(options.rootHash)) {\n      results.set(queryHash, false);\n      return \"continue\";\n    }\n\n    results.set(queryHash, true);\n  };\n\n  for (var i = 0; i < options.queryData.length; i += 1) {\n    var _ret = _loop(i);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return results.entries().map(function (result) {\n    return {\n      hash: result[0],\n      verified: result[1]\n    };\n  });\n};\n\nexports.verifyProof = verifyProof;","map":{"version":3,"sources":["../src/verify_proof.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifyProof = void 0;\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst constants_1 = require(\"./constants\");\nconst utils_1 = require(\"./utils\");\nconst verifyProof = (options) => {\n    const { path, indexes, dataLength } = options.proof;\n    const treeHeight = Math.ceil(Math.log2(dataLength)) + 1;\n    const results = new lisk_utils_1.dataStructures.BufferMap();\n    if (dataLength === 0 || options.queryData.length === 0) {\n        return [{ hash: options.rootHash, verified: true }];\n    }\n    const locationToPathMap = {};\n    for (const p of path) {\n        if (p.layerIndex !== undefined && p.nodeIndex !== undefined) {\n            locationToPathMap[`${utils_1.getBinaryString(p.nodeIndex, treeHeight - p.layerIndex)}`] = p.hash;\n        }\n    }\n    for (let i = 0; i < options.queryData.length; i += 1) {\n        const queryHash = options.queryData[i];\n        let { nodeIndex, layerIndex } = indexes[i];\n        if (nodeIndex === undefined || layerIndex === undefined) {\n            results.set(queryHash, false);\n            continue;\n        }\n        if (dataLength === 1) {\n            if (path.some(p => p.hash.equals(queryHash))) {\n                results.set(queryHash, true);\n            }\n            else {\n                results.set(queryHash, false);\n            }\n            continue;\n        }\n        let currentHash = queryHash;\n        while (layerIndex !== treeHeight) {\n            const { layerIndex: pairLayerIndex, nodeIndex: pairNodeIndex, side: pairSide, } = utils_1.getPairLocation({ layerIndex, nodeIndex, dataLength });\n            const nextPath = locationToPathMap[`${utils_1.getBinaryString(pairNodeIndex, treeHeight - pairLayerIndex)}`];\n            if (nextPath === undefined) {\n                break;\n            }\n            const leftHashBuffer = pairSide === 0 ? nextPath : currentHash;\n            const rightHashBuffer = pairSide === 1 ? nextPath : currentHash;\n            currentHash = utils_1.generateHash(constants_1.BRANCH_PREFIX, leftHashBuffer, rightHashBuffer);\n            layerIndex = pairLayerIndex > layerIndex ? pairLayerIndex + 1 : layerIndex + 1;\n            nodeIndex =\n                dataLength === 2 ** (treeHeight - 1)\n                    ? Math.floor(pairNodeIndex / 2)\n                    : Math.floor(pairNodeIndex / 2 ** (layerIndex - pairLayerIndex));\n        }\n        if (!currentHash.equals(options.rootHash)) {\n            results.set(queryHash, false);\n            continue;\n        }\n        results.set(queryHash, true);\n    }\n    return results.entries().map(result => ({ hash: result[0], verified: result[1] }));\n};\nexports.verifyProof = verifyProof;\n//# sourceMappingURL=verify_proof.js.map"]},"metadata":{},"sourceType":"script"}