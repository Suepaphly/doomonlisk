{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WSChannel = void 0;\n\nvar WebSocket = require(\"isomorphic-ws\");\n\nvar events_1 = require(\"events\");\n\nvar utils_1 = require(\"./utils\");\n\nvar CONNECTION_TIMEOUT = 2000;\nvar RESPONSE_TIMEOUT = 3000;\n\nvar timeout = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ms, message) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", new Promise(function (_, reject) {\n              var id = setTimeout(function () {\n                clearTimeout(id);\n                reject(new Error(message !== null && message !== void 0 ? message : \"Timed out in \".concat(ms, \"ms.\")));\n              }, ms);\n            }));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function timeout(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar defer = function defer() {\n  var resolve;\n  var reject;\n  var promise = new Promise(function (_resolve, _reject) {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  return {\n    promise: promise,\n    resolve: resolve,\n    reject: reject\n  };\n};\n\nvar messageIsNotification = function messageIsNotification(input) {\n  return !!((input.id === undefined || input.id === null) && input.method);\n};\n\nvar WSChannel = /*#__PURE__*/function () {\n  function WSChannel(url) {\n    _classCallCheck(this, WSChannel);\n\n    this.isAlive = false;\n    this._requestCounter = 0;\n    this._pendingRequests = {};\n    this._url = url;\n    this._emitter = new events_1.EventEmitter();\n  }\n\n  _createClass(WSChannel, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this = this;\n\n        var connectHandler, errorHandler;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._ws = new WebSocket(this._url);\n                this._ws.onclose = this._handleClose.bind(this);\n                this._ws.onmessage = this._handleMessage.bind(this);\n\n                this._ws.addEventListener('ping', this._handlePing.bind(this));\n\n                connectHandler = new Promise(function (resolve) {\n                  var _a;\n\n                  var onOpen = function onOpen() {\n                    var _a;\n\n                    _this.isAlive = true;\n                    (_a = _this._ws) === null || _a === void 0 ? void 0 : _a.removeEventListener('open', onOpen);\n                    resolve();\n                  };\n\n                  (_a = _this._ws) === null || _a === void 0 ? void 0 : _a.addEventListener('open', onOpen);\n                });\n                errorHandler = new Promise(function (_, reject) {\n                  var _a;\n\n                  var onError = function onError(error) {\n                    var _a;\n\n                    _this.isAlive = false;\n                    (_a = _this._ws) === null || _a === void 0 ? void 0 : _a.removeEventListener('error', onError);\n                    reject(error.error);\n                  };\n\n                  (_a = _this._ws) === null || _a === void 0 ? void 0 : _a.addEventListener('error', onError);\n                });\n                _context2.prev = 6;\n                _context2.next = 9;\n                return Promise.race([connectHandler, errorHandler, timeout(CONNECTION_TIMEOUT, \"Could not connect in \".concat(CONNECTION_TIMEOUT, \"ms\"))]);\n\n              case 9:\n                _context2.next = 15;\n                break;\n\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](6);\n\n                this._ws.close();\n\n                throw _context2.t0;\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[6, 11]]);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var closeHandler;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._requestCounter = 0;\n                this._pendingRequests = {};\n\n                if (this._ws) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 4:\n                if (!(this._ws.readyState === WebSocket.CLOSED)) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                this.isAlive = false;\n                this._ws = undefined;\n                return _context3.abrupt(\"return\");\n\n              case 8:\n                closeHandler = new Promise(function (resolve) {\n                  var _a;\n\n                  var onClose = function onClose() {\n                    var _a;\n\n                    _this2.isAlive = false;\n                    (_a = _this2._ws) === null || _a === void 0 ? void 0 : _a.removeEventListener('close', onClose);\n                    resolve();\n                  };\n\n                  (_a = _this2._ws) === null || _a === void 0 ? void 0 : _a.addEventListener('close', onClose);\n                });\n\n                this._ws.close();\n\n                _context3.next = 12;\n                return Promise.race([closeHandler, timeout(CONNECTION_TIMEOUT, \"Could not disconnect in \".concat(CONNECTION_TIMEOUT, \"ms\"))]);\n\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }()\n  }, {\n    key: \"invoke\",\n    value: function () {\n      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(actionName, params) {\n        var _a, request, response;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.isAlive) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('Websocket client is not connected.');\n\n              case 2:\n                request = {\n                  jsonrpc: '2.0',\n                  id: this._requestCounter,\n                  method: actionName,\n                  params: params !== null && params !== void 0 ? params : {}\n                };\n                (_a = this._ws) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(request));\n                response = defer();\n                this._pendingRequests[this._requestCounter] = response;\n                this._requestCounter += 1;\n                return _context4.abrupt(\"return\", Promise.race([response.promise, timeout(RESPONSE_TIMEOUT, \"Response not received in \".concat(RESPONSE_TIMEOUT, \"ms\"))]));\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function invoke(_x3, _x4) {\n        return _invoke.apply(this, arguments);\n      }\n\n      return invoke;\n    }()\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(eventName, cb) {\n      this._emitter.on(eventName, cb);\n    }\n  }, {\n    key: \"_handleClose\",\n    value: function _handleClose() {\n      this.isAlive = false;\n    }\n  }, {\n    key: \"_handlePing\",\n    value: function _handlePing() {\n      this.isAlive = true;\n    }\n  }, {\n    key: \"_handleMessage\",\n    value: function _handleMessage(event) {\n      var res = JSON.parse(event.data);\n\n      if (messageIsNotification(res)) {\n        this._emitter.emit(res.method, res.params);\n      } else {\n        var id = typeof res.id === 'number' ? res.id : parseInt(res.id, 10);\n\n        if (this._pendingRequests[id]) {\n          if (res.error) {\n            this._pendingRequests[id].reject(utils_1.convertRPCError(res.error));\n          } else {\n            this._pendingRequests[id].resolve(res.result);\n          }\n\n          delete this._pendingRequests[id];\n        }\n      }\n    }\n  }]);\n\n  return WSChannel;\n}();\n\nexports.WSChannel = WSChannel;","map":{"version":3,"sources":["../src/ws_channel.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAeA,IAAA,SAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,IAAM,kBAAkB,GAAG,IAA3B;AACA,IAAM,gBAAgB,GAAG,IAAzB;;AAEA,IAAM,OAAO;AAAA,sEAAG,iBAAiB,EAAjB,EAA6B,OAA7B;AAAA;AAAA;AAAA;AAAA;AAAA,6CACf,IAAI,OAAJ,CAAY,UAAC,CAAD,EAAI,MAAJ,EAAc;AACzB,kBAAM,EAAE,GAAG,UAAU,CAAC,YAAK;AAC1B,gBAAA,YAAY,CAAC,EAAD,CAAZ;AACA,gBAAA,MAAM,CAAC,IAAI,KAAJ,CAAU,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,0BAA2B,EAA3B,QAAV,CAAD,CAAN;AACA,eAHoB,EAGlB,EAHkB,CAArB;AAIA,aALD,CADe;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAP,OAAO;AAAA;AAAA;AAAA,GAAb;;AAcA,IAAM,KAAK,GAAG,SAAR,KAAQ,GAAkB;AAC/B,MAAI,OAAJ;AACA,MAAI,MAAJ;AAEA,MAAM,OAAO,GAAG,IAAI,OAAJ,CAAe,UAAC,QAAD,EAAW,OAAX,EAAsB;AACpD,IAAA,OAAO,GAAG,QAAV;AACA,IAAA,MAAM,GAAG,OAAT;AACA,GAHe,CAAhB;AAKA,SAAO;AAAE,IAAA,OAAO,EAAP,OAAF;AAAW,IAAA,OAAO,EAAP,OAAX;AAAoB,IAAA,MAAM,EAAN;AAApB,GAAP;AACA,CAVD;;AAYA,IAAM,qBAAqB,GAAG,SAAxB,qBAAwB,CAC7B,KAD6B;AAAA,SAG7B,CAAC,EAAE,CAAC,KAAK,CAAC,EAAN,KAAa,SAAb,IAA0B,KAAK,CAAC,EAAN,KAAa,IAAxC,KAAiD,KAAK,CAAC,MAAzD,CAH4B;AAAA,CAA9B;;IAKa,S;AAUZ,qBAAmB,GAAnB,EAA8B;AAAA;;AATvB,SAAA,OAAA,GAAU,KAAV;AAGC,SAAA,eAAA,GAAkB,CAAlB;AACA,SAAA,gBAAA,GAEJ,EAFI;AAMP,SAAK,IAAL,GAAY,GAAZ;AACA,SAAK,QAAL,GAAgB,IAAI,QAAA,CAAA,YAAJ,EAAhB;AACA;;;;;8EAEM;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACN,qBAAK,GAAL,GAAW,IAAI,SAAJ,CAAc,KAAK,IAAnB,CAAX;AACA,qBAAK,GAAL,CAAS,OAAT,GAAmB,KAAK,YAAL,CAAkB,IAAlB,CAAuB,IAAvB,CAAnB;AACA,qBAAK,GAAL,CAAS,SAAT,GAAqB,KAAK,cAAL,CAAoB,IAApB,CAAyB,IAAzB,CAArB;;AACA,qBAAK,GAAL,CAAS,gBAAT,CAA0B,MAA1B,EAAkC,KAAK,WAAL,CAAiB,IAAjB,CAAsB,IAAtB,CAAlC;;AAEM,gBAAA,cANA,GAMiB,IAAI,OAAJ,CAAkB,UAAA,OAAO,EAAG;;;AAClD,sBAAM,MAAM,GAAG,SAAT,MAAS,GAAK;;;AACnB,oBAAA,KAAI,CAAC,OAAL,GAAe,IAAf;AACA,qBAAA,EAAA,GAAA,KAAI,CAAC,GAAL,MAAQ,IAAR,IAAQ,EAAA,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAQ,EAAA,CAAE,mBAAF,CAAsB,MAAtB,EAA8B,MAA9B,CAAR;AACA,oBAAA,OAAO;AACP,mBAJD;;AAMA,mBAAA,EAAA,GAAA,KAAI,CAAC,GAAL,MAAQ,IAAR,IAAQ,EAAA,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAQ,EAAA,CAAE,gBAAF,CAAmB,MAAnB,EAA2B,MAA3B,CAAR;AACA,iBARsB,CANjB;AAgBA,gBAAA,YAhBA,GAgBe,IAAI,OAAJ,CAAkB,UAAC,CAAD,EAAI,MAAJ,EAAc;;;AACpD,sBAAM,OAAO,GAAG,SAAV,OAAU,CAAC,KAAD,EAAgC;;;AAC/C,oBAAA,KAAI,CAAC,OAAL,GAAe,KAAf;AACA,qBAAA,EAAA,GAAA,KAAI,CAAC,GAAL,MAAQ,IAAR,IAAQ,EAAA,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAQ,EAAA,CAAE,mBAAF,CAAsB,OAAtB,EAA+B,OAA/B,CAAR;AACA,oBAAA,MAAM,CAAC,KAAK,CAAC,KAAP,CAAN;AACA,mBAJD;;AAMA,mBAAA,EAAA,GAAA,KAAI,CAAC,GAAL,MAAQ,IAAR,IAAQ,EAAA,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAQ,EAAA,CAAE,gBAAF,CAAmB,OAAnB,EAA4B,OAA5B,CAAR;AACA,iBARoB,CAhBf;AAAA;AAAA;AAAA,uBA2BC,OAAO,CAAC,IAAR,CAAa,CAClB,cADkB,EAElB,YAFkB,EAGlB,OAAO,CAAC,kBAAD,iCAA6C,kBAA7C,QAHW,CAAb,CA3BD;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAiCL,qBAAK,GAAL,CAAS,KAAT;;AAjCK;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;iFAuCA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACN,qBAAK,eAAL,GAAuB,CAAvB;AACA,qBAAK,gBAAL,GAAwB,EAAxB;;AAFM,oBAID,KAAK,GAJJ;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,sBAQF,KAAK,GAAL,CAAS,UAAT,KAAwB,SAAS,CAAC,MARhC;AAAA;AAAA;AAAA;;AASL,qBAAK,OAAL,GAAe,KAAf;AACA,qBAAK,GAAL,GAAW,SAAX;AAVK;;AAAA;AAcA,gBAAA,YAdA,GAce,IAAI,OAAJ,CAAkB,UAAA,OAAO,EAAG;;;AAChD,sBAAM,OAAO,GAAG,SAAV,OAAU,GAAK;;;AACpB,oBAAA,MAAI,CAAC,OAAL,GAAe,KAAf;AACA,qBAAA,EAAA,GAAA,MAAI,CAAC,GAAL,MAAQ,IAAR,IAAQ,EAAA,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAQ,EAAA,CAAE,mBAAF,CAAsB,OAAtB,EAA+B,OAA/B,CAAR;AACA,oBAAA,OAAO;AACP,mBAJD;;AAMA,mBAAA,EAAA,GAAA,MAAI,CAAC,GAAL,MAAQ,IAAR,IAAQ,EAAA,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAQ,EAAA,CAAE,gBAAF,CAAmB,OAAnB,EAA4B,OAA5B,CAAR;AACA,iBARoB,CAdf;;AAwBN,qBAAK,GAAL,CAAS,KAAT;;AAxBM;AAAA,uBAyBA,OAAO,CAAC,IAAR,CAAa,CAClB,YADkB,EAElB,OAAO,CAAC,kBAAD,oCAAgD,kBAAhD,QAFW,CAAb,CAzBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;6EA+BA,kBACN,UADM,EAEN,MAFM;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,oBAID,KAAK,OAJJ;AAAA;AAAA;AAAA;;AAAA,sBAKC,IAAI,KAAJ,CAAU,oCAAV,CALD;;AAAA;AAQA,gBAAA,OARA,GAQU;AACf,kBAAA,OAAO,EAAE,KADM;AAEf,kBAAA,EAAE,EAAE,KAAK,eAFM;AAGf,kBAAA,MAAM,EAAE,UAHO;AAIf,kBAAA,MAAM,EAAE,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAA,MAAA,GAAU;AAJH,iBARV;AAeN,iBAAA,EAAA,GAAA,KAAK,GAAL,MAAQ,IAAR,IAAQ,EAAA,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAQ,EAAA,CAAE,IAAF,CAAO,IAAI,CAAC,SAAL,CAAe,OAAf,CAAP,CAAR;AAEM,gBAAA,QAjBA,GAiBW,KAAK,EAjBhB;AAkBN,qBAAK,gBAAL,CAAsB,KAAK,eAA3B,IAA8C,QAA9C;AACA,qBAAK,eAAL,IAAwB,CAAxB;AAnBM,kDAqBC,OAAO,CAAC,IAAR,CAAgB,CACtB,QAAQ,CAAC,OADa,EAEtB,OAAO,CAAI,gBAAJ,qCAAkD,gBAAlD,QAFe,CAAhB,CArBD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WA2BA,mBAAuC,SAAvC,EAA0D,EAA1D,EAA8E;AAEpF,WAAK,QAAL,CAAc,EAAd,CAAiB,SAAjB,EAA4B,EAA5B;AACA;;;WAEO,wBAAY;AACnB,WAAK,OAAL,GAAe,KAAf;AACA;;;WAEO,uBAAW;AAClB,WAAK,OAAL,GAAe,IAAf;AACA;;;WAEO,wBAAe,KAAf,EAA4C;AACnD,UAAM,GAAG,GAAG,IAAI,CAAC,KAAL,CAAW,KAAK,CAAC,IAAjB,CAAZ;;AAGA,UAAI,qBAAqB,CAAC,GAAD,CAAzB,EAAgC;AAC/B,aAAK,QAAL,CAAc,IAAd,CAAmB,GAAG,CAAC,MAAvB,EAA+B,GAAG,CAAC,MAAnC;AAGA,OAJD,MAIO;AACN,YAAM,EAAE,GAAG,OAAO,GAAG,CAAC,EAAX,KAAkB,QAAlB,GAA6B,GAAG,CAAC,EAAjC,GAAsC,QAAQ,CAAC,GAAG,CAAC,EAAL,EAAmB,EAAnB,CAAzD;;AAEA,YAAI,KAAK,gBAAL,CAAsB,EAAtB,CAAJ,EAA+B;AAC9B,cAAI,GAAG,CAAC,KAAR,EAAe;AACd,iBAAK,gBAAL,CAAsB,EAAtB,EAA0B,MAA1B,CAAiC,OAAA,CAAA,eAAA,CAAgB,GAAG,CAAC,KAApB,CAAjC;AACA,WAFD,MAEO;AACN,iBAAK,gBAAL,CAAsB,EAAtB,EAA0B,OAA1B,CAAkC,GAAG,CAAC,MAAtC;AACA;;AAED,iBAAO,KAAK,gBAAL,CAAsB,EAAtB,CAAP;AACA;AACD;AACD;;;;;;AAlJF,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WSChannel = void 0;\nconst WebSocket = require(\"isomorphic-ws\");\nconst events_1 = require(\"events\");\nconst utils_1 = require(\"./utils\");\nconst CONNECTION_TIMEOUT = 2000;\nconst RESPONSE_TIMEOUT = 3000;\nconst timeout = async (ms, message) => new Promise((_, reject) => {\n    const id = setTimeout(() => {\n        clearTimeout(id);\n        reject(new Error(message !== null && message !== void 0 ? message : `Timed out in ${ms}ms.`));\n    }, ms);\n});\nconst defer = () => {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n    });\n    return { promise, resolve, reject };\n};\nconst messageIsNotification = (input) => !!((input.id === undefined || input.id === null) && input.method);\nclass WSChannel {\n    constructor(url) {\n        this.isAlive = false;\n        this._requestCounter = 0;\n        this._pendingRequests = {};\n        this._url = url;\n        this._emitter = new events_1.EventEmitter();\n    }\n    async connect() {\n        this._ws = new WebSocket(this._url);\n        this._ws.onclose = this._handleClose.bind(this);\n        this._ws.onmessage = this._handleMessage.bind(this);\n        this._ws.addEventListener('ping', this._handlePing.bind(this));\n        const connectHandler = new Promise(resolve => {\n            var _a;\n            const onOpen = () => {\n                var _a;\n                this.isAlive = true;\n                (_a = this._ws) === null || _a === void 0 ? void 0 : _a.removeEventListener('open', onOpen);\n                resolve();\n            };\n            (_a = this._ws) === null || _a === void 0 ? void 0 : _a.addEventListener('open', onOpen);\n        });\n        const errorHandler = new Promise((_, reject) => {\n            var _a;\n            const onError = (error) => {\n                var _a;\n                this.isAlive = false;\n                (_a = this._ws) === null || _a === void 0 ? void 0 : _a.removeEventListener('error', onError);\n                reject(error.error);\n            };\n            (_a = this._ws) === null || _a === void 0 ? void 0 : _a.addEventListener('error', onError);\n        });\n        try {\n            await Promise.race([\n                connectHandler,\n                errorHandler,\n                timeout(CONNECTION_TIMEOUT, `Could not connect in ${CONNECTION_TIMEOUT}ms`),\n            ]);\n        }\n        catch (err) {\n            this._ws.close();\n            throw err;\n        }\n    }\n    async disconnect() {\n        this._requestCounter = 0;\n        this._pendingRequests = {};\n        if (!this._ws) {\n            return;\n        }\n        if (this._ws.readyState === WebSocket.CLOSED) {\n            this.isAlive = false;\n            this._ws = undefined;\n            return;\n        }\n        const closeHandler = new Promise(resolve => {\n            var _a;\n            const onClose = () => {\n                var _a;\n                this.isAlive = false;\n                (_a = this._ws) === null || _a === void 0 ? void 0 : _a.removeEventListener('close', onClose);\n                resolve();\n            };\n            (_a = this._ws) === null || _a === void 0 ? void 0 : _a.addEventListener('close', onClose);\n        });\n        this._ws.close();\n        await Promise.race([\n            closeHandler,\n            timeout(CONNECTION_TIMEOUT, `Could not disconnect in ${CONNECTION_TIMEOUT}ms`),\n        ]);\n    }\n    async invoke(actionName, params) {\n        var _a;\n        if (!this.isAlive) {\n            throw new Error('Websocket client is not connected.');\n        }\n        const request = {\n            jsonrpc: '2.0',\n            id: this._requestCounter,\n            method: actionName,\n            params: params !== null && params !== void 0 ? params : {},\n        };\n        (_a = this._ws) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify(request));\n        const response = defer();\n        this._pendingRequests[this._requestCounter] = response;\n        this._requestCounter += 1;\n        return Promise.race([\n            response.promise,\n            timeout(RESPONSE_TIMEOUT, `Response not received in ${RESPONSE_TIMEOUT}ms`),\n        ]);\n    }\n    subscribe(eventName, cb) {\n        this._emitter.on(eventName, cb);\n    }\n    _handleClose() {\n        this.isAlive = false;\n    }\n    _handlePing() {\n        this.isAlive = true;\n    }\n    _handleMessage(event) {\n        const res = JSON.parse(event.data);\n        if (messageIsNotification(res)) {\n            this._emitter.emit(res.method, res.params);\n        }\n        else {\n            const id = typeof res.id === 'number' ? res.id : parseInt(res.id, 10);\n            if (this._pendingRequests[id]) {\n                if (res.error) {\n                    this._pendingRequests[id].reject(utils_1.convertRPCError(res.error));\n                }\n                else {\n                    this._pendingRequests[id].resolve(res.result);\n                }\n                delete this._pendingRequests[id];\n            }\n        }\n    }\n}\nexports.WSChannel = WSChannel;\n//# sourceMappingURL=ws_channel.js.map"]},"metadata":{},"sourceType":"script"}