{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RegisterAsset = exports.MAX_KEYS_COUNT = exports.RegisterAssetID = void 0;\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar base_asset_1 = require(\"../base_asset\");\n\nvar schemas_1 = require(\"./schemas\");\n\nvar setMemberAccounts = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(store, membersPublicKeys) {\n    var _iterator, _step, memberPublicKey, address, memberAccount;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _iterator = _createForOfIteratorHelper(membersPublicKeys);\n            _context.prev = 1;\n\n            _iterator.s();\n\n          case 3:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 13;\n              break;\n            }\n\n            memberPublicKey = _step.value;\n            address = lisk_cryptography_1.getAddressFromPublicKey(memberPublicKey);\n            _context.next = 8;\n            return store.account.getOrDefault(address);\n\n          case 8:\n            memberAccount = _context.sent;\n            _context.next = 11;\n            return store.account.set(memberAccount.address, memberAccount);\n\n          case 11:\n            _context.next = 3;\n            break;\n\n          case 13:\n            _context.next = 18;\n            break;\n\n          case 15:\n            _context.prev = 15;\n            _context.t0 = _context[\"catch\"](1);\n\n            _iterator.e(_context.t0);\n\n          case 18:\n            _context.prev = 18;\n\n            _iterator.f();\n\n            return _context.finish(18);\n\n          case 21:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 15, 18, 21]]);\n  }));\n\n  return function setMemberAccounts(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.RegisterAssetID = 0;\nexports.MAX_KEYS_COUNT = 64;\n\nvar RegisterAsset = /*#__PURE__*/function (_base_asset_1$BaseAss) {\n  _inherits(RegisterAsset, _base_asset_1$BaseAss);\n\n  var _super = _createSuper(RegisterAsset);\n\n  function RegisterAsset() {\n    var _this;\n\n    _classCallCheck(this, RegisterAsset);\n\n    _this = _super.apply(this, arguments);\n    _this.name = 'registerMultisignatureGroup';\n    _this.id = exports.RegisterAssetID;\n    _this.schema = schemas_1.keysSchema;\n    return _this;\n  }\n\n  _createClass(RegisterAsset, [{\n    key: \"validate\",\n    value: function validate(_ref2) {\n      var asset = _ref2.asset,\n          transaction = _ref2.transaction;\n      var mandatoryKeys = asset.mandatoryKeys,\n          optionalKeys = asset.optionalKeys,\n          numberOfSignatures = asset.numberOfSignatures;\n\n      if (!lisk_utils_1.objects.bufferArrayUniqueItems(mandatoryKeys)) {\n        throw new Error('MandatoryKeys contains duplicate public keys.');\n      }\n\n      if (!lisk_utils_1.objects.bufferArrayUniqueItems(optionalKeys)) {\n        throw new Error('OptionalKeys contains duplicate public keys.');\n      }\n\n      if (mandatoryKeys.length + optionalKeys.length < numberOfSignatures) {\n        throw new Error('The numberOfSignatures is bigger than the count of Mandatory and Optional keys.');\n      }\n\n      if (mandatoryKeys.length + optionalKeys.length > exports.MAX_KEYS_COUNT || mandatoryKeys.length + optionalKeys.length <= 0) {\n        throw new Error('The count of Mandatory and Optional keys should be between 1 and 64.');\n      }\n\n      if (mandatoryKeys.length > numberOfSignatures) {\n        throw new Error('The numberOfSignatures needs to be equal or bigger than the number of Mandatory keys.');\n      }\n\n      var repeatedKeys = mandatoryKeys.filter(function (value) {\n        return optionalKeys.find(function (optional) {\n          return optional.equals(value);\n        }) !== undefined;\n      });\n\n      if (repeatedKeys.length > 0) {\n        throw new Error('Invalid combination of Mandatory and Optional keys. Repeated keys across Mandatory and Optional were found.');\n      }\n\n      if (mandatoryKeys.length + optionalKeys.length + 1 !== transaction.signatures.length) {\n        throw new Error('The number of mandatory, optional and sender keys should match the number of signatures');\n      }\n\n      var sortedMandatoryKeys = _toConsumableArray(mandatoryKeys).sort(function (a, b) {\n        return a.compare(b);\n      });\n\n      var sortedOptionalKeys = _toConsumableArray(optionalKeys).sort(function (a, b) {\n        return a.compare(b);\n      });\n\n      for (var i = 0; i < sortedMandatoryKeys.length; i += 1) {\n        if (!mandatoryKeys[i].equals(sortedMandatoryKeys[i])) {\n          throw new Error('Mandatory keys should be sorted lexicographically.');\n        }\n      }\n\n      for (var _i = 0; _i < sortedOptionalKeys.length; _i += 1) {\n        if (!optionalKeys[_i].equals(sortedOptionalKeys[_i])) {\n          throw new Error('Optional keys should be sorted lexicographically.');\n        }\n      }\n    }\n  }, {\n    key: \"apply\",\n    value: function () {\n      var _apply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n        var asset, stateStore, transaction, sender;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                asset = _ref3.asset, stateStore = _ref3.stateStore, transaction = _ref3.transaction;\n                _context2.next = 3;\n                return stateStore.account.get(transaction.senderAddress);\n\n              case 3:\n                sender = _context2.sent;\n\n                if (!(sender.keys.numberOfSignatures > 0)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw new Error('Register multisignature only allowed once per account.');\n\n              case 6:\n                sender.keys = {\n                  numberOfSignatures: asset.numberOfSignatures,\n                  mandatoryKeys: asset.mandatoryKeys,\n                  optionalKeys: asset.optionalKeys\n                };\n                _context2.next = 9;\n                return stateStore.account.set(sender.address, sender);\n\n              case 9:\n                _context2.next = 11;\n                return setMemberAccounts(stateStore, sender.keys.mandatoryKeys);\n\n              case 11:\n                _context2.next = 13;\n                return setMemberAccounts(stateStore, sender.keys.optionalKeys);\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function apply(_x3) {\n        return _apply.apply(this, arguments);\n      }\n\n      return apply;\n    }()\n  }]);\n\n  return RegisterAsset;\n}(base_asset_1.BaseAsset);\n\nexports.RegisterAsset = RegisterAsset;","map":{"version":3,"sources":["../../../src/modules/keys/register_asset.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RegisterAsset = exports.MAX_KEYS_COUNT = exports.RegisterAssetID = void 0;\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst base_asset_1 = require(\"../base_asset\");\nconst schemas_1 = require(\"./schemas\");\nconst setMemberAccounts = async (store, membersPublicKeys) => {\n    for (const memberPublicKey of membersPublicKeys) {\n        const address = lisk_cryptography_1.getAddressFromPublicKey(memberPublicKey);\n        const memberAccount = await store.account.getOrDefault(address);\n        await store.account.set(memberAccount.address, memberAccount);\n    }\n};\nexports.RegisterAssetID = 0;\nexports.MAX_KEYS_COUNT = 64;\nclass RegisterAsset extends base_asset_1.BaseAsset {\n    constructor() {\n        super(...arguments);\n        this.name = 'registerMultisignatureGroup';\n        this.id = exports.RegisterAssetID;\n        this.schema = schemas_1.keysSchema;\n    }\n    validate({ asset, transaction }) {\n        const { mandatoryKeys, optionalKeys, numberOfSignatures } = asset;\n        if (!lisk_utils_1.objects.bufferArrayUniqueItems(mandatoryKeys)) {\n            throw new Error('MandatoryKeys contains duplicate public keys.');\n        }\n        if (!lisk_utils_1.objects.bufferArrayUniqueItems(optionalKeys)) {\n            throw new Error('OptionalKeys contains duplicate public keys.');\n        }\n        if (mandatoryKeys.length + optionalKeys.length < numberOfSignatures) {\n            throw new Error('The numberOfSignatures is bigger than the count of Mandatory and Optional keys.');\n        }\n        if (mandatoryKeys.length + optionalKeys.length > exports.MAX_KEYS_COUNT ||\n            mandatoryKeys.length + optionalKeys.length <= 0) {\n            throw new Error('The count of Mandatory and Optional keys should be between 1 and 64.');\n        }\n        if (mandatoryKeys.length > numberOfSignatures) {\n            throw new Error('The numberOfSignatures needs to be equal or bigger than the number of Mandatory keys.');\n        }\n        const repeatedKeys = mandatoryKeys.filter(value => optionalKeys.find(optional => optional.equals(value)) !== undefined);\n        if (repeatedKeys.length > 0) {\n            throw new Error('Invalid combination of Mandatory and Optional keys. Repeated keys across Mandatory and Optional were found.');\n        }\n        if (mandatoryKeys.length + optionalKeys.length + 1 !== transaction.signatures.length) {\n            throw new Error('The number of mandatory, optional and sender keys should match the number of signatures');\n        }\n        const sortedMandatoryKeys = [...mandatoryKeys].sort((a, b) => a.compare(b));\n        const sortedOptionalKeys = [...optionalKeys].sort((a, b) => a.compare(b));\n        for (let i = 0; i < sortedMandatoryKeys.length; i += 1) {\n            if (!mandatoryKeys[i].equals(sortedMandatoryKeys[i])) {\n                throw new Error('Mandatory keys should be sorted lexicographically.');\n            }\n        }\n        for (let i = 0; i < sortedOptionalKeys.length; i += 1) {\n            if (!optionalKeys[i].equals(sortedOptionalKeys[i])) {\n                throw new Error('Optional keys should be sorted lexicographically.');\n            }\n        }\n    }\n    async apply({ asset, stateStore, transaction }) {\n        const sender = await stateStore.account.get(transaction.senderAddress);\n        if (sender.keys.numberOfSignatures > 0) {\n            throw new Error('Register multisignature only allowed once per account.');\n        }\n        sender.keys = {\n            numberOfSignatures: asset.numberOfSignatures,\n            mandatoryKeys: asset.mandatoryKeys,\n            optionalKeys: asset.optionalKeys,\n        };\n        await stateStore.account.set(sender.address, sender);\n        await setMemberAccounts(stateStore, sender.keys.mandatoryKeys);\n        await setMemberAccounts(stateStore, sender.keys.optionalKeys);\n    }\n}\nexports.RegisterAsset = RegisterAsset;\n//# sourceMappingURL=register_asset.js.map"]},"metadata":{},"sourceType":"script"}