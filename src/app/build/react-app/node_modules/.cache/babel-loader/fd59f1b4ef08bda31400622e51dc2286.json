{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AccountStore = void 0;\n\nvar lisk_db_1 = require(\"@liskhq/lisk-db\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar constants_1 = require(\"../data_access/constants\");\n\nvar utils_1 = require(\"../utils\");\n\nvar AccountStore = /*#__PURE__*/function () {\n  function AccountStore(dataAccess, additionalInformation) {\n    _classCallCheck(this, AccountStore);\n\n    this._dataAccess = dataAccess;\n    this._data = new lisk_utils_1.dataStructures.BufferMap();\n    this._updatedKeys = new lisk_utils_1.dataStructures.BufferSet();\n    this._deletedKeys = new lisk_utils_1.dataStructures.BufferSet();\n    this._originalData = new lisk_utils_1.dataStructures.BufferMap();\n    this._originalUpdatedKeys = new lisk_utils_1.dataStructures.BufferSet();\n    this._originalDeletedKeys = new lisk_utils_1.dataStructures.BufferSet();\n    this._defaultAccount = additionalInformation.defaultAccount;\n    this._initialAccountValue = new lisk_utils_1.dataStructures.BufferMap();\n  }\n\n  _createClass(AccountStore, [{\n    key: \"createSnapshot\",\n    value: function createSnapshot() {\n      this._originalData = this._data.clone();\n      this._originalUpdatedKeys = this._updatedKeys.clone();\n      this._originalDeletedKeys = this._deletedKeys.clone();\n    }\n  }, {\n    key: \"restoreSnapshot\",\n    value: function restoreSnapshot() {\n      this._data = this._originalData;\n      this._updatedKeys = this._originalUpdatedKeys;\n      this._deletedKeys = this._originalDeletedKeys;\n      this._originalData = new lisk_utils_1.dataStructures.BufferMap();\n      this._originalUpdatedKeys = new lisk_utils_1.dataStructures.BufferSet();\n      this._originalDeletedKeys = new lisk_utils_1.dataStructures.BufferSet();\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address) {\n        var cachedAccount, encodedAccount, account;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                cachedAccount = this._data.get(address);\n\n                if (!cachedAccount) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", lisk_utils_1.objects.cloneDeep(cachedAccount));\n\n              case 3:\n                if (!this._deletedKeys.has(address)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new lisk_db_1.NotFoundError(\"Account \".concat(address.toString('hex'), \" has been deleted\"));\n\n              case 5:\n                _context.next = 7;\n                return this._dataAccess.getEncodedAccountByAddress(address);\n\n              case 7:\n                encodedAccount = _context.sent;\n                account = this._getAccountInstance(encodedAccount);\n\n                this._data.set(address, account);\n\n                this._initialAccountValue.set(address, encodedAccount);\n\n                return _context.abrupt(\"return\", account);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"getOrDefault\",\n    value: function () {\n      var _getOrDefault = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address) {\n        var cachedAccount, encodedAccount, account, defaultAccount;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cachedAccount = this._data.get(address);\n\n                if (!cachedAccount) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", lisk_utils_1.objects.cloneDeep(cachedAccount));\n\n              case 3:\n                _context2.prev = 3;\n                _context2.next = 6;\n                return this._dataAccess.getEncodedAccountByAddress(address);\n\n              case 6:\n                encodedAccount = _context2.sent;\n                account = this._getAccountInstance(encodedAccount);\n\n                this._data.set(address, account);\n\n                this._initialAccountValue.set(address, encodedAccount);\n\n                return _context2.abrupt(\"return\", account);\n\n              case 13:\n                _context2.prev = 13;\n                _context2.t0 = _context2[\"catch\"](3);\n\n                if (_context2.t0 instanceof lisk_db_1.NotFoundError) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                throw _context2.t0;\n\n              case 17:\n                defaultAccount = _objectSpread({\n                  address: address\n                }, lisk_utils_1.objects.cloneDeep(this._defaultAccount));\n\n                this._data.set(address, defaultAccount);\n\n                return _context2.abrupt(\"return\", defaultAccount);\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[3, 13]]);\n      }));\n\n      function getOrDefault(_x2) {\n        return _getOrDefault.apply(this, arguments);\n      }\n\n      return getOrDefault;\n    }()\n  }, {\n    key: \"getUpdated\",\n    value: function getUpdated() {\n      return _toConsumableArray(this._data.values());\n    }\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(address, updatedElement) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._data.set(address, updatedElement);\n\n                this._updatedKeys.add(address);\n\n                this._deletedKeys.delete(address);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function set(_x3, _x4) {\n        return _set.apply(this, arguments);\n      }\n\n      return set;\n    }()\n  }, {\n    key: \"del\",\n    value: function () {\n      var _del = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(address) {\n        var initialAccount;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.get(address);\n\n              case 2:\n                initialAccount = this._initialAccountValue.get(address);\n\n                if (initialAccount !== undefined) {\n                  this._deletedKeys.add(address);\n                }\n\n                this._updatedKeys.delete(address);\n\n                this._data.delete(address);\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function del(_x5) {\n        return _del.apply(this, arguments);\n      }\n\n      return del;\n    }()\n  }, {\n    key: \"finalize\",\n    value: function finalize(batch) {\n      var stateDiff = {\n        updated: [],\n        created: [],\n        deleted: []\n      };\n\n      var _iterator = _createForOfIteratorHelper(this._data.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var updatedAccount = _step.value;\n\n          if (this._updatedKeys.has(updatedAccount.address)) {\n            var encodedAccount = this._dataAccess.encodeAccount(updatedAccount);\n\n            var dbKey = \"\".concat(constants_1.DB_KEY_ACCOUNTS_ADDRESS, \":\").concat(utils_1.keyString(updatedAccount.address));\n            batch.put(dbKey, encodedAccount);\n\n            var initialAccount = this._initialAccountValue.get(updatedAccount.address);\n\n            if (initialAccount !== undefined && !initialAccount.equals(encodedAccount)) {\n              stateDiff.updated.push({\n                key: dbKey,\n                value: initialAccount\n              });\n            } else if (initialAccount === undefined) {\n              stateDiff.created.push(dbKey);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this._deletedKeys),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var deletedAddress = _step2.value;\n\n          var _initialAccount = this._initialAccountValue.get(deletedAddress);\n\n          if (!_initialAccount) {\n            throw new Error('Deleting account should have initial account');\n          }\n\n          var _dbKey = \"\".concat(constants_1.DB_KEY_ACCOUNTS_ADDRESS, \":\").concat(utils_1.keyString(deletedAddress));\n\n          batch.del(_dbKey);\n          stateDiff.deleted.push({\n            key: _dbKey,\n            value: _initialAccount\n          });\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return stateDiff;\n    }\n  }, {\n    key: \"_getAccountInstance\",\n    value: function _getAccountInstance(encodedAccount) {\n      var decodedAccount = this._dataAccess.decodeAccount(encodedAccount);\n\n      return lisk_utils_1.objects.cloneDeep(decodedAccount);\n    }\n  }]);\n\n  return AccountStore;\n}();\n\nexports.AccountStore = AccountStore;","map":{"version":3,"sources":["../../src/state_store/account_store.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AccountStore = void 0;\nconst lisk_db_1 = require(\"@liskhq/lisk-db\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst constants_1 = require(\"../data_access/constants\");\nconst utils_1 = require(\"../utils\");\nclass AccountStore {\n    constructor(dataAccess, additionalInformation) {\n        this._dataAccess = dataAccess;\n        this._data = new lisk_utils_1.dataStructures.BufferMap();\n        this._updatedKeys = new lisk_utils_1.dataStructures.BufferSet();\n        this._deletedKeys = new lisk_utils_1.dataStructures.BufferSet();\n        this._originalData = new lisk_utils_1.dataStructures.BufferMap();\n        this._originalUpdatedKeys = new lisk_utils_1.dataStructures.BufferSet();\n        this._originalDeletedKeys = new lisk_utils_1.dataStructures.BufferSet();\n        this._defaultAccount = additionalInformation.defaultAccount;\n        this._initialAccountValue = new lisk_utils_1.dataStructures.BufferMap();\n    }\n    createSnapshot() {\n        this._originalData = this._data.clone();\n        this._originalUpdatedKeys = this._updatedKeys.clone();\n        this._originalDeletedKeys = this._deletedKeys.clone();\n    }\n    restoreSnapshot() {\n        this._data = this._originalData;\n        this._updatedKeys = this._originalUpdatedKeys;\n        this._deletedKeys = this._originalDeletedKeys;\n        this._originalData = new lisk_utils_1.dataStructures.BufferMap();\n        this._originalUpdatedKeys = new lisk_utils_1.dataStructures.BufferSet();\n        this._originalDeletedKeys = new lisk_utils_1.dataStructures.BufferSet();\n    }\n    async get(address) {\n        const cachedAccount = this._data.get(address);\n        if (cachedAccount) {\n            return lisk_utils_1.objects.cloneDeep(cachedAccount);\n        }\n        if (this._deletedKeys.has(address)) {\n            throw new lisk_db_1.NotFoundError(`Account ${address.toString('hex')} has been deleted`);\n        }\n        const encodedAccount = await this._dataAccess.getEncodedAccountByAddress(address);\n        const account = this._getAccountInstance(encodedAccount);\n        this._data.set(address, account);\n        this._initialAccountValue.set(address, encodedAccount);\n        return account;\n    }\n    async getOrDefault(address) {\n        const cachedAccount = this._data.get(address);\n        if (cachedAccount) {\n            return lisk_utils_1.objects.cloneDeep(cachedAccount);\n        }\n        try {\n            const encodedAccount = await this._dataAccess.getEncodedAccountByAddress(address);\n            const account = this._getAccountInstance(encodedAccount);\n            this._data.set(address, account);\n            this._initialAccountValue.set(address, encodedAccount);\n            return account;\n        }\n        catch (error) {\n            if (!(error instanceof lisk_db_1.NotFoundError)) {\n                throw error;\n            }\n        }\n        const defaultAccount = {\n            address,\n            ...lisk_utils_1.objects.cloneDeep(this._defaultAccount),\n        };\n        this._data.set(address, defaultAccount);\n        return defaultAccount;\n    }\n    getUpdated() {\n        return [...this._data.values()];\n    }\n    async set(address, updatedElement) {\n        this._data.set(address, updatedElement);\n        this._updatedKeys.add(address);\n        this._deletedKeys.delete(address);\n    }\n    async del(address) {\n        await this.get(address);\n        const initialAccount = this._initialAccountValue.get(address);\n        if (initialAccount !== undefined) {\n            this._deletedKeys.add(address);\n        }\n        this._updatedKeys.delete(address);\n        this._data.delete(address);\n    }\n    finalize(batch) {\n        const stateDiff = { updated: [], created: [], deleted: [] };\n        for (const updatedAccount of this._data.values()) {\n            if (this._updatedKeys.has(updatedAccount.address)) {\n                const encodedAccount = this._dataAccess.encodeAccount(updatedAccount);\n                const dbKey = `${constants_1.DB_KEY_ACCOUNTS_ADDRESS}:${utils_1.keyString(updatedAccount.address)}`;\n                batch.put(dbKey, encodedAccount);\n                const initialAccount = this._initialAccountValue.get(updatedAccount.address);\n                if (initialAccount !== undefined && !initialAccount.equals(encodedAccount)) {\n                    stateDiff.updated.push({\n                        key: dbKey,\n                        value: initialAccount,\n                    });\n                }\n                else if (initialAccount === undefined) {\n                    stateDiff.created.push(dbKey);\n                }\n            }\n        }\n        for (const deletedAddress of this._deletedKeys) {\n            const initialAccount = this._initialAccountValue.get(deletedAddress);\n            if (!initialAccount) {\n                throw new Error('Deleting account should have initial account');\n            }\n            const dbKey = `${constants_1.DB_KEY_ACCOUNTS_ADDRESS}:${utils_1.keyString(deletedAddress)}`;\n            batch.del(dbKey);\n            stateDiff.deleted.push({\n                key: dbKey,\n                value: initialAccount,\n            });\n        }\n        return stateDiff;\n    }\n    _getAccountInstance(encodedAccount) {\n        const decodedAccount = this._dataAccess.decodeAccount(encodedAccount);\n        return lisk_utils_1.objects.cloneDeep(decodedAccount);\n    }\n}\nexports.AccountStore = AccountStore;\n//# sourceMappingURL=account_store.js.map"]},"metadata":{},"sourceType":"script"}