{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPeers = void 0;\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nvar utils_1 = require(\"../utils\");\n\nvar getPeerSchema = {\n  type: 'object',\n  properties: {\n    limit: {\n      type: 'string',\n      format: 'uint32',\n      description: 'Number of peers to be returned'\n    },\n    offset: {\n      type: 'string',\n      format: 'uint32',\n      description: 'Offset to get peers after a specific point in a peer list'\n    },\n    state: {\n      type: 'string',\n      enum: ['connected', 'disconnected']\n    }\n  }\n};\nvar PeerState;\n\n(function (PeerState) {\n  PeerState[\"connected\"] = \"connected\";\n  PeerState[\"disconnected\"] = \"disconnected\";\n})(PeerState || (PeerState = {}));\n\nvar getPeers = function getPeers(channel) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(req, res, next) {\n      var errors, _req$query, _req$query$limit, limit, _req$query$offset, offset, _req$query$state, state, peers;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              errors = lisk_validator_1.validator.validate(getPeerSchema, req.query);\n\n              if (!errors.length) {\n                _context.next = 4;\n                break;\n              }\n\n              res.status(400).send({\n                errors: [{\n                  message: new lisk_validator_1.LiskValidationError(_toConsumableArray(errors)).message\n                }]\n              });\n              return _context.abrupt(\"return\");\n\n            case 4:\n              _req$query = req.query, _req$query$limit = _req$query.limit, limit = _req$query$limit === void 0 ? 100 : _req$query$limit, _req$query$offset = _req$query.offset, offset = _req$query$offset === void 0 ? 0 : _req$query$offset, _req$query$state = _req$query.state, state = _req$query$state === void 0 ? PeerState.connected : _req$query$state;\n              _context.prev = 5;\n\n              if (!(state === PeerState.disconnected)) {\n                _context.next = 12;\n                break;\n              }\n\n              _context.next = 9;\n              return channel.invoke('app:getDisconnectedPeers');\n\n            case 9:\n              peers = _context.sent;\n              _context.next = 15;\n              break;\n\n            case 12:\n              _context.next = 14;\n              return channel.invoke('app:getConnectedPeers');\n\n            case 14:\n              peers = _context.sent;\n\n            case 15:\n              res.status(200).json({\n                meta: {\n                  count: peers.length,\n                  limit: +limit,\n                  offset: +offset\n                },\n                data: utils_1.paginateList(peers, +limit, +offset)\n              });\n              _context.next = 21;\n              break;\n\n            case 18:\n              _context.prev = 18;\n              _context.t0 = _context[\"catch\"](5);\n              next(_context.t0);\n\n            case 21:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[5, 18]]);\n    }));\n\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n\nexports.getPeers = getPeers;","map":{"version":3,"sources":["../../src/controllers/peers.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAcA,IAAA,gBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,IAAM,aAAa,GAAG;AACrB,EAAA,IAAI,EAAE,QADe;AAErB,EAAA,UAAU,EAAE;AACX,IAAA,KAAK,EAAE;AACN,MAAA,IAAI,EAAE,QADA;AAEN,MAAA,MAAM,EAAE,QAFF;AAGN,MAAA,WAAW,EAAE;AAHP,KADI;AAMX,IAAA,MAAM,EAAE;AACP,MAAA,IAAI,EAAE,QADC;AAEP,MAAA,MAAM,EAAE,QAFD;AAGP,MAAA,WAAW,EAAE;AAHN,KANG;AAWX,IAAA,KAAK,EAAE;AACN,MAAA,IAAI,EAAE,QADA;AAEN,MAAA,IAAI,EAAE,CAAC,WAAD,EAAc,cAAd;AAFA;AAXI;AAFS,CAAtB;AAoBA,IAAK,SAAL;;AAAA,CAAA,UAAK,SAAL,EAAc;AACb,EAAA,SAAA,CAAA,WAAA,CAAA,GAAA,WAAA;AACA,EAAA,SAAA,CAAA,cAAA,CAAA,GAAA,cAAA;AACA,CAHD,EAAK,SAAS,KAAT,SAAS,GAAA,EAAA,CAAd;;AAcO,IAAM,QAAQ,GAAG,SAAX,QAAW,CAAC,OAAD;AAAA;AAAA,wEAA0B,iBACjD,GADiD,EAEjD,GAFiD,EAGjD,IAHiD;AAAA;;AAAA;AAAA;AAAA;AAAA;AAK3C,cAAA,MAL2C,GAKlC,gBAAA,CAAA,SAAA,CAAU,QAAV,CAAmB,aAAnB,EAAkC,GAAG,CAAC,KAAtC,CALkC;;AAAA,mBAQ7C,MAAM,CAAC,MARsC;AAAA;AAAA;AAAA;;AAShD,cAAA,GAAG,CAAC,MAAJ,CAAW,GAAX,EAAgB,IAAhB,CAAqB;AACpB,gBAAA,MAAM,EAAE,CAAC;AAAE,kBAAA,OAAO,EAAE,IAAI,gBAAA,CAAA,mBAAJ,oBAA4B,MAA5B,GAAqC;AAAhD,iBAAD;AADY,eAArB;AATgD;;AAAA;AAAA,2BAcgB,GAAG,CAAC,KAdpB,gCAczC,KAdyC,EAczC,KAdyC,iCAcjC,GAdiC,oDAc5B,MAd4B,EAc5B,MAd4B,kCAcnB,CAdmB,oDAchB,KAdgB,EAchB,KAdgB,iCAcR,SAAS,CAAC,SAdF;AAAA;;AAAA,oBAkB5C,KAAK,KAAK,SAAS,CAAC,YAlBwB;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAmBjC,OAAO,CAAC,MAAR,CAAwC,0BAAxC,CAnBiC;;AAAA;AAmB/C,cAAA,KAnB+C;AAAA;AAAA;;AAAA;AAAA;AAAA,qBAqBjC,OAAO,CAAC,MAAR,CAAwC,uBAAxC,CArBiC;;AAAA;AAqB/C,cAAA,KArB+C;;AAAA;AAwBhD,cAAA,GAAG,CAAC,MAAJ,CAAW,GAAX,EAAgB,IAAhB,CAAqB;AACpB,gBAAA,IAAI,EAAE;AAAE,kBAAA,KAAK,EAAE,KAAK,CAAC,MAAf;AAAuB,kBAAA,KAAK,EAAE,CAAC,KAA/B;AAAsC,kBAAA,MAAM,EAAE,CAAC;AAA/C,iBADc;AAEpB,gBAAA,IAAI,EAAE,OAAA,CAAA,YAAA,CAAa,KAAb,EAAoB,CAAC,KAArB,EAA4B,CAAC,MAA7B;AAFc,eAArB;AAxBgD;AAAA;;AAAA;AAAA;AAAA;AA6BhD,cAAA,IAAI,aAAJ;;AA7BgD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAA1B;;AAAA;AAAA;AAAA;AAAA;AAAA,CAAjB;;AAAM,OAAA,CAAA,QAAA,GAAQ,QAAR","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPeers = void 0;\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst utils_1 = require(\"../utils\");\nconst getPeerSchema = {\n    type: 'object',\n    properties: {\n        limit: {\n            type: 'string',\n            format: 'uint32',\n            description: 'Number of peers to be returned',\n        },\n        offset: {\n            type: 'string',\n            format: 'uint32',\n            description: 'Offset to get peers after a specific point in a peer list',\n        },\n        state: {\n            type: 'string',\n            enum: ['connected', 'disconnected'],\n        },\n    },\n};\nvar PeerState;\n(function (PeerState) {\n    PeerState[\"connected\"] = \"connected\";\n    PeerState[\"disconnected\"] = \"disconnected\";\n})(PeerState || (PeerState = {}));\nconst getPeers = (channel) => async (req, res, next) => {\n    const errors = lisk_validator_1.validator.validate(getPeerSchema, req.query);\n    if (errors.length) {\n        res.status(400).send({\n            errors: [{ message: new lisk_validator_1.LiskValidationError([...errors]).message }],\n        });\n        return;\n    }\n    const { limit = 100, offset = 0, state = PeerState.connected } = req.query;\n    try {\n        let peers;\n        if (state === PeerState.disconnected) {\n            peers = await channel.invoke('app:getDisconnectedPeers');\n        }\n        else {\n            peers = await channel.invoke('app:getConnectedPeers');\n        }\n        res.status(200).json({\n            meta: { count: peers.length, limit: +limit, offset: +offset },\n            data: utils_1.paginateList(peers, +limit, +offset),\n        });\n    }\n    catch (err) {\n        next(err);\n    }\n};\nexports.getPeers = getPeers;\n//# sourceMappingURL=peers.js.map"]},"metadata":{},"sourceType":"script"}