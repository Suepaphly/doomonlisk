{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _taggedTemplateLiteral = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar equal_1 = require(\"../../runtime/equal\");\n\nvar error = {\n  message: \"must be equal to one of the allowed values\",\n  params: function params(_ref) {\n    var schemaCode = _ref.schemaCode;\n    return codegen_1._(_templateObject || (_templateObject = _taggedTemplateLiteral([\"{allowedValues: \", \"}\"])), schemaCode);\n  }\n};\nvar def = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        data = cxt.data,\n        $data = cxt.$data,\n        schema = cxt.schema,\n        schemaCode = cxt.schemaCode,\n        it = cxt.it;\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\");\n    var useLoop = schema.length >= it.opts.loopEnum;\n    var eql = util_1.useFunc(gen, equal_1.default);\n    var valid;\n\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\");\n      cxt.block$data(valid, loopEnum);\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n      var vSchema = gen.const(\"vSchema\", schemaCode);\n      valid = codegen_1.or.apply(codegen_1, _toConsumableArray(schema.map(function (_x, i) {\n        return equalCode(vSchema, i);\n      })));\n    }\n\n    cxt.pass(valid);\n\n    function loopEnum() {\n      gen.assign(valid, false);\n      gen.forOf(\"v\", schemaCode, function (v) {\n        return gen.if(codegen_1._(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\", \"(\", \", \", \")\"])), eql, data, v), function () {\n          return gen.assign(valid, true).break();\n        });\n      });\n    }\n\n    function equalCode(vSchema, i) {\n      var sch = schema[i];\n      return sch && typeof sch === \"object\" ? codegen_1._(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \"(\", \", \", \"[\", \"])\"])), eql, data, vSchema, i) : codegen_1._(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), data, sch);\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/enum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: \"must be equal to one of the allowed values\",\n    params: ({ schemaCode }) => codegen_1._ `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error(\"enum must have non-empty array\");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        const eql = util_1.useFunc(gen, equal_1.default);\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let(\"valid\");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error(\"ajv implementation error\");\n            const vSchema = gen.const(\"vSchema\", schemaCode);\n            valid = codegen_1.or(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf(\"v\", schemaCode, (v) => gen.if(codegen_1._ `${eql}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return sch && typeof sch === \"object\"\n                ? codegen_1._ `${eql}(${data}, ${vSchema}[${i}])`\n                : codegen_1._ `${data} === ${sch}`;\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=enum.js.map"]},"metadata":{},"sourceType":"script"}