{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseSynchronizer = exports.EVENT_SYNCHRONIZER_SYNC_REQUIRED = void 0;\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar events_1 = require(\"events\");\n\nvar errors_1 = require(\"./errors\");\n\nvar schemas_1 = require(\"../transport/schemas\");\n\nexports.EVENT_SYNCHRONIZER_SYNC_REQUIRED = 'EVENT_SYNCHRONIZER_SYNC_REQUIRED';\n\nvar BaseSynchronizer = /*#__PURE__*/function () {\n  function BaseSynchronizer(logger, channel, chain, network) {\n    _classCallCheck(this, BaseSynchronizer);\n\n    this._stop = false;\n    this._logger = logger;\n    this._channel = channel;\n    this._chain = chain;\n    this._networkModule = network;\n    this.events = new events_1.EventEmitter();\n  }\n\n  _createClass(BaseSynchronizer, [{\n    key: \"stop\",\n    value: function stop() {\n      this._stop = true;\n    }\n  }, {\n    key: \"_restartSync\",\n    value: function _restartSync(receivedBlock, reason) {\n      this._logger.info({\n        reason: reason\n      }, \"Restarting synchronization mechanism with reason: \".concat(reason));\n\n      this.events.emit(exports.EVENT_SYNCHRONIZER_SYNC_REQUIRED, {\n        block: receivedBlock\n      });\n    }\n  }, {\n    key: \"_applyPenaltyAndRestartSync\",\n    value: function _applyPenaltyAndRestartSync(peerId, receivedBlock, reason) {\n      this._logger.info({\n        peerId: peerId,\n        reason: reason\n      }, 'Applying penalty to peer and restarting synchronizer');\n\n      this._networkModule.applyPenaltyOnPeer({\n        peerId: peerId,\n        penalty: 100\n      });\n\n      this.events.emit(exports.EVENT_SYNCHRONIZER_SYNC_REQUIRED, {\n        block: receivedBlock,\n        peerId: peerId\n      });\n    }\n  }, {\n    key: \"_getLastBlockFromNetwork\",\n    value: function () {\n      var _getLastBlockFromNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peerId) {\n        var _yield$this$_networkM, data;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._networkModule.requestFromPeer({\n                  procedure: 'getLastBlock',\n                  peerId: peerId\n                });\n\n              case 2:\n                _yield$this$_networkM = _context.sent;\n                data = _yield$this$_networkM.data;\n\n                if (!(!data || !data.length)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'Peer did not provide its last block');\n\n              case 6:\n                return _context.abrupt(\"return\", this._chain.dataAccess.decode(data));\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _getLastBlockFromNetwork(_x) {\n        return _getLastBlockFromNetwork2.apply(this, arguments);\n      }\n\n      return _getLastBlockFromNetwork;\n    }()\n  }, {\n    key: \"_getHighestCommonBlockFromNetwork\",\n    value: function () {\n      var _getHighestCommonBlockFromNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(peerId, ids) {\n        var blockIds, _yield$this$_networkM2, data, decodedResp, errors;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                blockIds = lisk_codec_1.codec.encode(schemas_1.getHighestCommonBlockRequestSchema, {\n                  ids: ids\n                });\n                _context2.next = 3;\n                return this._networkModule.requestFromPeer({\n                  procedure: 'getHighestCommonBlock',\n                  peerId: peerId,\n                  data: blockIds\n                });\n\n              case 3:\n                _yield$this$_networkM2 = _context2.sent;\n                data = _yield$this$_networkM2.data;\n                decodedResp = lisk_codec_1.codec.decode(schemas_1.getHighestCommonBlockResponseSchema, data);\n                errors = lisk_validator_1.validator.validate(schemas_1.getHighestCommonBlockResponseSchema, decodedResp);\n\n                if (!errors.length) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw new errors_1.ApplyPenaltyAndAbortError(peerId, 'Invalid common block response format');\n\n              case 9:\n                return _context2.abrupt(\"return\", this._chain.dataAccess.getBlockHeaderByID(decodedResp.id));\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _getHighestCommonBlockFromNetwork(_x2, _x3) {\n        return _getHighestCommonBlockFromNetwork2.apply(this, arguments);\n      }\n\n      return _getHighestCommonBlockFromNetwork;\n    }()\n  }, {\n    key: \"_getBlocksFromNetwork\",\n    value: function () {\n      var _getBlocksFromNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peerId, fromID) {\n        var _this = this;\n\n        var blockId, _yield$this$_networkM3, data, encodedData;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                blockId = lisk_codec_1.codec.encode(schemas_1.getBlocksFromIdRequestSchema, {\n                  blockId: fromID\n                });\n                _context3.next = 3;\n                return this._networkModule.requestFromPeer({\n                  procedure: 'getBlocksFromId',\n                  peerId: peerId,\n                  data: blockId\n                });\n\n              case 3:\n                _yield$this$_networkM3 = _context3.sent;\n                data = _yield$this$_networkM3.data;\n\n                if (!(!data || !data.length)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                throw new Error('Peer did not respond with block');\n\n              case 7:\n                encodedData = lisk_codec_1.codec.decode(schemas_1.getBlocksFromIdResponseSchema, data);\n                return _context3.abrupt(\"return\", encodedData.blocks.map(function (block) {\n                  return _this._chain.dataAccess.decode(block);\n                }));\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _getBlocksFromNetwork(_x4, _x5) {\n        return _getBlocksFromNetwork2.apply(this, arguments);\n      }\n\n      return _getBlocksFromNetwork;\n    }()\n  }]);\n\n  return BaseSynchronizer;\n}();\n\nexports.BaseSynchronizer = BaseSynchronizer;","map":{"version":3,"sources":["../../../src/node/synchronizer/base_synchronizer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseSynchronizer = exports.EVENT_SYNCHRONIZER_SYNC_REQUIRED = void 0;\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst events_1 = require(\"events\");\nconst errors_1 = require(\"./errors\");\nconst schemas_1 = require(\"../transport/schemas\");\nexports.EVENT_SYNCHRONIZER_SYNC_REQUIRED = 'EVENT_SYNCHRONIZER_SYNC_REQUIRED';\nclass BaseSynchronizer {\n    constructor(logger, channel, chain, network) {\n        this._stop = false;\n        this._logger = logger;\n        this._channel = channel;\n        this._chain = chain;\n        this._networkModule = network;\n        this.events = new events_1.EventEmitter();\n    }\n    stop() {\n        this._stop = true;\n    }\n    _restartSync(receivedBlock, reason) {\n        this._logger.info({ reason }, `Restarting synchronization mechanism with reason: ${reason}`);\n        this.events.emit(exports.EVENT_SYNCHRONIZER_SYNC_REQUIRED, {\n            block: receivedBlock,\n        });\n    }\n    _applyPenaltyAndRestartSync(peerId, receivedBlock, reason) {\n        this._logger.info({ peerId, reason }, 'Applying penalty to peer and restarting synchronizer');\n        this._networkModule.applyPenaltyOnPeer({\n            peerId,\n            penalty: 100,\n        });\n        this.events.emit(exports.EVENT_SYNCHRONIZER_SYNC_REQUIRED, {\n            block: receivedBlock,\n            peerId,\n        });\n    }\n    async _getLastBlockFromNetwork(peerId) {\n        const { data } = (await this._networkModule.requestFromPeer({\n            procedure: 'getLastBlock',\n            peerId,\n        }));\n        if (!data || !data.length) {\n            throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'Peer did not provide its last block');\n        }\n        return this._chain.dataAccess.decode(data);\n    }\n    async _getHighestCommonBlockFromNetwork(peerId, ids) {\n        const blockIds = lisk_codec_1.codec.encode(schemas_1.getHighestCommonBlockRequestSchema, { ids });\n        const { data } = (await this._networkModule.requestFromPeer({\n            procedure: 'getHighestCommonBlock',\n            peerId,\n            data: blockIds,\n        }));\n        const decodedResp = lisk_codec_1.codec.decode(schemas_1.getHighestCommonBlockResponseSchema, data);\n        const errors = lisk_validator_1.validator.validate(schemas_1.getHighestCommonBlockResponseSchema, decodedResp);\n        if (errors.length) {\n            throw new errors_1.ApplyPenaltyAndAbortError(peerId, 'Invalid common block response format');\n        }\n        return this._chain.dataAccess.getBlockHeaderByID(decodedResp.id);\n    }\n    async _getBlocksFromNetwork(peerId, fromID) {\n        const blockId = lisk_codec_1.codec.encode(schemas_1.getBlocksFromIdRequestSchema, { blockId: fromID });\n        const { data } = (await this._networkModule.requestFromPeer({\n            procedure: 'getBlocksFromId',\n            peerId,\n            data: blockId,\n        }));\n        if (!data || !data.length) {\n            throw new Error('Peer did not respond with block');\n        }\n        const encodedData = lisk_codec_1.codec.decode(schemas_1.getBlocksFromIdResponseSchema, data);\n        return encodedData.blocks.map(block => this._chain.dataAccess.decode(block));\n    }\n}\nexports.BaseSynchronizer = BaseSynchronizer;\n//# sourceMappingURL=base_synchronizer.js.map"]},"metadata":{},"sourceType":"script"}