{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleTree = void 0;\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar constants_1 = require(\"./constants\");\n\nvar utils_1 = require(\"./utils\");\n\nvar MerkleTree = /*#__PURE__*/function () {\n  function MerkleTree() {\n    var initValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var options = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, MerkleTree);\n\n    var _a, _b;\n\n    this._width = 0;\n    this._hashToValueMap = {};\n    this._locationToHashMap = {};\n\n    if (initValues.length <= 1) {\n      var rootNode = initValues.length ? this._generateLeaf(initValues[0], 0) : {\n        hash: constants_1.EMPTY_HASH,\n        value: Buffer.alloc(0)\n      };\n      this._root = rootNode.hash;\n      this._hashToValueMap[this._root.toString('binary')] = rootNode.value;\n      this._locationToHashMap[\"\".concat(utils_1.getBinaryString(0, this._getHeight()))] = this._root;\n      this._width = initValues.length ? 1 : 0;\n      this._preHashedLeaf = (_a = options === null || options === void 0 ? void 0 : options.preHashedLeaf) !== null && _a !== void 0 ? _a : false;\n      return;\n    }\n\n    this._preHashedLeaf = (_b = options === null || options === void 0 ? void 0 : options.preHashedLeaf) !== null && _b !== void 0 ? _b : false;\n    this._root = this._build(initValues);\n  }\n\n  _createClass(MerkleTree, [{\n    key: \"root\",\n    get: function get() {\n      return this._root;\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(nodeHash) {\n      var value = this._hashToValueMap[nodeHash.toString('binary')];\n\n      if (!value) {\n        throw new Error(\"Hash does not exist in merkle tree: \".concat(nodeHash.toString('hex')));\n      }\n\n      var type = utils_1.isLeaf(value) ? \"leaf\" : \"branch\";\n      var layerIndex = type === \"leaf\" ? 0 : value.readInt8(constants_1.BRANCH_PREFIX.length);\n      var nodeIndex = type === \"branch\" ? value.readInt32BE(constants_1.BRANCH_PREFIX.length + constants_1.LAYER_INDEX_SIZE) : value.readInt32BE(constants_1.LEAF_PREFIX.length);\n      var rightHash = type === \"branch\" ? value.slice(-1 * constants_1.NODE_HASH_SIZE) : Buffer.alloc(0);\n      var leftHash = type === \"branch\" ? value.slice(-2 * constants_1.NODE_HASH_SIZE, -1 * constants_1.NODE_HASH_SIZE) : Buffer.alloc(0);\n      return {\n        type: type,\n        hash: nodeHash,\n        value: value,\n        layerIndex: layerIndex,\n        nodeIndex: nodeIndex,\n        rightHash: rightHash,\n        leftHash: leftHash\n      };\n    }\n  }, {\n    key: \"append\",\n    value: function append(value) {\n      if (this._width === 0) {\n        var leaf = this._generateLeaf(value, 0);\n\n        this._root = leaf.hash;\n        this._width += 1;\n        return this._root;\n      }\n\n      var appendPath = [];\n      var currentNode = this.getNode(this._root);\n\n      if (this._width === Math.pow(2, this._getHeight() - 1)) {\n        appendPath.push(currentNode);\n      } else {\n        while (true) {\n          var currentLayer = currentNode.layerIndex;\n          var currentLayerSize = this._width >> currentLayer;\n\n          if (currentLayerSize % 2 === 1 && currentNode.nodeIndex % 2 === 0) {\n            appendPath.push(currentNode);\n          }\n\n          if (currentNode.type === \"leaf\") {\n            break;\n          }\n\n          currentLayerSize = this._width >> currentLayer - 1;\n\n          if (currentLayerSize % 2 === 1) {\n            var leftNode = this.getNode(currentNode.leftHash);\n            appendPath.push(leftNode);\n          }\n\n          currentNode = this.getNode(currentNode.rightHash);\n        }\n      }\n\n      var appendData = this._generateLeaf(value, this._width);\n\n      var appendNode = this.getNode(appendData.hash);\n      appendPath.push(appendNode);\n\n      while (appendPath.length > 1) {\n        var rightNodeInfo = appendPath.pop();\n        var leftNodeInfo = appendPath.pop();\n\n        var newBranchNode = this._generateBranch(leftNodeInfo.hash, rightNodeInfo.hash, leftNodeInfo.layerIndex + 1, leftNodeInfo.nodeIndex + 1);\n\n        appendPath.push(this.getNode(newBranchNode.hash));\n      }\n\n      this._root = appendPath[0].hash;\n      return this.root;\n    }\n  }, {\n    key: \"generateProof\",\n    value: function generateProof(queryData) {\n      if (this._width === 0) {\n        return {\n          path: [],\n          indexes: [],\n          dataLength: 0\n        };\n      }\n\n      var path = [];\n      var addedPath = new lisk_utils_1.dataStructures.BufferSet();\n      var indexes = [];\n      var queryNode;\n\n      for (var i = 0; i < queryData.length; i += 1) {\n        try {\n          queryNode = this.getNode(queryData[i]);\n        } catch (err) {\n          path.push({\n            hash: queryData[i],\n            layerIndex: undefined,\n            nodeIndex: undefined\n          });\n          indexes.push({\n            layerIndex: undefined,\n            nodeIndex: undefined\n          });\n          continue;\n        }\n\n        if (this._width === 1 && this._root.equals(queryNode.hash)) {\n          if (!addedPath.has(queryNode.hash)) {\n            addedPath.add(queryNode.hash);\n            path.push({\n              hash: queryNode.hash,\n              layerIndex: 0,\n              nodeIndex: 0\n            });\n            indexes.push({\n              layerIndex: 0,\n              nodeIndex: 0\n            });\n          }\n\n          continue;\n        }\n\n        indexes.push({\n          layerIndex: queryNode.layerIndex,\n          nodeIndex: queryNode.nodeIndex\n        });\n        var currentNode = queryNode;\n\n        while (!currentNode.hash.equals(this._root)) {\n          var _utils_1$getPairLocat = utils_1.getPairLocation({\n            layerIndex: currentNode.layerIndex,\n            nodeIndex: currentNode.nodeIndex,\n            dataLength: this._width\n          }),\n              pairLayerIndex = _utils_1$getPairLocat.layerIndex,\n              pairNodeIndex = _utils_1$getPairLocat.nodeIndex,\n              pairSide = _utils_1$getPairLocat.side;\n\n          var pairNodeHash = this._locationToHashMap[\"\".concat(utils_1.getBinaryString(pairNodeIndex, this._getHeight() - pairLayerIndex))];\n\n          if (!addedPath.has(pairNodeHash)) {\n            addedPath.add(pairNodeHash);\n            path.push({\n              hash: pairNodeHash,\n              layerIndex: pairLayerIndex,\n              nodeIndex: pairNodeIndex\n            });\n          }\n\n          var leftHashBuffer = pairSide === 0 ? pairNodeHash : currentNode.hash;\n          var rightHashBuffer = pairSide === 1 ? pairNodeHash : currentNode.hash;\n          var parentNodeHash = utils_1.generateHash(constants_1.BRANCH_PREFIX, leftHashBuffer, rightHashBuffer);\n          currentNode = this.getNode(parentNodeHash);\n        }\n      }\n\n      return {\n        path: path,\n        indexes: indexes,\n        dataLength: this._width\n      };\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._width = 0;\n      this._root = constants_1.EMPTY_HASH;\n      this._hashToValueMap = _defineProperty({}, this._root.toString('2'), Buffer.alloc(0));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this._width === 0) {\n        return this.root.toString('hex');\n      }\n\n      return this._printNode(this.root);\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var _this = this;\n\n      return this._width === 0 ? [] : Object.keys(this._hashToValueMap).map(function (key) {\n        return _this.getNode(Buffer.from(key, 'binary'));\n      });\n    }\n  }, {\n    key: \"_getHeight\",\n    value: function _getHeight() {\n      return Math.ceil(Math.log2(this._width)) + 1;\n    }\n  }, {\n    key: \"_generateLeaf\",\n    value: function _generateLeaf(value, nodeIndex) {\n      var nodeIndexBuffer = Buffer.alloc(constants_1.NODE_INDEX_SIZE);\n      nodeIndexBuffer.writeInt32BE(nodeIndex, 0);\n      var leafValueWithoutNodeIndex = Buffer.concat([constants_1.LEAF_PREFIX, value], constants_1.LEAF_PREFIX.length + value.length);\n      var leafHash = this._preHashedLeaf ? value : lisk_cryptography_1.hash(leafValueWithoutNodeIndex);\n      var leafValueWithNodeIndex = Buffer.concat([constants_1.LEAF_PREFIX, nodeIndexBuffer, value], constants_1.LEAF_PREFIX.length + nodeIndexBuffer.length + value.length);\n      this._hashToValueMap[leafHash.toString('binary')] = leafValueWithNodeIndex;\n      this._locationToHashMap[\"\".concat(utils_1.getBinaryString(nodeIndex, this._getHeight()))] = leafHash;\n      return {\n        value: leafValueWithNodeIndex,\n        hash: leafHash\n      };\n    }\n  }, {\n    key: \"_generateBranch\",\n    value: function _generateBranch(leftHashBuffer, rightHashBuffer, layerIndex, nodeIndex) {\n      var layerIndexBuffer = Buffer.alloc(constants_1.LAYER_INDEX_SIZE);\n      var nodeIndexBuffer = Buffer.alloc(constants_1.NODE_INDEX_SIZE);\n      layerIndexBuffer.writeInt8(layerIndex, 0);\n      nodeIndexBuffer.writeInt32BE(nodeIndex, 0);\n      var branchValue = Buffer.concat([constants_1.BRANCH_PREFIX, layerIndexBuffer, nodeIndexBuffer, leftHashBuffer, rightHashBuffer], constants_1.BRANCH_PREFIX.length + layerIndexBuffer.length + nodeIndexBuffer.length + leftHashBuffer.length + rightHashBuffer.length);\n      var branchHash = utils_1.generateHash(constants_1.BRANCH_PREFIX, leftHashBuffer, rightHashBuffer);\n      this._hashToValueMap[branchHash.toString('binary')] = branchValue;\n      this._locationToHashMap[\"\".concat(utils_1.getBinaryString(nodeIndex, this._getHeight() - layerIndex))] = branchHash;\n      return {\n        hash: branchHash,\n        value: branchValue\n      };\n    }\n  }, {\n    key: \"_build\",\n    value: function _build(initValues) {\n      var leafHashes = [];\n      this._width = initValues.length;\n\n      for (var i = 0; i < initValues.length; i += 1) {\n        var leaf = this._generateLeaf(initValues[i], i);\n\n        leafHashes.push(leaf.hash);\n      }\n\n      var currentLayerIndex = 0;\n      var currentLayerHashes = leafHashes;\n      var orphanNodeHashInPreviousLayer;\n\n      while (currentLayerHashes.length > 1 || orphanNodeHashInPreviousLayer !== undefined) {\n        var pairsOfHashes = [];\n\n        for (var _i = 0; _i < currentLayerHashes.length - 1; _i += 2) {\n          pairsOfHashes.push([currentLayerHashes[_i], currentLayerHashes[_i + 1]]);\n        }\n\n        if (currentLayerHashes.length % 2 === 1) {\n          if (orphanNodeHashInPreviousLayer === undefined) {\n            orphanNodeHashInPreviousLayer = currentLayerHashes[currentLayerHashes.length - 1];\n          } else {\n            pairsOfHashes.push([currentLayerHashes[currentLayerHashes.length - 1], orphanNodeHashInPreviousLayer]);\n            orphanNodeHashInPreviousLayer = undefined;\n          }\n        }\n\n        var parentLayerHashes = [];\n\n        for (var _i2 = 0; _i2 < pairsOfHashes.length; _i2 += 1) {\n          var leftHash = pairsOfHashes[_i2][0];\n          var rightHash = pairsOfHashes[_i2][1];\n\n          var node = this._generateBranch(leftHash, rightHash, currentLayerIndex + 1, _i2);\n\n          parentLayerHashes.push(node.hash);\n        }\n\n        currentLayerHashes = parentLayerHashes;\n        currentLayerIndex += 1;\n      }\n\n      return currentLayerHashes[0];\n    }\n  }, {\n    key: \"_printNode\",\n    value: function _printNode(hashValue) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      var nodeValue = this._hashToValueMap[hashValue.toString('binary')];\n\n      if (nodeValue && utils_1.isLeaf(nodeValue)) {\n        return hashValue.toString('hex');\n      }\n\n      var node = this.getNode(hashValue);\n      return [hashValue.toString('hex'), \"\\u251C\".concat(' ─ '.repeat(level), \" \").concat(this._printNode(node.leftHash, level + 1)), \"\\u251C\".concat(' ─ '.repeat(level), \" \").concat(this._printNode(node.rightHash, level + 1))].join('\\n');\n    }\n  }]);\n\n  return MerkleTree;\n}();\n\nexports.MerkleTree = MerkleTree;","map":{"version":3,"sources":["../src/merkle_tree.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleTree = void 0;\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst constants_1 = require(\"./constants\");\nconst utils_1 = require(\"./utils\");\nclass MerkleTree {\n    constructor(initValues = [], options) {\n        var _a, _b;\n        this._width = 0;\n        this._hashToValueMap = {};\n        this._locationToHashMap = {};\n        if (initValues.length <= 1) {\n            const rootNode = initValues.length\n                ? this._generateLeaf(initValues[0], 0)\n                : { hash: constants_1.EMPTY_HASH, value: Buffer.alloc(0) };\n            this._root = rootNode.hash;\n            this._hashToValueMap[this._root.toString('binary')] = rootNode.value;\n            this._locationToHashMap[`${utils_1.getBinaryString(0, this._getHeight())}`] = this._root;\n            this._width = initValues.length ? 1 : 0;\n            this._preHashedLeaf = (_a = options === null || options === void 0 ? void 0 : options.preHashedLeaf) !== null && _a !== void 0 ? _a : false;\n            return;\n        }\n        this._preHashedLeaf = (_b = options === null || options === void 0 ? void 0 : options.preHashedLeaf) !== null && _b !== void 0 ? _b : false;\n        this._root = this._build(initValues);\n    }\n    get root() {\n        return this._root;\n    }\n    getNode(nodeHash) {\n        const value = this._hashToValueMap[nodeHash.toString('binary')];\n        if (!value) {\n            throw new Error(`Hash does not exist in merkle tree: ${nodeHash.toString('hex')}`);\n        }\n        const type = utils_1.isLeaf(value) ? \"leaf\" : \"branch\";\n        const layerIndex = type === \"leaf\" ? 0 : value.readInt8(constants_1.BRANCH_PREFIX.length);\n        const nodeIndex = type === \"branch\"\n            ? value.readInt32BE(constants_1.BRANCH_PREFIX.length + constants_1.LAYER_INDEX_SIZE)\n            : value.readInt32BE(constants_1.LEAF_PREFIX.length);\n        const rightHash = type === \"branch\" ? value.slice(-1 * constants_1.NODE_HASH_SIZE) : Buffer.alloc(0);\n        const leftHash = type === \"branch\"\n            ? value.slice(-2 * constants_1.NODE_HASH_SIZE, -1 * constants_1.NODE_HASH_SIZE)\n            : Buffer.alloc(0);\n        return {\n            type,\n            hash: nodeHash,\n            value,\n            layerIndex,\n            nodeIndex,\n            rightHash,\n            leftHash,\n        };\n    }\n    append(value) {\n        if (this._width === 0) {\n            const leaf = this._generateLeaf(value, 0);\n            this._root = leaf.hash;\n            this._width += 1;\n            return this._root;\n        }\n        const appendPath = [];\n        let currentNode = this.getNode(this._root);\n        if (this._width === 2 ** (this._getHeight() - 1)) {\n            appendPath.push(currentNode);\n        }\n        else {\n            while (true) {\n                const currentLayer = currentNode.layerIndex;\n                let currentLayerSize = this._width >> currentLayer;\n                if (currentLayerSize % 2 === 1 && currentNode.nodeIndex % 2 === 0) {\n                    appendPath.push(currentNode);\n                }\n                if (currentNode.type === \"leaf\") {\n                    break;\n                }\n                currentLayerSize = this._width >> (currentLayer - 1);\n                if (currentLayerSize % 2 === 1) {\n                    const leftNode = this.getNode(currentNode.leftHash);\n                    appendPath.push(leftNode);\n                }\n                currentNode = this.getNode(currentNode.rightHash);\n            }\n        }\n        const appendData = this._generateLeaf(value, this._width);\n        const appendNode = this.getNode(appendData.hash);\n        appendPath.push(appendNode);\n        while (appendPath.length > 1) {\n            const rightNodeInfo = appendPath.pop();\n            const leftNodeInfo = appendPath.pop();\n            const newBranchNode = this._generateBranch(leftNodeInfo.hash, rightNodeInfo.hash, leftNodeInfo.layerIndex + 1, leftNodeInfo.nodeIndex + 1);\n            appendPath.push(this.getNode(newBranchNode.hash));\n        }\n        this._root = appendPath[0].hash;\n        return this.root;\n    }\n    generateProof(queryData) {\n        if (this._width === 0) {\n            return {\n                path: [],\n                indexes: [],\n                dataLength: 0,\n            };\n        }\n        const path = [];\n        const addedPath = new lisk_utils_1.dataStructures.BufferSet();\n        const indexes = [];\n        let queryNode;\n        for (let i = 0; i < queryData.length; i += 1) {\n            try {\n                queryNode = this.getNode(queryData[i]);\n            }\n            catch (err) {\n                path.push({\n                    hash: queryData[i],\n                    layerIndex: undefined,\n                    nodeIndex: undefined,\n                });\n                indexes.push({\n                    layerIndex: undefined,\n                    nodeIndex: undefined,\n                });\n                continue;\n            }\n            if (this._width === 1 && this._root.equals(queryNode.hash)) {\n                if (!addedPath.has(queryNode.hash)) {\n                    addedPath.add(queryNode.hash);\n                    path.push({\n                        hash: queryNode.hash,\n                        layerIndex: 0,\n                        nodeIndex: 0,\n                    });\n                    indexes.push({\n                        layerIndex: 0,\n                        nodeIndex: 0,\n                    });\n                }\n                continue;\n            }\n            indexes.push({\n                layerIndex: queryNode.layerIndex,\n                nodeIndex: queryNode.nodeIndex,\n            });\n            let currentNode = queryNode;\n            while (!currentNode.hash.equals(this._root)) {\n                const { layerIndex: pairLayerIndex, nodeIndex: pairNodeIndex, side: pairSide, } = utils_1.getPairLocation({\n                    layerIndex: currentNode.layerIndex,\n                    nodeIndex: currentNode.nodeIndex,\n                    dataLength: this._width,\n                });\n                const pairNodeHash = this._locationToHashMap[`${utils_1.getBinaryString(pairNodeIndex, this._getHeight() - pairLayerIndex)}`];\n                if (!addedPath.has(pairNodeHash)) {\n                    addedPath.add(pairNodeHash);\n                    path.push({\n                        hash: pairNodeHash,\n                        layerIndex: pairLayerIndex,\n                        nodeIndex: pairNodeIndex,\n                    });\n                }\n                const leftHashBuffer = pairSide === 0 ? pairNodeHash : currentNode.hash;\n                const rightHashBuffer = pairSide === 1 ? pairNodeHash : currentNode.hash;\n                const parentNodeHash = utils_1.generateHash(constants_1.BRANCH_PREFIX, leftHashBuffer, rightHashBuffer);\n                currentNode = this.getNode(parentNodeHash);\n            }\n        }\n        return {\n            path,\n            indexes,\n            dataLength: this._width,\n        };\n    }\n    clear() {\n        this._width = 0;\n        this._root = constants_1.EMPTY_HASH;\n        this._hashToValueMap = { [this._root.toString('2')]: Buffer.alloc(0) };\n    }\n    toString() {\n        if (this._width === 0) {\n            return this.root.toString('hex');\n        }\n        return this._printNode(this.root);\n    }\n    getData() {\n        return this._width === 0\n            ? []\n            : Object.keys(this._hashToValueMap).map(key => this.getNode(Buffer.from(key, 'binary')));\n    }\n    _getHeight() {\n        return Math.ceil(Math.log2(this._width)) + 1;\n    }\n    _generateLeaf(value, nodeIndex) {\n        const nodeIndexBuffer = Buffer.alloc(constants_1.NODE_INDEX_SIZE);\n        nodeIndexBuffer.writeInt32BE(nodeIndex, 0);\n        const leafValueWithoutNodeIndex = Buffer.concat([constants_1.LEAF_PREFIX, value], constants_1.LEAF_PREFIX.length + value.length);\n        const leafHash = this._preHashedLeaf ? value : lisk_cryptography_1.hash(leafValueWithoutNodeIndex);\n        const leafValueWithNodeIndex = Buffer.concat([constants_1.LEAF_PREFIX, nodeIndexBuffer, value], constants_1.LEAF_PREFIX.length + nodeIndexBuffer.length + value.length);\n        this._hashToValueMap[leafHash.toString('binary')] = leafValueWithNodeIndex;\n        this._locationToHashMap[`${utils_1.getBinaryString(nodeIndex, this._getHeight())}`] = leafHash;\n        return {\n            value: leafValueWithNodeIndex,\n            hash: leafHash,\n        };\n    }\n    _generateBranch(leftHashBuffer, rightHashBuffer, layerIndex, nodeIndex) {\n        const layerIndexBuffer = Buffer.alloc(constants_1.LAYER_INDEX_SIZE);\n        const nodeIndexBuffer = Buffer.alloc(constants_1.NODE_INDEX_SIZE);\n        layerIndexBuffer.writeInt8(layerIndex, 0);\n        nodeIndexBuffer.writeInt32BE(nodeIndex, 0);\n        const branchValue = Buffer.concat([constants_1.BRANCH_PREFIX, layerIndexBuffer, nodeIndexBuffer, leftHashBuffer, rightHashBuffer], constants_1.BRANCH_PREFIX.length +\n            layerIndexBuffer.length +\n            nodeIndexBuffer.length +\n            leftHashBuffer.length +\n            rightHashBuffer.length);\n        const branchHash = utils_1.generateHash(constants_1.BRANCH_PREFIX, leftHashBuffer, rightHashBuffer);\n        this._hashToValueMap[branchHash.toString('binary')] = branchValue;\n        this._locationToHashMap[`${utils_1.getBinaryString(nodeIndex, this._getHeight() - layerIndex)}`] = branchHash;\n        return {\n            hash: branchHash,\n            value: branchValue,\n        };\n    }\n    _build(initValues) {\n        const leafHashes = [];\n        this._width = initValues.length;\n        for (let i = 0; i < initValues.length; i += 1) {\n            const leaf = this._generateLeaf(initValues[i], i);\n            leafHashes.push(leaf.hash);\n        }\n        let currentLayerIndex = 0;\n        let currentLayerHashes = leafHashes;\n        let orphanNodeHashInPreviousLayer;\n        while (currentLayerHashes.length > 1 || orphanNodeHashInPreviousLayer !== undefined) {\n            const pairsOfHashes = [];\n            for (let i = 0; i < currentLayerHashes.length - 1; i += 2) {\n                pairsOfHashes.push([currentLayerHashes[i], currentLayerHashes[i + 1]]);\n            }\n            if (currentLayerHashes.length % 2 === 1) {\n                if (orphanNodeHashInPreviousLayer === undefined) {\n                    orphanNodeHashInPreviousLayer = currentLayerHashes[currentLayerHashes.length - 1];\n                }\n                else {\n                    pairsOfHashes.push([\n                        currentLayerHashes[currentLayerHashes.length - 1],\n                        orphanNodeHashInPreviousLayer,\n                    ]);\n                    orphanNodeHashInPreviousLayer = undefined;\n                }\n            }\n            const parentLayerHashes = [];\n            for (let i = 0; i < pairsOfHashes.length; i += 1) {\n                const leftHash = pairsOfHashes[i][0];\n                const rightHash = pairsOfHashes[i][1];\n                const node = this._generateBranch(leftHash, rightHash, currentLayerIndex + 1, i);\n                parentLayerHashes.push(node.hash);\n            }\n            currentLayerHashes = parentLayerHashes;\n            currentLayerIndex += 1;\n        }\n        return currentLayerHashes[0];\n    }\n    _printNode(hashValue, level = 1) {\n        const nodeValue = this._hashToValueMap[hashValue.toString('binary')];\n        if (nodeValue && utils_1.isLeaf(nodeValue)) {\n            return hashValue.toString('hex');\n        }\n        const node = this.getNode(hashValue);\n        return [\n            hashValue.toString('hex'),\n            `├${' ─ '.repeat(level)} ${this._printNode(node.leftHash, level + 1)}`,\n            `├${' ─ '.repeat(level)} ${this._printNode(node.rightHash, level + 1)}`,\n        ].join('\\n');\n    }\n}\nexports.MerkleTree = MerkleTree;\n//# sourceMappingURL=merkle_tree.js.map"]},"metadata":{},"sourceType":"script"}