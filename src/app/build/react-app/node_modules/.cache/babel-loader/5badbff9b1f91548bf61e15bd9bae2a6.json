{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _taggedTemplateLiteral = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36, _templateObject37, _templateObject38, _templateObject39;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\n\nvar boolSchema_1 = require(\"./boolSchema\");\n\nvar dataType_1 = require(\"./dataType\");\n\nvar applicability_1 = require(\"./applicability\");\n\nvar dataType_2 = require(\"./dataType\");\n\nvar defaults_1 = require(\"./defaults\");\n\nvar keyword_1 = require(\"./keyword\");\n\nvar subschema_1 = require(\"./subschema\");\n\nvar codegen_1 = require(\"../codegen\");\n\nvar names_1 = require(\"../names\");\n\nvar resolve_1 = require(\"../resolve\");\n\nvar util_1 = require(\"../util\");\n\nvar errors_1 = require(\"../errors\"); // schema compilation - generates validation function, subschemaCode (below) is used for subschemas\n\n\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n\n  validateFunction(it, function () {\n    return boolSchema_1.topBoolOrEmptySchema(it);\n  });\n}\n\nexports.validateFunctionCode = validateFunctionCode;\n\nfunction validateFunction(_ref, body) {\n  var gen = _ref.gen,\n      validateName = _ref.validateName,\n      schema = _ref.schema,\n      schemaEnv = _ref.schemaEnv,\n      opts = _ref.opts;\n\n  if (opts.code.es5) {\n    gen.func(validateName, codegen_1._(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \", \", \"\"])), names_1.default.data, names_1.default.valCxt), schemaEnv.$async, function () {\n      gen.code(codegen_1._(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\\"use strict\\\"; \", \"\"])), funcSourceUrl(schema, opts)));\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, codegen_1._(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \", \", \"\"])), names_1.default.data, destructureValCxt(opts)), schemaEnv.$async, function () {\n      return gen.code(funcSourceUrl(schema, opts)).code(body);\n    });\n  }\n}\n\nfunction destructureValCxt(opts) {\n  return codegen_1._(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"{\", \"=\\\"\\\", \", \", \", \", \", \"=\", \"\", \"}={}\"])), names_1.default.instancePath, names_1.default.parentData, names_1.default.parentDataProperty, names_1.default.rootData, names_1.default.data, opts.dynamicRef ? codegen_1._(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\", \", \"={}\"])), names_1.default.dynamicAnchors) : codegen_1.nil);\n}\n\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, function () {\n    gen.var(names_1.default.instancePath, codegen_1._(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.instancePath));\n    gen.var(names_1.default.parentData, codegen_1._(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.parentData));\n    gen.var(names_1.default.parentDataProperty, codegen_1._(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.parentDataProperty));\n    gen.var(names_1.default.rootData, codegen_1._(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.rootData));\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, codegen_1._(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"\", \".\", \"\"])), names_1.default.valCxt, names_1.default.dynamicAnchors));\n  }, function () {\n    gen.var(names_1.default.instancePath, codegen_1._(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\\\"\\\"\"]))));\n    gen.var(names_1.default.parentData, codegen_1._(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"undefined\"]))));\n    gen.var(names_1.default.parentDataProperty, codegen_1._(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"undefined\"]))));\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, codegen_1._(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"{}\"]))));\n  });\n}\n\nfunction topSchemaObjCode(it) {\n  var schema = it.schema,\n      opts = it.opts,\n      gen = it.gen;\n  validateFunction(it, function () {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\n\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  var gen = it.gen,\n      validateName = it.validateName;\n  it.evaluated = gen.const(\"evaluated\", codegen_1._(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\"\", \".evaluated\"])), validateName));\n  gen.if(codegen_1._(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \".dynamicProps\"])), it.evaluated), function () {\n    return gen.assign(codegen_1._(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \".props\"])), it.evaluated), codegen_1._(_templateObject18 || (_templateObject18 = _taggedTemplateLiteral([\"undefined\"]))));\n  });\n  gen.if(codegen_1._(_templateObject19 || (_templateObject19 = _taggedTemplateLiteral([\"\", \".dynamicItems\"])), it.evaluated), function () {\n    return gen.assign(codegen_1._(_templateObject20 || (_templateObject20 = _taggedTemplateLiteral([\"\", \".items\"])), it.evaluated), codegen_1._(_templateObject21 || (_templateObject21 = _taggedTemplateLiteral([\"undefined\"]))));\n  });\n}\n\nfunction funcSourceUrl(schema, opts) {\n  return typeof schema == \"object\" && schema.$id && (opts.code.source || opts.code.process) ? codegen_1._(_templateObject22 || (_templateObject22 = _taggedTemplateLiteral([\"/*# sourceURL=\", \" */\"])), schema.$id) : codegen_1.nil;\n} // schema compilation - this function is used recursively to generate code for sub-schemas\n\n\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n\n  boolSchema_1.boolOrEmptySchema(it, valid);\n}\n\nfunction schemaCxtHasRules(_ref2) {\n  var schema = _ref2.schema,\n      self = _ref2.self;\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (var key in schema) {\n    if (self.RULES.all[key]) return true;\n  }\n\n  return false;\n}\n\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\n\nfunction subSchemaObjCode(it, valid) {\n  var schema = it.schema,\n      gen = it.gen,\n      opts = it.opts;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  var errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount); // TODO var\n\n  gen.var(valid, codegen_1._(_templateObject23 || (_templateObject23 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), errsCount, names_1.default.errors));\n}\n\nfunction checkKeywords(it) {\n  util_1.checkUnknownRules(it);\n  checkRefsAndKeywords(it);\n}\n\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  var types = dataType_1.getSchemaTypes(it.schema);\n  var checkedTypes = dataType_1.coerceAndCheckDataType(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\n\nfunction checkRefsAndKeywords(it) {\n  var schema = it.schema,\n      errSchemaPath = it.errSchemaPath,\n      opts = it.opts,\n      self = it.self;\n\n  if (schema.$ref && opts.ignoreKeywordsWithRef && util_1.schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(\"$ref: keywords ignored in schema at path \\\"\".concat(errSchemaPath, \"\\\"\"));\n  }\n}\n\nfunction checkNoDefault(it) {\n  var schema = it.schema,\n      opts = it.opts;\n\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    util_1.checkStrictMode(it, \"default is ignored in the schema root\");\n  }\n}\n\nfunction updateContext(it) {\n  if (it.schema.$id) it.baseId = resolve_1.resolveUrl(it.baseId, it.schema.$id);\n}\n\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\n\nfunction commentKeyword(_ref3) {\n  var gen = _ref3.gen,\n      schemaEnv = _ref3.schemaEnv,\n      schema = _ref3.schema,\n      errSchemaPath = _ref3.errSchemaPath,\n      opts = _ref3.opts;\n  var msg = schema.$comment;\n\n  if (opts.$comment === true) {\n    gen.code(codegen_1._(_templateObject24 || (_templateObject24 = _taggedTemplateLiteral([\"\", \".logger.log(\", \")\"])), names_1.default.self, msg));\n  } else if (typeof opts.$comment == \"function\") {\n    var schemaPath = codegen_1.str(_templateObject25 || (_templateObject25 = _taggedTemplateLiteral([\"\", \"/$comment\"])), errSchemaPath);\n    var rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code(codegen_1._(_templateObject26 || (_templateObject26 = _taggedTemplateLiteral([\"\", \".opts.$comment(\", \", \", \", \", \".schema)\"])), names_1.default.self, msg, schemaPath, rootName));\n  }\n}\n\nfunction returnResults(it) {\n  var gen = it.gen,\n      schemaEnv = it.schemaEnv,\n      validateName = it.validateName,\n      ValidationError = it.ValidationError,\n      opts = it.opts;\n\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(codegen_1._(_templateObject27 || (_templateObject27 = _taggedTemplateLiteral([\"\", \" === 0\"])), names_1.default.errors), function () {\n      return gen.return(names_1.default.data);\n    }, function () {\n      return gen.throw(codegen_1._(_templateObject28 || (_templateObject28 = _taggedTemplateLiteral([\"new \", \"(\", \")\"])), ValidationError, names_1.default.vErrors));\n    });\n  } else {\n    gen.assign(codegen_1._(_templateObject29 || (_templateObject29 = _taggedTemplateLiteral([\"\", \".errors\"])), validateName), names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return(codegen_1._(_templateObject30 || (_templateObject30 = _taggedTemplateLiteral([\"\", \" === 0\"])), names_1.default.errors));\n  }\n}\n\nfunction assignEvaluated(_ref4) {\n  var gen = _ref4.gen,\n      evaluated = _ref4.evaluated,\n      props = _ref4.props,\n      items = _ref4.items;\n  if (props instanceof codegen_1.Name) gen.assign(codegen_1._(_templateObject31 || (_templateObject31 = _taggedTemplateLiteral([\"\", \".props\"])), evaluated), props);\n  if (items instanceof codegen_1.Name) gen.assign(codegen_1._(_templateObject32 || (_templateObject32 = _taggedTemplateLiteral([\"\", \".items\"])), evaluated), items);\n}\n\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  var gen = it.gen,\n      schema = it.schema,\n      data = it.data,\n      allErrors = it.allErrors,\n      opts = it.opts,\n      self = it.self;\n  var RULES = self.RULES;\n\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !util_1.schemaHasRulesButRef(schema, RULES))) {\n    gen.block(function () {\n      return keywordCode(it, \"$ref\", RULES.all.$ref.definition);\n    }); // TODO typecast\n\n    return;\n  }\n\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(function () {\n    var _iterator = _createForOfIteratorHelper(RULES.rules),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var group = _step.value;\n        groupKeywords(group);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    groupKeywords(RULES.post);\n  });\n\n  function groupKeywords(group) {\n    if (!applicability_1.shouldUseGroup(schema, group)) return;\n\n    if (group.type) {\n      gen.if(dataType_2.checkDataType(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        dataType_2.reportTypeError(it);\n      }\n\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    } // TODO make it \"ok\" call?\n\n\n    if (!allErrors) gen.if(codegen_1._(_templateObject33 || (_templateObject33 = _taggedTemplateLiteral([\"\", \" === \", \"\"])), names_1.default.errors, errsCount || 0));\n  }\n}\n\nfunction iterateKeywords(it, group) {\n  var gen = it.gen,\n      schema = it.schema,\n      useDefaults = it.opts.useDefaults;\n  if (useDefaults) defaults_1.assignDefaults(it, group.type);\n  gen.block(function () {\n    var _iterator2 = _createForOfIteratorHelper(group.rules),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var rule = _step2.value;\n\n        if (applicability_1.shouldUseRule(schema, rule)) {\n          keywordCode(it, rule.keyword, rule.definition, group.type);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  });\n}\n\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\n\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n\n  types.forEach(function (t) {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, \"type \\\"\".concat(t, \"\\\" not allowed by context \\\"\").concat(it.dataTypes.join(\",\"), \"\\\"\"));\n    }\n  });\n  it.dataTypes = it.dataTypes.filter(function (t) {\n    return includesType(types, t);\n  });\n}\n\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\n\nfunction checkKeywordTypes(it, ts) {\n  var rules = it.self.RULES.all;\n\n  for (var keyword in rules) {\n    var rule = rules[keyword];\n\n    if (typeof rule == \"object\" && applicability_1.shouldUseRule(it.schema, rule)) {\n      var type = rule.definition.type;\n\n      if (type.length && !type.some(function (t) {\n        return hasApplicableType(ts, t);\n      })) {\n        strictTypesError(it, \"missing type \\\"\".concat(type.join(\",\"), \"\\\" for keyword \\\"\").concat(keyword, \"\\\"\"));\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\n\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\n\nfunction strictTypesError(it, msg) {\n  var schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += \" at \\\"\".concat(schemaPath, \"\\\" (strictTypes)\");\n  util_1.checkStrictMode(it, msg, it.opts.strictTypes);\n}\n\nvar KeywordCxt = /*#__PURE__*/function () {\n  function KeywordCxt(it, def, keyword) {\n    _classCallCheck(this, KeywordCxt);\n\n    keyword_1.validateKeywordUsage(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = util_1.schemaRefOrVal(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n\n      if (!keyword_1.validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(\"\".concat(keyword, \" value must be \").concat(JSON.stringify(def.schemaType)));\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n\n  _createClass(KeywordCxt, [{\n    key: \"result\",\n    value: function result(condition, successAction, failAction) {\n      this.gen.if(codegen_1.not(condition));\n      if (failAction) failAction();else this.error();\n\n      if (successAction) {\n        this.gen.else();\n        successAction();\n        if (this.allErrors) this.gen.endIf();\n      } else {\n        if (this.allErrors) this.gen.endIf();else this.gen.else();\n      }\n    }\n  }, {\n    key: \"pass\",\n    value: function pass(condition, failAction) {\n      this.result(condition, undefined, failAction);\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(condition) {\n      if (condition === undefined) {\n        this.error();\n        if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n\n        return;\n      }\n\n      this.gen.if(condition);\n      this.error();\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }, {\n    key: \"fail$data\",\n    value: function fail$data(condition) {\n      if (!this.$data) return this.fail(condition);\n      var schemaCode = this.schemaCode;\n      this.fail(codegen_1._(_templateObject34 || (_templateObject34 = _taggedTemplateLiteral([\"\", \" !== undefined && (\", \")\"])), schemaCode, codegen_1.or(this.invalid$data(), condition)));\n    }\n  }, {\n    key: \"error\",\n    value: function error(append, errorParams, errorPaths) {\n      if (errorParams) {\n        this.setParams(errorParams);\n\n        this._error(append, errorPaths);\n\n        this.setParams({});\n        return;\n      }\n\n      this._error(append, errorPaths);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(append, errorPaths) {\n      ;\n      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n  }, {\n    key: \"$dataError\",\n    value: function $dataError() {\n      errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n      errors_1.resetErrorsCount(this.gen, this.errsCount);\n    }\n  }, {\n    key: \"ok\",\n    value: function ok(cond) {\n      if (!this.allErrors) this.gen.if(cond);\n    }\n  }, {\n    key: \"setParams\",\n    value: function setParams(obj, assign) {\n      if (assign) Object.assign(this.params, obj);else this.params = obj;\n    }\n  }, {\n    key: \"block$data\",\n    value: function block$data(valid, codeBlock) {\n      var _this = this;\n\n      var $dataValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : codegen_1.nil;\n      this.gen.block(function () {\n        _this.check$data(valid, $dataValid);\n\n        codeBlock();\n      });\n    }\n  }, {\n    key: \"check$data\",\n    value: function check$data() {\n      var valid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : codegen_1.nil;\n      var $dataValid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : codegen_1.nil;\n      if (!this.$data) return;\n      var gen = this.gen,\n          schemaCode = this.schemaCode,\n          schemaType = this.schemaType,\n          def = this.def;\n      gen.if(codegen_1.or(codegen_1._(_templateObject35 || (_templateObject35 = _taggedTemplateLiteral([\"\", \" === undefined\"])), schemaCode), $dataValid));\n      if (valid !== codegen_1.nil) gen.assign(valid, true);\n\n      if (schemaType.length || def.validateSchema) {\n        gen.elseIf(this.invalid$data());\n        this.$dataError();\n        if (valid !== codegen_1.nil) gen.assign(valid, false);\n      }\n\n      gen.else();\n    }\n  }, {\n    key: \"invalid$data\",\n    value: function invalid$data() {\n      var gen = this.gen,\n          schemaCode = this.schemaCode,\n          schemaType = this.schemaType,\n          def = this.def,\n          it = this.it;\n      return codegen_1.or(wrong$DataType(), invalid$DataSchema());\n\n      function wrong$DataType() {\n        if (schemaType.length) {\n          /* istanbul ignore if */\n          if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n          var st = Array.isArray(schemaType) ? schemaType : [schemaType];\n          return codegen_1._(_templateObject36 || (_templateObject36 = _taggedTemplateLiteral([\"\", \"\"])), dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong));\n        }\n\n        return codegen_1.nil;\n      }\n\n      function invalid$DataSchema() {\n        if (def.validateSchema) {\n          var validateSchemaRef = gen.scopeValue(\"validate$data\", {\n            ref: def.validateSchema\n          }); // TODO value.code for standalone\n\n          return codegen_1._(_templateObject37 || (_templateObject37 = _taggedTemplateLiteral([\"!\", \"(\", \")\"])), validateSchemaRef, schemaCode);\n        }\n\n        return codegen_1.nil;\n      }\n    }\n  }, {\n    key: \"subschema\",\n    value: function subschema(appl, valid) {\n      var subschema = subschema_1.getSubschema(this.it, appl);\n      subschema_1.extendSubschemaData(subschema, this.it, appl);\n      subschema_1.extendSubschemaMode(subschema, appl);\n\n      var nextContext = _objectSpread(_objectSpread(_objectSpread({}, this.it), subschema), {}, {\n        items: undefined,\n        props: undefined\n      });\n\n      subschemaCode(nextContext, valid);\n      return nextContext;\n    }\n  }, {\n    key: \"mergeEvaluated\",\n    value: function mergeEvaluated(schemaCxt, toName) {\n      var it = this.it,\n          gen = this.gen;\n      if (!it.opts.unevaluated) return;\n\n      if (it.props !== true && schemaCxt.props !== undefined) {\n        it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n      }\n\n      if (it.items !== true && schemaCxt.items !== undefined) {\n        it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n      }\n    }\n  }, {\n    key: \"mergeValidEvaluated\",\n    value: function mergeValidEvaluated(schemaCxt, valid) {\n      var _this2 = this;\n\n      var it = this.it,\n          gen = this.gen;\n\n      if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n        gen.if(valid, function () {\n          return _this2.mergeEvaluated(schemaCxt, codegen_1.Name);\n        });\n        return true;\n      }\n    }\n  }]);\n\n  return KeywordCxt;\n}();\n\nexports.KeywordCxt = KeywordCxt;\n\nfunction keywordCode(it, keyword, def, ruleType) {\n  var cxt = new KeywordCxt(it, def, keyword);\n\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    keyword_1.funcKeywordCode(cxt, def);\n  } else if (\"macro\" in def) {\n    keyword_1.macroKeywordCode(cxt, def);\n  } else if (def.compile || def.validate) {\n    keyword_1.funcKeywordCode(cxt, def);\n  }\n}\n\nvar JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nvar RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\n\nfunction getData($data, _ref5) {\n  var dataLevel = _ref5.dataLevel,\n      dataNames = _ref5.dataNames,\n      dataPathArr = _ref5.dataPathArr;\n  var jsonPointer;\n  var data;\n  if ($data === \"\") return names_1.default.rootData;\n\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(\"Invalid JSON-pointer: \".concat($data));\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    var matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(\"Invalid JSON-pointer: \".concat($data));\n    var up = +matches[1];\n    jsonPointer = matches[2];\n\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n\n  var expr = data;\n  var segments = jsonPointer.split(\"/\");\n\n  var _iterator3 = _createForOfIteratorHelper(segments),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var segment = _step3.value;\n\n      if (segment) {\n        data = codegen_1._(_templateObject38 || (_templateObject38 = _taggedTemplateLiteral([\"\", \"\", \"\"])), data, codegen_1.getProperty(util_1.unescapeJsonPointer(segment)));\n        expr = codegen_1._(_templateObject39 || (_templateObject39 = _taggedTemplateLiteral([\"\", \" && \", \"\"])), expr, data);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return expr;\n\n  function errorMsg(pointerType, up) {\n    return \"Cannot access \".concat(pointerType, \" \").concat(up, \" levels up, current level is \").concat(dataLevel);\n  }\n}\n\nexports.getData = getData;","map":{"version":3,"sources":["../../../lib/compile/validate/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, codegen_1._ `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code(codegen_1._ `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, codegen_1._ `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return codegen_1._ `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen_1._ `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, codegen_1._ `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, codegen_1._ `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, codegen_1._ `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, codegen_1._ `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, codegen_1._ `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, codegen_1._ `\"\"`);\n        gen.var(names_1.default.parentData, codegen_1._ `undefined`);\n        gen.var(names_1.default.parentDataProperty, codegen_1._ `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, codegen_1._ `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", codegen_1._ `${validateName}.evaluated`);\n    gen.if(codegen_1._ `${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1._ `${it.evaluated}.props`, codegen_1._ `undefined`));\n    gen.if(codegen_1._ `${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1._ `${it.evaluated}.items`, codegen_1._ `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    return typeof schema == \"object\" && schema.$id && (opts.code.source || opts.code.process)\n        ? codegen_1._ `/*# sourceURL=${schema.$id} */`\n        : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    boolSchema_1.boolOrEmptySchema(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, codegen_1._ `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    util_1.checkUnknownRules(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = dataType_1.getSchemaTypes(it.schema);\n    const checkedTypes = dataType_1.coerceAndCheckDataType(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && util_1.schemaHasRulesButRef(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        util_1.checkStrictMode(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    if (it.schema.$id)\n        it.baseId = resolve_1.resolveUrl(it.baseId, it.schema.$id);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code(codegen_1._ `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = codegen_1.str `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code(codegen_1._ `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if(codegen_1._ `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw(codegen_1._ `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign(codegen_1._ `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return(codegen_1._ `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign(codegen_1._ `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign(codegen_1._ `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !util_1.schemaHasRulesButRef(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!applicability_1.shouldUseGroup(schema, group))\n            return;\n        if (group.type) {\n            gen.if(dataType_2.checkDataType(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                dataType_2.reportTypeError(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if(codegen_1._ `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        defaults_1.assignDefaults(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if (applicability_1.shouldUseRule(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && applicability_1.shouldUseRule(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    util_1.checkStrictMode(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        keyword_1.validateKeywordUsage(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = util_1.schemaRefOrVal(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!keyword_1.validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.gen.if(codegen_1.not(condition));\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.result(condition, undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail(codegen_1._ `${schemaCode} !== undefined && (${codegen_1.or(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        errors_1.resetErrorsCount(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if(codegen_1.or(codegen_1._ `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return codegen_1.or(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return codegen_1._ `${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return codegen_1._ `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = subschema_1.getSubschema(this.it, appl);\n        subschema_1.extendSubschemaData(subschema, this.it, appl);\n        subschema_1.extendSubschemaMode(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        keyword_1.funcKeywordCode(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        keyword_1.macroKeywordCode(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        keyword_1.funcKeywordCode(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = codegen_1._ `${data}${codegen_1.getProperty(util_1.unescapeJsonPointer(segment))}`;\n            expr = codegen_1._ `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}