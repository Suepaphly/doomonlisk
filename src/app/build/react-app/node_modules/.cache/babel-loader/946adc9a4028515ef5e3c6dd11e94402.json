{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBlock = exports.decodeBlock = exports.encodeTransaction = exports.decodeTransaction = exports.decodeAccount = exports.getTransactionAssetSchema = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar getTransactionAssetSchema = function getTransactionAssetSchema(transaction, registeredSchema) {\n  var txAssetSchema = registeredSchema.transactionsAssets.find(function (assetSchema) {\n    return assetSchema.moduleID === transaction.moduleID && assetSchema.assetID === transaction.assetID;\n  });\n\n  if (!txAssetSchema) {\n    throw new Error(\"ModuleID: \".concat(transaction.moduleID, \" AssetID: \").concat(transaction.assetID, \" is not registered.\"));\n  }\n\n  return txAssetSchema.schema;\n};\n\nexports.getTransactionAssetSchema = getTransactionAssetSchema;\n\nvar decodeAccount = function decodeAccount(encodedAccount, registeredSchema) {\n  return lisk_codec_1.codec.decode(registeredSchema.account, encodedAccount);\n};\n\nexports.decodeAccount = decodeAccount;\n\nvar decodeTransaction = function decodeTransaction(encodedTransaction, registeredSchema) {\n  var transaction = lisk_codec_1.codec.decode(registeredSchema.transaction, encodedTransaction);\n  var assetSchema = exports.getTransactionAssetSchema(transaction, registeredSchema);\n  var asset = lisk_codec_1.codec.decode(assetSchema, transaction.asset);\n  var id = lisk_cryptography_1.hash(encodedTransaction);\n  return _objectSpread(_objectSpread({}, transaction), {}, {\n    asset: asset,\n    id: id\n  });\n};\n\nexports.decodeTransaction = decodeTransaction;\n\nvar encodeTransaction = function encodeTransaction(transaction, registeredSchema) {\n  var assetSchema = exports.getTransactionAssetSchema(transaction, registeredSchema);\n  var encodedAsset = lisk_codec_1.codec.encode(assetSchema, transaction.asset);\n  var decodedTransaction = lisk_codec_1.codec.encode(registeredSchema.transaction, _objectSpread(_objectSpread({}, transaction), {}, {\n    asset: encodedAsset\n  }));\n  return decodedTransaction;\n};\n\nexports.encodeTransaction = encodeTransaction;\n\nvar decodeBlock = function decodeBlock(encodedBlock, registeredSchema) {\n  var block = lisk_codec_1.codec.decode(registeredSchema.block, encodedBlock);\n  var header = lisk_codec_1.codec.decode(registeredSchema.blockHeader, block.header);\n  var id = lisk_cryptography_1.hash(block.header);\n  var assetSchema = registeredSchema.blockHeadersAssets[header.version];\n\n  if (!assetSchema) {\n    throw new Error(\"Block header asset version \".concat(header.version, \" is not registered.\"));\n  }\n\n  var asset = lisk_codec_1.codec.decode(assetSchema, header.asset);\n  var payload = [];\n\n  var _iterator = _createForOfIteratorHelper(block.payload),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var tx = _step.value;\n      payload.push(exports.decodeTransaction(tx, registeredSchema));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return {\n    header: _objectSpread(_objectSpread({}, header), {}, {\n      asset: asset,\n      id: id\n    }),\n    payload: payload\n  };\n};\n\nexports.decodeBlock = decodeBlock;\n\nvar encodeBlock = function encodeBlock(block, registeredSchema) {\n  var encodedPayload = block.payload.map(function (p) {\n    return exports.encodeTransaction(p, registeredSchema);\n  });\n  var assetSchema = registeredSchema.blockHeadersAssets[block.header.version];\n\n  if (!assetSchema) {\n    throw new Error(\"Block header asset version \".concat(block.header.version, \" is not registered.\"));\n  }\n\n  var encodedBlockAsset = lisk_codec_1.codec.encode(assetSchema, block.header.asset);\n  var encodedBlockHeader = lisk_codec_1.codec.encode(registeredSchema.blockHeader, _objectSpread(_objectSpread({}, block.header), {}, {\n    asset: encodedBlockAsset\n  }));\n  return lisk_codec_1.codec.encode(registeredSchema.block, {\n    header: encodedBlockHeader,\n    payload: encodedPayload\n  });\n};\n\nexports.encodeBlock = encodeBlock;","map":{"version":3,"sources":["../src/codec.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeBlock = exports.decodeBlock = exports.encodeTransaction = exports.decodeTransaction = exports.decodeAccount = exports.getTransactionAssetSchema = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst getTransactionAssetSchema = (transaction, registeredSchema) => {\n    const txAssetSchema = registeredSchema.transactionsAssets.find(assetSchema => assetSchema.moduleID === transaction.moduleID && assetSchema.assetID === transaction.assetID);\n    if (!txAssetSchema) {\n        throw new Error(`ModuleID: ${transaction.moduleID} AssetID: ${transaction.assetID} is not registered.`);\n    }\n    return txAssetSchema.schema;\n};\nexports.getTransactionAssetSchema = getTransactionAssetSchema;\nconst decodeAccount = (encodedAccount, registeredSchema) => lisk_codec_1.codec.decode(registeredSchema.account, encodedAccount);\nexports.decodeAccount = decodeAccount;\nconst decodeTransaction = (encodedTransaction, registeredSchema) => {\n    const transaction = lisk_codec_1.codec.decode(registeredSchema.transaction, encodedTransaction);\n    const assetSchema = exports.getTransactionAssetSchema(transaction, registeredSchema);\n    const asset = lisk_codec_1.codec.decode(assetSchema, transaction.asset);\n    const id = lisk_cryptography_1.hash(encodedTransaction);\n    return {\n        ...transaction,\n        asset,\n        id,\n    };\n};\nexports.decodeTransaction = decodeTransaction;\nconst encodeTransaction = (transaction, registeredSchema) => {\n    const assetSchema = exports.getTransactionAssetSchema(transaction, registeredSchema);\n    const encodedAsset = lisk_codec_1.codec.encode(assetSchema, transaction.asset);\n    const decodedTransaction = lisk_codec_1.codec.encode(registeredSchema.transaction, {\n        ...transaction,\n        asset: encodedAsset,\n    });\n    return decodedTransaction;\n};\nexports.encodeTransaction = encodeTransaction;\nconst decodeBlock = (encodedBlock, registeredSchema) => {\n    const block = lisk_codec_1.codec.decode(registeredSchema.block, encodedBlock);\n    const header = lisk_codec_1.codec.decode(registeredSchema.blockHeader, block.header);\n    const id = lisk_cryptography_1.hash(block.header);\n    const assetSchema = registeredSchema.blockHeadersAssets[header.version];\n    if (!assetSchema) {\n        throw new Error(`Block header asset version ${header.version} is not registered.`);\n    }\n    const asset = lisk_codec_1.codec.decode(assetSchema, header.asset);\n    const payload = [];\n    for (const tx of block.payload) {\n        payload.push(exports.decodeTransaction(tx, registeredSchema));\n    }\n    return {\n        header: {\n            ...header,\n            asset,\n            id,\n        },\n        payload,\n    };\n};\nexports.decodeBlock = decodeBlock;\nconst encodeBlock = (block, registeredSchema) => {\n    const encodedPayload = block.payload.map(p => exports.encodeTransaction(p, registeredSchema));\n    const assetSchema = registeredSchema.blockHeadersAssets[block.header.version];\n    if (!assetSchema) {\n        throw new Error(`Block header asset version ${block.header.version} is not registered.`);\n    }\n    const encodedBlockAsset = lisk_codec_1.codec.encode(assetSchema, block.header.asset);\n    const encodedBlockHeader = lisk_codec_1.codec.encode(registeredSchema.blockHeader, {\n        ...block.header,\n        asset: encodedBlockAsset,\n    });\n    return lisk_codec_1.codec.encode(registeredSchema.block, {\n        header: encodedBlockHeader,\n        payload: encodedPayload,\n    });\n};\nexports.encodeBlock = encodeBlock;\n//# sourceMappingURL=codec.js.map"]},"metadata":{},"sourceType":"script"}