{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InboundPeer = void 0;\n\nvar constants_1 = require(\"../constants\");\n\nvar events_1 = require(\"../events\");\n\nvar base_1 = require(\"./base\");\n\nvar getRandomPingDelay = function getRandomPingDelay() {\n  return Math.random() * (constants_1.DEFAULT_PING_INTERVAL_MAX - constants_1.DEFAULT_PING_INTERVAL_MIN) + constants_1.DEFAULT_PING_INTERVAL_MIN;\n};\n\nvar InboundPeer = /*#__PURE__*/function (_base_1$Peer) {\n  _inherits(InboundPeer, _base_1$Peer);\n\n  var _super = _createSuper(InboundPeer);\n\n  function InboundPeer(peerInfo, peerSocket, peerConfig) {\n    var _this;\n\n    _classCallCheck(this, InboundPeer);\n\n    _this = _super.call(this, peerInfo, peerConfig);\n    _this._peerInfo.internalState.connectionKind = constants_1.ConnectionKind.INBOUND;\n\n    _this._handleInboundSocketError = function (error) {\n      _this.emit(events_1.EVENT_INBOUND_SOCKET_ERROR, error);\n    };\n\n    _this._handleInboundSocketClose = function (code, reasonMessage) {\n      var _a;\n\n      var reason = reasonMessage !== undefined && reasonMessage !== '' ? reasonMessage : (_a = base_1.socketErrorStatusCodes[code]) !== null && _a !== void 0 ? _a : 'Unknown reason';\n\n      if (_this._pingTimeoutId) {\n        clearTimeout(_this._pingTimeoutId);\n      }\n\n      _this.emit(events_1.EVENT_CLOSE_INBOUND, {\n        peerInfo: peerInfo,\n        code: code,\n        reason: reason\n      });\n    };\n\n    _this._pingTimeoutId = setTimeout(function () {\n      _this._sendPing();\n    }, getRandomPingDelay());\n    _this._socket = peerSocket;\n\n    _this._bindHandlersToInboundSocket(_this._socket);\n\n    return _this;\n  }\n\n  _createClass(InboundPeer, [{\n    key: \"socket\",\n    set: function set(scServerSocket) {\n      this._unbindHandlersFromInboundSocket(this._socket);\n\n      this._socket = scServerSocket;\n\n      this._bindHandlersToInboundSocket(this._socket);\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : constants_1.INTENTIONAL_DISCONNECT_CODE;\n      var reason = arguments.length > 1 ? arguments[1] : undefined;\n\n      _get(_getPrototypeOf(InboundPeer.prototype), \"disconnect\", this).call(this, code, reason);\n\n      clearTimeout(this._pingTimeoutId);\n\n      this._unbindHandlersFromInboundSocket(this._socket);\n    }\n  }, {\n    key: \"_sendPing\",\n    value: function _sendPing() {\n      var _this2 = this;\n\n      var pingStart = Date.now();\n      this.request({\n        procedure: events_1.REMOTE_EVENT_PING\n      }).catch(function () {}).finally(function () {\n        _this2._peerInfo.internalState.latency = Date.now() - pingStart;\n        _this2._pingTimeoutId = setTimeout(function () {\n          _this2._sendPing();\n        }, getRandomPingDelay());\n      });\n    }\n  }, {\n    key: \"_bindHandlersToInboundSocket\",\n    value: function _bindHandlersToInboundSocket(inboundSocket) {\n      inboundSocket.on('close', this._handleInboundSocketClose);\n      inboundSocket.on('error', this._handleInboundSocketError);\n      inboundSocket.on('message', this._handleWSMessage);\n      inboundSocket.on(events_1.REMOTE_SC_EVENT_RPC_REQUEST, this._handleRawRPC);\n      inboundSocket.on(events_1.REMOTE_SC_EVENT_MESSAGE, this._handleRawMessage);\n    }\n  }, {\n    key: \"_unbindHandlersFromInboundSocket\",\n    value: function _unbindHandlersFromInboundSocket(inboundSocket) {\n      inboundSocket.off('close', this._handleInboundSocketClose);\n      inboundSocket.off('message', this._handleWSMessage);\n      inboundSocket.off(events_1.REMOTE_SC_EVENT_RPC_REQUEST, this._handleRawRPC);\n      inboundSocket.off(events_1.REMOTE_SC_EVENT_MESSAGE, this._handleRawMessage);\n    }\n  }]);\n\n  return InboundPeer;\n}(base_1.Peer);\n\nexports.InboundPeer = InboundPeer;","map":{"version":3,"sources":["../../src/peer/inbound.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InboundPeer = void 0;\nconst constants_1 = require(\"../constants\");\nconst events_1 = require(\"../events\");\nconst base_1 = require(\"./base\");\nconst getRandomPingDelay = () => Math.random() * (constants_1.DEFAULT_PING_INTERVAL_MAX - constants_1.DEFAULT_PING_INTERVAL_MIN) +\n    constants_1.DEFAULT_PING_INTERVAL_MIN;\nclass InboundPeer extends base_1.Peer {\n    constructor(peerInfo, peerSocket, peerConfig) {\n        super(peerInfo, peerConfig);\n        this._peerInfo.internalState.connectionKind = constants_1.ConnectionKind.INBOUND;\n        this._handleInboundSocketError = (error) => {\n            this.emit(events_1.EVENT_INBOUND_SOCKET_ERROR, error);\n        };\n        this._handleInboundSocketClose = (code, reasonMessage) => {\n            var _a;\n            const reason = reasonMessage !== undefined && reasonMessage !== ''\n                ? reasonMessage\n                : (_a = base_1.socketErrorStatusCodes[code]) !== null && _a !== void 0 ? _a : 'Unknown reason';\n            if (this._pingTimeoutId) {\n                clearTimeout(this._pingTimeoutId);\n            }\n            this.emit(events_1.EVENT_CLOSE_INBOUND, {\n                peerInfo,\n                code,\n                reason,\n            });\n        };\n        this._pingTimeoutId = setTimeout(() => {\n            this._sendPing();\n        }, getRandomPingDelay());\n        this._socket = peerSocket;\n        this._bindHandlersToInboundSocket(this._socket);\n    }\n    set socket(scServerSocket) {\n        this._unbindHandlersFromInboundSocket(this._socket);\n        this._socket = scServerSocket;\n        this._bindHandlersToInboundSocket(this._socket);\n    }\n    disconnect(code = constants_1.INTENTIONAL_DISCONNECT_CODE, reason) {\n        super.disconnect(code, reason);\n        clearTimeout(this._pingTimeoutId);\n        this._unbindHandlersFromInboundSocket(this._socket);\n    }\n    _sendPing() {\n        const pingStart = Date.now();\n        this.request({ procedure: events_1.REMOTE_EVENT_PING })\n            .catch(() => { })\n            .finally(() => {\n            this._peerInfo.internalState.latency = Date.now() - pingStart;\n            this._pingTimeoutId = setTimeout(() => {\n                this._sendPing();\n            }, getRandomPingDelay());\n        });\n    }\n    _bindHandlersToInboundSocket(inboundSocket) {\n        inboundSocket.on('close', this._handleInboundSocketClose);\n        inboundSocket.on('error', this._handleInboundSocketError);\n        inboundSocket.on('message', this._handleWSMessage);\n        inboundSocket.on(events_1.REMOTE_SC_EVENT_RPC_REQUEST, this._handleRawRPC);\n        inboundSocket.on(events_1.REMOTE_SC_EVENT_MESSAGE, this._handleRawMessage);\n    }\n    _unbindHandlersFromInboundSocket(inboundSocket) {\n        inboundSocket.off('close', this._handleInboundSocketClose);\n        inboundSocket.off('message', this._handleWSMessage);\n        inboundSocket.off(events_1.REMOTE_SC_EVENT_RPC_REQUEST, this._handleRawRPC);\n        inboundSocket.off(events_1.REMOTE_SC_EVENT_MESSAGE, this._handleRawMessage);\n    }\n}\nexports.InboundPeer = InboundPeer;\n//# sourceMappingURL=inbound.js.map"]},"metadata":{},"sourceType":"script"}