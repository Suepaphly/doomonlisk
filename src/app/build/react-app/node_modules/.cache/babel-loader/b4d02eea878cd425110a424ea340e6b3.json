{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.selectPeersForConnection = exports.selectPeersForSend = exports.selectPeersForRequest = void 0;\n\nvar constants_1 = require(\"../constants\");\n\nvar shuffle = require(\"lodash.shuffle\");\n\nvar _removeCommonIPsFromLists = function _removeCommonIPsFromLists(peerList) {\n  var peerMap = new Map();\n\n  var _iterator = _createForOfIteratorHelper(peerList),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var peer = _step.value;\n      var internalState = peer.internalState;\n      var peerReputation = internalState ? internalState.reputation : 0;\n      var tempPeer = peerMap.get(peer.ipAddress);\n\n      if (tempPeer) {\n        var tempInternalState = tempPeer.internalState;\n        var tempPeerReputation = tempInternalState ? tempInternalState.reputation : 0;\n\n        if (peerReputation > tempPeerReputation) {\n          peerMap.set(peer.ipAddress, peer);\n        }\n      } else {\n        peerMap.set(peer.ipAddress, peer);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return _toConsumableArray(peerMap.values());\n};\n\nvar selectPeersForRequest = function selectPeersForRequest(input) {\n  var peers = input.peers;\n  var peerLimit = input.peerLimit;\n\n  if (peers.length === 0) {\n    return [];\n  }\n\n  if (peerLimit === undefined) {\n    return shuffle(peers);\n  }\n\n  return shuffle(peers).slice(0, peerLimit);\n};\n\nexports.selectPeersForRequest = selectPeersForRequest;\n\nvar selectPeersForSend = function selectPeersForSend(input) {\n  var shuffledPeers = shuffle(input.peers);\n  var peerLimit = input.peerLimit;\n  var halfPeerLimit = Math.round(peerLimit / 2);\n  var outboundPeers = shuffledPeers.filter(function (peerInfo) {\n    return peerInfo.internalState ? peerInfo.internalState.connectionKind === constants_1.ConnectionKind.OUTBOUND : false;\n  });\n  var inboundPeers = shuffledPeers.filter(function (peerInfo) {\n    return peerInfo.internalState ? peerInfo.internalState.connectionKind === constants_1.ConnectionKind.INBOUND : false;\n  });\n  var fixedPeers = shuffledPeers.filter(function (peerInfo) {\n    return peerInfo.internalState ? peerInfo.internalState.peerKind === constants_1.PeerKind.FIXED_PEER : false;\n  });\n  var shortestPeersList;\n  var longestPeersList;\n\n  if (outboundPeers.length < inboundPeers.length) {\n    shortestPeersList = outboundPeers;\n    longestPeersList = inboundPeers;\n  } else {\n    shortestPeersList = inboundPeers;\n    longestPeersList = outboundPeers;\n  }\n\n  var selectedFirstKindPeers = shortestPeersList.slice(0, halfPeerLimit);\n  var remainingPeerLimit = peerLimit - selectedFirstKindPeers.length;\n  var selectedSecondKindPeers = longestPeersList.slice(0, remainingPeerLimit);\n  var selectedPeers = selectedFirstKindPeers.concat(selectedSecondKindPeers).concat(fixedPeers);\n\n  var uniquePeerIds = _toConsumableArray(new Set(selectedPeers.map(function (p) {\n    return p.peerId;\n  })));\n\n  var uniquePeers = uniquePeerIds.map(function (peerId) {\n    return selectedPeers.find(function (p) {\n      return p.peerId === peerId;\n    });\n  });\n  return uniquePeers;\n};\n\nexports.selectPeersForSend = selectPeersForSend;\n\nvar selectPeersForConnection = function selectPeersForConnection(input) {\n  if (input.peerLimit && input.peerLimit < 0 || input.triedPeers.length === 0 && input.newPeers.length === 0) {\n    return [];\n  }\n\n  if (input.peerLimit === undefined || input.peerLimit >= input.triedPeers.length + input.newPeers.length) {\n    return _removeCommonIPsFromLists([].concat(_toConsumableArray(input.newPeers), _toConsumableArray(input.triedPeers)));\n  }\n\n  var minimumProbability = 0.5;\n  var x = input.triedPeers.length < 100 ? minimumProbability : input.triedPeers.length / (input.triedPeers.length + input.newPeers.length);\n  var r = Math.max(x, minimumProbability);\n  var shuffledTriedPeers = shuffle(input.triedPeers);\n  var shuffledNewPeers = shuffle(input.newPeers);\n\n  var peerList = _toConsumableArray(new Array(input.peerLimit)).map(function () {\n    if (shuffledTriedPeers.length !== 0) {\n      if (Math.random() < r) {\n        return shuffledTriedPeers.pop();\n      }\n    }\n\n    if (shuffledNewPeers.length !== 0) {\n      return shuffledNewPeers.pop();\n    }\n\n    return shuffledTriedPeers.pop();\n  });\n\n  return _removeCommonIPsFromLists(peerList);\n};\n\nexports.selectPeersForConnection = selectPeersForConnection;","map":{"version":3,"sources":["../../src/utils/select.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.selectPeersForConnection = exports.selectPeersForSend = exports.selectPeersForRequest = void 0;\nconst constants_1 = require(\"../constants\");\nconst shuffle = require(\"lodash.shuffle\");\nconst _removeCommonIPsFromLists = (peerList) => {\n    const peerMap = new Map();\n    for (const peer of peerList) {\n        const { internalState } = peer;\n        const peerReputation = internalState ? internalState.reputation : 0;\n        const tempPeer = peerMap.get(peer.ipAddress);\n        if (tempPeer) {\n            const { internalState: tempInternalState } = tempPeer;\n            const tempPeerReputation = tempInternalState ? tempInternalState.reputation : 0;\n            if (peerReputation > tempPeerReputation) {\n                peerMap.set(peer.ipAddress, peer);\n            }\n        }\n        else {\n            peerMap.set(peer.ipAddress, peer);\n        }\n    }\n    return [...peerMap.values()];\n};\nconst selectPeersForRequest = (input) => {\n    const { peers } = input;\n    const { peerLimit } = input;\n    if (peers.length === 0) {\n        return [];\n    }\n    if (peerLimit === undefined) {\n        return shuffle(peers);\n    }\n    return shuffle(peers).slice(0, peerLimit);\n};\nexports.selectPeersForRequest = selectPeersForRequest;\nconst selectPeersForSend = (input) => {\n    const shuffledPeers = shuffle(input.peers);\n    const peerLimit = input.peerLimit;\n    const halfPeerLimit = Math.round(peerLimit / 2);\n    const outboundPeers = shuffledPeers.filter((peerInfo) => peerInfo.internalState\n        ? peerInfo.internalState.connectionKind === constants_1.ConnectionKind.OUTBOUND\n        : false);\n    const inboundPeers = shuffledPeers.filter((peerInfo) => peerInfo.internalState\n        ? peerInfo.internalState.connectionKind === constants_1.ConnectionKind.INBOUND\n        : false);\n    const fixedPeers = shuffledPeers.filter((peerInfo) => peerInfo.internalState ? peerInfo.internalState.peerKind === constants_1.PeerKind.FIXED_PEER : false);\n    let shortestPeersList;\n    let longestPeersList;\n    if (outboundPeers.length < inboundPeers.length) {\n        shortestPeersList = outboundPeers;\n        longestPeersList = inboundPeers;\n    }\n    else {\n        shortestPeersList = inboundPeers;\n        longestPeersList = outboundPeers;\n    }\n    const selectedFirstKindPeers = shortestPeersList.slice(0, halfPeerLimit);\n    const remainingPeerLimit = peerLimit - selectedFirstKindPeers.length;\n    const selectedSecondKindPeers = longestPeersList.slice(0, remainingPeerLimit);\n    const selectedPeers = selectedFirstKindPeers.concat(selectedSecondKindPeers).concat(fixedPeers);\n    const uniquePeerIds = [...new Set(selectedPeers.map(p => p.peerId))];\n    const uniquePeers = uniquePeerIds.map(peerId => selectedPeers.find(p => p.peerId === peerId));\n    return uniquePeers;\n};\nexports.selectPeersForSend = selectPeersForSend;\nconst selectPeersForConnection = (input) => {\n    if ((input.peerLimit && input.peerLimit < 0) ||\n        (input.triedPeers.length === 0 && input.newPeers.length === 0)) {\n        return [];\n    }\n    if (input.peerLimit === undefined ||\n        input.peerLimit >= input.triedPeers.length + input.newPeers.length) {\n        return _removeCommonIPsFromLists([...input.newPeers, ...input.triedPeers]);\n    }\n    const minimumProbability = 0.5;\n    const x = input.triedPeers.length < 100\n        ? minimumProbability\n        : input.triedPeers.length / (input.triedPeers.length + input.newPeers.length);\n    const r = Math.max(x, minimumProbability);\n    const shuffledTriedPeers = shuffle(input.triedPeers);\n    const shuffledNewPeers = shuffle(input.newPeers);\n    const peerList = [...new Array(input.peerLimit)].map(() => {\n        if (shuffledTriedPeers.length !== 0) {\n            if (Math.random() < r) {\n                return shuffledTriedPeers.pop();\n            }\n        }\n        if (shuffledNewPeers.length !== 0) {\n            return shuffledNewPeers.pop();\n        }\n        return shuffledTriedPeers.pop();\n    });\n    return _removeCommonIPsFromLists(peerList);\n};\nexports.selectPeersForConnection = selectPeersForConnection;\n//# sourceMappingURL=select.js.map"]},"metadata":{},"sourceType":"script"}