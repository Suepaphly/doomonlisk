{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeArray = exports.readArray = exports.readObject = exports.writeObject = void 0;\n\nvar varint_1 = require(\"./varint\");\n\nvar string_1 = require(\"./string\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar boolean_1 = require(\"./boolean\");\n\nvar keys_1 = require(\"./keys\");\n\nvar default_value_1 = require(\"./utils/default_value\");\n\nvar _readers = {\n  uint32: varint_1.readUInt32,\n  sint32: varint_1.readSInt32,\n  uint64: varint_1.readUInt64,\n  sint64: varint_1.readSInt64,\n  string: string_1.readString,\n  bytes: bytes_1.readBytes,\n  boolean: boolean_1.readBoolean\n};\nvar _writers = {\n  uint32: varint_1.writeUInt32,\n  sint32: varint_1.writeSInt32,\n  uint64: varint_1.writeUInt64,\n  sint64: varint_1.writeSInt64,\n  string: string_1.writeString,\n  bytes: bytes_1.writeBytes,\n  boolean: boolean_1.writeBoolean\n};\n\nvar writeObject = function writeObject(compiledSchema, message, chunks) {\n  var simpleObjectSize = 0;\n\n  for (var i = 0; i < compiledSchema.length; i += 1) {\n    var property = compiledSchema[i];\n\n    if (Array.isArray(property)) {\n      var headerProp = property[0];\n\n      if (headerProp.schemaProp.type === 'array') {\n        var _exports$writeArray = exports.writeArray(property, message[headerProp.propertyName], chunks),\n            _exports$writeArray2 = _slicedToArray(_exports$writeArray, 2),\n            size = _exports$writeArray2[1];\n\n        simpleObjectSize += size;\n        continue;\n      }\n\n      chunks.push(headerProp.binaryKey);\n\n      var _exports$writeObject = exports.writeObject(property, message[headerProp.propertyName], []),\n          _exports$writeObject2 = _slicedToArray(_exports$writeObject, 2),\n          encodedValues = _exports$writeObject2[0],\n          totalWrittenSize = _exports$writeObject2[1];\n\n      var objectSize = _writers.uint32(totalWrittenSize);\n\n      simpleObjectSize += objectSize.length + headerProp.binaryKey.length;\n      chunks.push(objectSize);\n\n      for (var e = 0; e < encodedValues.length; e += 1) {\n        simpleObjectSize += encodedValues[e].length;\n        chunks.push(encodedValues[e]);\n      }\n    } else {\n      if (property.schemaProp.type === 'object') {\n        continue;\n      }\n\n      var value = message[property.propertyName];\n\n      if (value === undefined) {\n        continue;\n      }\n\n      var dataType = property.schemaProp.dataType,\n          binaryKey = property.binaryKey;\n\n      if (dataType === undefined) {\n        throw new Error('Compiled Schema is corrupted as \"dataType\" can not be undefined.');\n      }\n\n      var binaryValue = _writers[dataType](value);\n\n      chunks.push(binaryKey);\n      chunks.push(binaryValue);\n      simpleObjectSize += binaryKey.length + binaryValue.length;\n    }\n  }\n\n  return [chunks, simpleObjectSize];\n};\n\nexports.writeObject = writeObject;\n\nvar readObject = function readObject(message, offset, compiledSchema, terminateIndex) {\n  var index = offset;\n  var result = {};\n\n  for (var i = 0; i < compiledSchema.length; i += 1) {\n    var typeSchema = compiledSchema[i];\n\n    if (Array.isArray(typeSchema)) {\n      if (typeSchema[0].schemaProp.type === 'array') {\n        if (index >= terminateIndex) {\n          result[typeSchema[0].propertyName] = [];\n          continue;\n        }\n\n        var _exports$readArray = exports.readArray(message, index, typeSchema, terminateIndex),\n            _exports$readArray2 = _slicedToArray(_exports$readArray, 2),\n            arr = _exports$readArray2[0],\n            nextOffset = _exports$readArray2[1];\n\n        result[typeSchema[0].propertyName] = arr;\n        index = nextOffset;\n      } else if (typeSchema[0].schemaProp.type === 'object') {\n        var _varint_1$readUInt = varint_1.readUInt32(message, index),\n            _varint_1$readUInt2 = _slicedToArray(_varint_1$readUInt, 2),\n            _keySize = _varint_1$readUInt2[1];\n\n        index += _keySize;\n\n        var _varint_1$readUInt3 = varint_1.readUInt32(message, index),\n            _varint_1$readUInt4 = _slicedToArray(_varint_1$readUInt3, 2),\n            objectSize = _varint_1$readUInt4[0],\n            objectSizeLength = _varint_1$readUInt4[1];\n\n        index += objectSizeLength;\n\n        var _exports$readObject = exports.readObject(message, index, typeSchema, objectSize + index),\n            _exports$readObject2 = _slicedToArray(_exports$readObject, 2),\n            obj = _exports$readObject2[0],\n            _nextOffset = _exports$readObject2[1];\n\n        result[typeSchema[0].propertyName] = obj;\n        index = _nextOffset;\n      } else {\n        throw new Error('Invalid container type');\n      }\n\n      continue;\n    }\n\n    if (typeSchema.schemaProp.type === 'object' || typeSchema.schemaProp.type === 'array') {\n      continue;\n    }\n\n    if (message.length <= index) {\n      result[typeSchema.propertyName] = default_value_1.getDefaultValue(typeSchema.schemaProp.dataType);\n      continue;\n    }\n\n    var _varint_1$readUInt5 = varint_1.readUInt32(message, index),\n        _varint_1$readUInt6 = _slicedToArray(_varint_1$readUInt5, 2),\n        key = _varint_1$readUInt6[0],\n        keySize = _varint_1$readUInt6[1];\n\n    var _keys_1$readKey = keys_1.readKey(key),\n        _keys_1$readKey2 = _slicedToArray(_keys_1$readKey, 1),\n        fieldNumber = _keys_1$readKey2[0];\n\n    if (fieldNumber !== typeSchema.schemaProp.fieldNumber) {\n      result[typeSchema.propertyName] = default_value_1.getDefaultValue(typeSchema.schemaProp.dataType);\n      continue;\n    }\n\n    index += keySize;\n\n    var _readers$typeSchema$s = _readers[typeSchema.schemaProp.dataType](message, index),\n        _readers$typeSchema$s2 = _slicedToArray(_readers$typeSchema$s, 2),\n        scalarValue = _readers$typeSchema$s2[0],\n        scalarSize = _readers$typeSchema$s2[1];\n\n    index += scalarSize;\n    result[typeSchema.propertyName] = scalarValue;\n  }\n\n  return [result, index];\n};\n\nexports.readObject = readObject;\n\nvar readArray = function readArray(message, offset, compiledSchema, terminateIndex) {\n  var index = offset;\n\n  if (index >= message.length) {\n    return [[], index];\n  }\n\n  var startingByte = message[index];\n\n  var _compiledSchema = _slicedToArray(compiledSchema, 2),\n      rootSchema = _compiledSchema[0],\n      typeSchema = _compiledSchema[1];\n\n  var _varint_1$readUInt7 = varint_1.readUInt32(message, index),\n      _varint_1$readUInt8 = _slicedToArray(_varint_1$readUInt7, 1),\n      key = _varint_1$readUInt8[0];\n\n  var _keys_1$readKey3 = keys_1.readKey(key),\n      _keys_1$readKey4 = _slicedToArray(_keys_1$readKey3, 1),\n      fieldNumber = _keys_1$readKey4[0];\n\n  if (fieldNumber !== rootSchema.schemaProp.fieldNumber) {\n    return [[], index];\n  }\n\n  var result = [];\n\n  if (Array.isArray(typeSchema)) {\n    var _typeSchema = _slicedToArray(typeSchema, 1),\n        nestedTypeSchema = _typeSchema[0];\n\n    if (nestedTypeSchema.schemaProp.type === 'object') {\n      while (message[index] === startingByte && index !== terminateIndex) {\n        var _varint_1$readUInt9 = varint_1.readUInt32(message, index),\n            _varint_1$readUInt10 = _slicedToArray(_varint_1$readUInt9, 2),\n            wire2KeySize = _varint_1$readUInt10[1];\n\n        index += wire2KeySize;\n\n        var _varint_1$readUInt11 = varint_1.readUInt32(message, index),\n            _varint_1$readUInt12 = _slicedToArray(_varint_1$readUInt11, 2),\n            objectSize = _varint_1$readUInt12[0],\n            objectSizeLength = _varint_1$readUInt12[1];\n\n        index += objectSizeLength;\n\n        if (objectSize === 0) {\n          continue;\n        }\n\n        var terminatingObjectSize = index + objectSize;\n\n        var _exports$readObject3 = exports.readObject(message, index, typeSchema, terminatingObjectSize),\n            _exports$readObject4 = _slicedToArray(_exports$readObject3, 2),\n            res = _exports$readObject4[0],\n            nextOffset = _exports$readObject4[1];\n\n        result.push(res);\n        index = nextOffset;\n      }\n\n      return [result, index];\n    }\n\n    throw new Error('Invalid container type');\n  }\n\n  if (typeSchema.schemaProp.dataType === 'string' || typeSchema.schemaProp.dataType === 'bytes') {\n    while (message[index] === startingByte && index !== terminateIndex) {\n      var _varint_1$readUInt13 = varint_1.readUInt32(message, index),\n          _varint_1$readUInt14 = _slicedToArray(_varint_1$readUInt13, 2),\n          _wire2KeySize = _varint_1$readUInt14[1];\n\n      index += _wire2KeySize;\n\n      var _varint_1$readUInt15 = varint_1.readUInt32(message, index),\n          _varint_1$readUInt16 = _slicedToArray(_varint_1$readUInt15, 2),\n          wireType2Length = _varint_1$readUInt16[0],\n          wireType2LengthSize = _varint_1$readUInt16[1];\n\n      if (wireType2Length === 0) {\n        if (typeSchema.schemaProp.dataType === 'string') {\n          result.push('');\n        } else {\n          result.push(Buffer.alloc(0));\n        }\n\n        index += wireType2LengthSize;\n        continue;\n      }\n\n      var _readers$typeSchema$s3 = _readers[typeSchema.schemaProp.dataType](message, index),\n          _readers$typeSchema$s4 = _slicedToArray(_readers$typeSchema$s3, 2),\n          _res = _readers$typeSchema$s4[0],\n          wire2Size = _readers$typeSchema$s4[1];\n\n      result.push(_res);\n      index += wire2Size;\n    }\n\n    return [result, index];\n  }\n\n  var _varint_1$readUInt17 = varint_1.readUInt32(message, index),\n      _varint_1$readUInt18 = _slicedToArray(_varint_1$readUInt17, 2),\n      keySize = _varint_1$readUInt18[1];\n\n  index += keySize;\n\n  var _varint_1$readUInt19 = varint_1.readUInt32(message, index),\n      _varint_1$readUInt20 = _slicedToArray(_varint_1$readUInt19, 2),\n      arrayLength = _varint_1$readUInt20[0],\n      wireType2Size = _varint_1$readUInt20[1];\n\n  index += wireType2Size;\n  var end = index + arrayLength;\n\n  while (index < end) {\n    var _readers$typeSchema$s5 = _readers[typeSchema.schemaProp.dataType](message, index),\n        _readers$typeSchema$s6 = _slicedToArray(_readers$typeSchema$s5, 2),\n        _res2 = _readers$typeSchema$s6[0],\n        size = _readers$typeSchema$s6[1];\n\n    result.push(_res2);\n    index += size;\n  }\n\n  return [result, index];\n};\n\nexports.readArray = readArray;\n\nvar writeArray = function writeArray(compiledSchema, message, chunks) {\n  if (message.length === 0) {\n    return [chunks, 0];\n  }\n\n  var totalSize = 0;\n\n  var _compiledSchema2 = _slicedToArray(compiledSchema, 2),\n      rootSchema = _compiledSchema2[0],\n      typeSchema = _compiledSchema2[1];\n\n  if (Array.isArray(typeSchema)) {\n    for (var i = 0; i < message.length; i += 1) {\n      var _exports$writeObject3 = exports.writeObject(typeSchema, message[i], []),\n          _exports$writeObject4 = _slicedToArray(_exports$writeObject3, 2),\n          res = _exports$writeObject4[0],\n          objectSize = _exports$writeObject4[1];\n\n      chunks.push(rootSchema.binaryKey);\n\n      var size = _writers.uint32(objectSize);\n\n      chunks.push(size);\n\n      for (var j = 0; j < res.length; j += 1) {\n        chunks.push(res[j]);\n      }\n\n      totalSize += objectSize + size.length + rootSchema.binaryKey.length;\n    }\n\n    return [chunks, totalSize];\n  }\n\n  if (typeSchema.schemaProp.dataType === 'string' || typeSchema.schemaProp.dataType === 'bytes') {\n    for (var _i = 0; _i < message.length; _i += 1) {\n      var _res3 = _writers[typeSchema.schemaProp.dataType](message[_i]);\n\n      chunks.push(rootSchema.binaryKey);\n      chunks.push(_res3);\n      totalSize += _res3.length + rootSchema.binaryKey.length;\n    }\n\n    return [chunks, totalSize];\n  }\n\n  chunks.push(rootSchema.binaryKey);\n  var contents = [];\n  var contentSize = 0;\n\n  for (var _i2 = 0; _i2 < message.length; _i2 += 1) {\n    var _res4 = _writers[typeSchema.schemaProp.dataType](message[_i2]);\n\n    contents.push(_res4);\n    contentSize += _res4.length;\n  }\n\n  var arrayLength = _writers.uint32(contentSize);\n\n  chunks.push(arrayLength);\n\n  for (var _i3 = 0; _i3 < contents.length; _i3 += 1) {\n    chunks.push(contents[_i3]);\n  }\n\n  totalSize += rootSchema.binaryKey.length + contentSize + arrayLength.length;\n  return [chunks, totalSize];\n};\n\nexports.writeArray = writeArray;","map":{"version":3,"sources":["../src/collection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeArray = exports.readArray = exports.readObject = exports.writeObject = void 0;\nconst varint_1 = require(\"./varint\");\nconst string_1 = require(\"./string\");\nconst bytes_1 = require(\"./bytes\");\nconst boolean_1 = require(\"./boolean\");\nconst keys_1 = require(\"./keys\");\nconst default_value_1 = require(\"./utils/default_value\");\nconst _readers = {\n    uint32: varint_1.readUInt32,\n    sint32: varint_1.readSInt32,\n    uint64: varint_1.readUInt64,\n    sint64: varint_1.readSInt64,\n    string: string_1.readString,\n    bytes: bytes_1.readBytes,\n    boolean: boolean_1.readBoolean,\n};\nconst _writers = {\n    uint32: varint_1.writeUInt32,\n    sint32: varint_1.writeSInt32,\n    uint64: varint_1.writeUInt64,\n    sint64: varint_1.writeSInt64,\n    string: string_1.writeString,\n    bytes: bytes_1.writeBytes,\n    boolean: boolean_1.writeBoolean,\n};\nconst writeObject = (compiledSchema, message, chunks) => {\n    let simpleObjectSize = 0;\n    for (let i = 0; i < compiledSchema.length; i += 1) {\n        const property = compiledSchema[i];\n        if (Array.isArray(property)) {\n            const headerProp = property[0];\n            if (headerProp.schemaProp.type === 'array') {\n                const [, size] = exports.writeArray(property, message[headerProp.propertyName], chunks);\n                simpleObjectSize += size;\n                continue;\n            }\n            chunks.push(headerProp.binaryKey);\n            const [encodedValues, totalWrittenSize] = exports.writeObject(property, message[headerProp.propertyName], []);\n            const objectSize = _writers.uint32(totalWrittenSize);\n            simpleObjectSize += objectSize.length + headerProp.binaryKey.length;\n            chunks.push(objectSize);\n            for (let e = 0; e < encodedValues.length; e += 1) {\n                simpleObjectSize += encodedValues[e].length;\n                chunks.push(encodedValues[e]);\n            }\n        }\n        else {\n            if (property.schemaProp.type === 'object') {\n                continue;\n            }\n            const value = message[property.propertyName];\n            if (value === undefined) {\n                continue;\n            }\n            const { schemaProp: { dataType }, binaryKey, } = property;\n            if (dataType === undefined) {\n                throw new Error('Compiled Schema is corrupted as \"dataType\" can not be undefined.');\n            }\n            const binaryValue = _writers[dataType](value);\n            chunks.push(binaryKey);\n            chunks.push(binaryValue);\n            simpleObjectSize += binaryKey.length + binaryValue.length;\n        }\n    }\n    return [chunks, simpleObjectSize];\n};\nexports.writeObject = writeObject;\nconst readObject = (message, offset, compiledSchema, terminateIndex) => {\n    let index = offset;\n    const result = {};\n    for (let i = 0; i < compiledSchema.length; i += 1) {\n        const typeSchema = compiledSchema[i];\n        if (Array.isArray(typeSchema)) {\n            if (typeSchema[0].schemaProp.type === 'array') {\n                if (index >= terminateIndex) {\n                    result[typeSchema[0].propertyName] = [];\n                    continue;\n                }\n                const [arr, nextOffset] = exports.readArray(message, index, typeSchema, terminateIndex);\n                result[typeSchema[0].propertyName] = arr;\n                index = nextOffset;\n            }\n            else if (typeSchema[0].schemaProp.type === 'object') {\n                const [, keySize] = varint_1.readUInt32(message, index);\n                index += keySize;\n                const [objectSize, objectSizeLength] = varint_1.readUInt32(message, index);\n                index += objectSizeLength;\n                const [obj, nextOffset] = exports.readObject(message, index, typeSchema, objectSize + index);\n                result[typeSchema[0].propertyName] = obj;\n                index = nextOffset;\n            }\n            else {\n                throw new Error('Invalid container type');\n            }\n            continue;\n        }\n        if (typeSchema.schemaProp.type === 'object' || typeSchema.schemaProp.type === 'array') {\n            continue;\n        }\n        if (message.length <= index) {\n            result[typeSchema.propertyName] = default_value_1.getDefaultValue(typeSchema.schemaProp.dataType);\n            continue;\n        }\n        const [key, keySize] = varint_1.readUInt32(message, index);\n        const [fieldNumber] = keys_1.readKey(key);\n        if (fieldNumber !== typeSchema.schemaProp.fieldNumber) {\n            result[typeSchema.propertyName] = default_value_1.getDefaultValue(typeSchema.schemaProp.dataType);\n            continue;\n        }\n        index += keySize;\n        const [scalarValue, scalarSize] = _readers[typeSchema.schemaProp.dataType](message, index);\n        index += scalarSize;\n        result[typeSchema.propertyName] = scalarValue;\n    }\n    return [result, index];\n};\nexports.readObject = readObject;\nconst readArray = (message, offset, compiledSchema, terminateIndex) => {\n    let index = offset;\n    if (index >= message.length) {\n        return [[], index];\n    }\n    const startingByte = message[index];\n    const [rootSchema, typeSchema] = compiledSchema;\n    const [key] = varint_1.readUInt32(message, index);\n    const [fieldNumber] = keys_1.readKey(key);\n    if (fieldNumber !== rootSchema.schemaProp.fieldNumber) {\n        return [[], index];\n    }\n    const result = [];\n    if (Array.isArray(typeSchema)) {\n        const [nestedTypeSchema] = typeSchema;\n        if (nestedTypeSchema.schemaProp.type === 'object') {\n            while (message[index] === startingByte && index !== terminateIndex) {\n                const [, wire2KeySize] = varint_1.readUInt32(message, index);\n                index += wire2KeySize;\n                const [objectSize, objectSizeLength] = varint_1.readUInt32(message, index);\n                index += objectSizeLength;\n                if (objectSize === 0) {\n                    continue;\n                }\n                const terminatingObjectSize = index + objectSize;\n                const [res, nextOffset] = exports.readObject(message, index, typeSchema, terminatingObjectSize);\n                result.push(res);\n                index = nextOffset;\n            }\n            return [result, index];\n        }\n        throw new Error('Invalid container type');\n    }\n    if (typeSchema.schemaProp.dataType === 'string' || typeSchema.schemaProp.dataType === 'bytes') {\n        while (message[index] === startingByte && index !== terminateIndex) {\n            const [, wire2KeySize] = varint_1.readUInt32(message, index);\n            index += wire2KeySize;\n            const [wireType2Length, wireType2LengthSize] = varint_1.readUInt32(message, index);\n            if (wireType2Length === 0) {\n                if (typeSchema.schemaProp.dataType === 'string') {\n                    result.push('');\n                }\n                else {\n                    result.push(Buffer.alloc(0));\n                }\n                index += wireType2LengthSize;\n                continue;\n            }\n            const [res, wire2Size] = _readers[typeSchema.schemaProp.dataType](message, index);\n            result.push(res);\n            index += wire2Size;\n        }\n        return [result, index];\n    }\n    const [, keySize] = varint_1.readUInt32(message, index);\n    index += keySize;\n    const [arrayLength, wireType2Size] = varint_1.readUInt32(message, index);\n    index += wireType2Size;\n    const end = index + arrayLength;\n    while (index < end) {\n        const [res, size] = _readers[typeSchema.schemaProp.dataType](message, index);\n        result.push(res);\n        index += size;\n    }\n    return [result, index];\n};\nexports.readArray = readArray;\nconst writeArray = (compiledSchema, message, chunks) => {\n    if (message.length === 0) {\n        return [chunks, 0];\n    }\n    let totalSize = 0;\n    const [rootSchema, typeSchema] = compiledSchema;\n    if (Array.isArray(typeSchema)) {\n        for (let i = 0; i < message.length; i += 1) {\n            const [res, objectSize] = exports.writeObject(typeSchema, message[i], []);\n            chunks.push(rootSchema.binaryKey);\n            const size = _writers.uint32(objectSize);\n            chunks.push(size);\n            for (let j = 0; j < res.length; j += 1) {\n                chunks.push(res[j]);\n            }\n            totalSize += objectSize + size.length + rootSchema.binaryKey.length;\n        }\n        return [chunks, totalSize];\n    }\n    if (typeSchema.schemaProp.dataType === 'string' || typeSchema.schemaProp.dataType === 'bytes') {\n        for (let i = 0; i < message.length; i += 1) {\n            const res = _writers[typeSchema.schemaProp.dataType](message[i]);\n            chunks.push(rootSchema.binaryKey);\n            chunks.push(res);\n            totalSize += res.length + rootSchema.binaryKey.length;\n        }\n        return [chunks, totalSize];\n    }\n    chunks.push(rootSchema.binaryKey);\n    const contents = [];\n    let contentSize = 0;\n    for (let i = 0; i < message.length; i += 1) {\n        const res = _writers[typeSchema.schemaProp.dataType](message[i]);\n        contents.push(res);\n        contentSize += res.length;\n    }\n    const arrayLength = _writers.uint32(contentSize);\n    chunks.push(arrayLength);\n    for (let i = 0; i < contents.length; i += 1) {\n        chunks.push(contents[i]);\n    }\n    totalSize += rootSchema.binaryKey.length + contentSize + arrayLength.length;\n    return [chunks, totalSize];\n};\nexports.writeArray = writeArray;\n//# sourceMappingURL=collection.js.map"]},"metadata":{},"sourceType":"script"}