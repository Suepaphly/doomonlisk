{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateRandomSeeds = exports.findPreviousHeaderOfDelegate = void 0;\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar NUMBER_BYTE_SIZE = 4;\nvar RANDOM_SEED_BYTE_SIZE = 16;\n\nvar strippedHash = function strippedHash(data) {\n  if (!(data instanceof Buffer)) {\n    throw new Error('Hash input is not a valid type');\n  }\n\n  return lisk_cryptography_1.hash(data).slice(0, RANDOM_SEED_BYTE_SIZE);\n};\n\nvar bitwiseXOR = function bitwiseXOR(bufferArray) {\n  if (bufferArray.length === 1) {\n    return bufferArray[0];\n  }\n\n  var bufferSizes = new Set(bufferArray.map(function (buffer) {\n    return buffer.length;\n  }));\n\n  if (bufferSizes.size > 1) {\n    throw new Error('All input for XOR should be same size');\n  }\n\n  var outputSize = _toConsumableArray(bufferSizes)[0];\n\n  var result = Buffer.alloc(outputSize, 0);\n\n  var _loop = function _loop(i) {\n    result[i] = bufferArray.map(function (b) {\n      return b[i];\n    }).reduce(function (a, b) {\n      return a ^ b;\n    }, 0);\n  };\n\n  for (var i = 0; i < outputSize; i += 1) {\n    _loop(i);\n  }\n\n  return result;\n};\n\nvar findPreviousHeaderOfDelegate = function findPreviousHeaderOfDelegate(header, searchTillHeight, headersMap) {\n  var height = header.height,\n      generatorPublicKey = header.generatorPublicKey;\n  var searchTill = Math.max(searchTillHeight, 1);\n\n  for (var i = height - 1; i >= searchTill; i -= 1) {\n    var foundHeader = headersMap[i];\n\n    if (!foundHeader) {\n      return undefined;\n    }\n\n    if (headersMap[i].generatorPublicKey.equals(generatorPublicKey)) {\n      return headersMap[i];\n    }\n  }\n\n  return undefined;\n};\n\nexports.findPreviousHeaderOfDelegate = findPreviousHeaderOfDelegate;\n\nvar isValidSeedReveal = function isValidSeedReveal(seedReveal, previousSeedReveal) {\n  return strippedHash(seedReveal).equals(previousSeedReveal);\n};\n\nvar selectSeedReveals = function selectSeedReveals(_ref) {\n  var fromHeight = _ref.fromHeight,\n      toHeight = _ref.toHeight,\n      headersMap = _ref.headersMap,\n      rounds = _ref.rounds;\n  var selected = [];\n\n  for (var i = fromHeight; i >= toHeight; i -= 1) {\n    var header = headersMap[i];\n\n    if (!header) {\n      continue;\n    }\n\n    var blockRound = rounds.calcRound(header.height);\n    var lastForgedBlock = exports.findPreviousHeaderOfDelegate(header, rounds.calcRoundStartHeight(blockRound - 1), headersMap);\n\n    if (!lastForgedBlock) {\n      continue;\n    }\n\n    if (!isValidSeedReveal(header.asset.seedReveal, lastForgedBlock.asset.seedReveal)) {\n      continue;\n    }\n\n    selected.push(header.asset.seedReveal);\n  }\n\n  return selected;\n};\n\nvar generateRandomSeeds = function generateRandomSeeds(_ref2) {\n  var round = _ref2.round,\n      rounds = _ref2.rounds,\n      headers = _ref2.headers,\n      logger = _ref2.logger;\n  var middleThreshold = Math.floor(rounds.blocksPerRound / 2);\n  var startOfRound = rounds.calcRoundStartHeight(round);\n  var middleOfRound = rounds.calcRoundMiddleHeight(round);\n  var startOfLastRound = rounds.calcRoundStartHeight(round - 1);\n  var endOfLastRound = rounds.calcRoundEndHeight(round - 1);\n  var startOfSecondLastRound = rounds.calcRoundStartHeight(round - 2);\n  var headersMap = headers.reduce(function (acc, header) {\n    if (header.height >= startOfSecondLastRound && header.height <= middleOfRound) {\n      acc[header.height] = header;\n    }\n\n    return acc;\n  }, {});\n  logger.debug({\n    fromHeight: startOfRound + middleThreshold,\n    toHeight: startOfRound - middleThreshold\n  }, 'Fetching seed reveals for random seed 1');\n  var seedRevealsForRandomSeed1 = selectSeedReveals({\n    fromHeight: startOfRound + middleThreshold,\n    toHeight: startOfRound - middleThreshold,\n    headersMap: headersMap,\n    rounds: rounds\n  });\n  logger.debug({\n    fromHeight: endOfLastRound,\n    toHeight: startOfLastRound\n  }, 'Fetching seed reveals for random seed 2');\n  var seedRevealsForRandomSeed2 = selectSeedReveals({\n    fromHeight: endOfLastRound,\n    toHeight: startOfLastRound,\n    headersMap: headersMap,\n    rounds: rounds\n  });\n  var randomSeed1 = bitwiseXOR([strippedHash(lisk_cryptography_1.intToBuffer(startOfRound + middleThreshold, NUMBER_BYTE_SIZE))].concat(_toConsumableArray(seedRevealsForRandomSeed1)));\n  var randomSeed2 = bitwiseXOR([strippedHash(lisk_cryptography_1.intToBuffer(endOfLastRound, NUMBER_BYTE_SIZE))].concat(_toConsumableArray(seedRevealsForRandomSeed2)));\n  return [randomSeed1, randomSeed2];\n};\n\nexports.generateRandomSeeds = generateRandomSeeds;","map":{"version":3,"sources":["../../../src/modules/dpos/random_seed.ts"],"names":[],"mappings":";;;;;;;;;AAeA,IAAA,mBAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AAUA,IAAM,gBAAgB,GAAG,CAAzB;AACA,IAAM,qBAAqB,GAAG,EAA9B;;AAEA,IAAM,YAAY,GAAG,SAAf,YAAe,CAAC,IAAD,EAAyB;AAC7C,MAAI,EAAE,IAAI,YAAY,MAAlB,CAAJ,EAA+B;AAC9B,UAAM,IAAI,KAAJ,CAAU,gCAAV,CAAN;AACA;;AAED,SAAO,mBAAA,CAAA,IAAA,CAAK,IAAL,EAAW,KAAX,CAAiB,CAAjB,EAAoB,qBAApB,CAAP;AACA,CAND;;AAQA,IAAM,UAAU,GAAG,SAAb,UAAa,CAAC,WAAD,EAAkC;AACpD,MAAI,WAAW,CAAC,MAAZ,KAAuB,CAA3B,EAA8B;AAC7B,WAAO,WAAW,CAAC,CAAD,CAAlB;AACA;;AAED,MAAM,WAAW,GAAG,IAAI,GAAJ,CAAQ,WAAW,CAAC,GAAZ,CAAgB,UAAA,MAAM;AAAA,WAAI,MAAM,CAAC,MAAX;AAAA,GAAtB,CAAR,CAApB;;AACA,MAAI,WAAW,CAAC,IAAZ,GAAmB,CAAvB,EAA0B;AACzB,UAAM,IAAI,KAAJ,CAAU,uCAAV,CAAN;AACA;;AACD,MAAM,UAAU,GAAG,mBAAI,WAAJ,EAAiB,CAAjB,CAAnB;;AACA,MAAM,MAAM,GAAG,MAAM,CAAC,KAAP,CAAa,UAAb,EAAyB,CAAzB,CAAf;;AAVoD,6BAY3C,CAZ2C;AAcnD,IAAA,MAAM,CAAC,CAAD,CAAN,GAAY,WAAW,CAAC,GAAZ,CAAgB,UAAA,CAAC;AAAA,aAAI,CAAC,CAAC,CAAD,CAAL;AAAA,KAAjB,EAA2B,MAA3B,CAAkC,UAAC,CAAD,EAAI,CAAJ;AAAA,aAAU,CAAC,GAAG,CAAd;AAAA,KAAlC,EAAmD,CAAnD,CAAZ;AAdmD;;AAYpD,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAApB,EAAgC,CAAC,IAAI,CAArC,EAAwC;AAAA,UAA/B,CAA+B;AAGvC;;AAED,SAAO,MAAP;AACA,CAlBD;;AAoBO,IAAM,4BAA4B,GAAG,SAA/B,4BAA+B,CAC3C,MAD2C,EAE3C,gBAF2C,EAG3C,UAH2C,EAIf;AAC5B,MAAQ,MAAR,GAAuC,MAAvC,CAAQ,MAAR;AAAA,MAAgB,kBAAhB,GAAuC,MAAvC,CAAgB,kBAAhB;AACA,MAAM,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,gBAAT,EAA2B,CAA3B,CAAnB;;AAEA,OAAK,IAAI,CAAC,GAAG,MAAM,GAAG,CAAtB,EAAyB,CAAC,IAAI,UAA9B,EAA0C,CAAC,IAAI,CAA/C,EAAkD;AACjD,QAAM,WAAW,GAAG,UAAU,CAAC,CAAD,CAA9B;;AACA,QAAI,CAAC,WAAL,EAAkB;AACjB,aAAO,SAAP;AACA;;AACD,QAAI,UAAU,CAAC,CAAD,CAAV,CAAc,kBAAd,CAAiC,MAAjC,CAAwC,kBAAxC,CAAJ,EAAiE;AAChE,aAAO,UAAU,CAAC,CAAD,CAAjB;AACA;AACD;;AAED,SAAO,SAAP;AACA,CAnBM;;AAAM,OAAA,CAAA,4BAAA,GAA4B,4BAA5B;;AAqBb,IAAM,iBAAiB,GAAG,SAApB,iBAAoB,CAAC,UAAD,EAAqB,kBAArB;AAAA,SACzB,YAAY,CAAC,UAAD,CAAZ,CAAyB,MAAzB,CAAgC,kBAAhC,CADyB;AAAA,CAA1B;;AAGA,IAAM,iBAAiB,GAAG,SAApB,iBAAoB,OAUX;AAAA,MATd,UASc,QATd,UASc;AAAA,MARd,QAQc,QARd,QAQc;AAAA,MAPd,UAOc,QAPd,UAOc;AAAA,MANd,MAMc,QANd,MAMc;AACd,MAAM,QAAQ,GAAG,EAAjB;;AAEA,OAAK,IAAI,CAAC,GAAG,UAAb,EAAyB,CAAC,IAAI,QAA9B,EAAwC,CAAC,IAAI,CAA7C,EAAgD;AAC/C,QAAM,MAAM,GAAG,UAAU,CAAC,CAAD,CAAzB;;AAGA,QAAI,CAAC,MAAL,EAAa;AACZ;AACA;;AACD,QAAM,UAAU,GAAG,MAAM,CAAC,SAAP,CAAiB,MAAM,CAAC,MAAxB,CAAnB;AAEA,QAAM,eAAe,GAAG,OAAA,CAAA,4BAAA,CACvB,MADuB,EAEvB,MAAM,CAAC,oBAAP,CAA4B,UAAU,GAAG,CAAzC,CAFuB,EAGvB,UAHuB,CAAxB;;AAOA,QAAI,CAAC,eAAL,EAAsB;AACrB;AACA;;AAID,QAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,KAAP,CAAa,UAAd,EAA0B,eAAe,CAAC,KAAhB,CAAsB,UAAhD,CAAtB,EAAmF;AAClF;AACA;;AAED,IAAA,QAAQ,CAAC,IAAT,CAAc,MAAM,CAAC,KAAP,CAAa,UAA3B;AACA;;AAED,SAAO,QAAP;AACA,CA3CD;;AA6CO,IAAM,mBAAmB,GAAG,SAAtB,mBAAsB,QAUG;AAAA,MATrC,KASqC,SATrC,KASqC;AAAA,MARrC,MAQqC,SARrC,MAQqC;AAAA,MAPrC,OAOqC,SAPrC,OAOqC;AAAA,MANrC,MAMqC,SANrC,MAMqC;AAErC,MAAM,eAAe,GAAG,IAAI,CAAC,KAAL,CAAW,MAAM,CAAC,cAAP,GAAwB,CAAnC,CAAxB;AACA,MAAM,YAAY,GAAG,MAAM,CAAC,oBAAP,CAA4B,KAA5B,CAArB;AACA,MAAM,aAAa,GAAG,MAAM,CAAC,qBAAP,CAA6B,KAA7B,CAAtB;AACA,MAAM,gBAAgB,GAAG,MAAM,CAAC,oBAAP,CAA4B,KAAK,GAAG,CAApC,CAAzB;AACA,MAAM,cAAc,GAAG,MAAM,CAAC,kBAAP,CAA0B,KAAK,GAAG,CAAlC,CAAvB;AACA,MAAM,sBAAsB,GAAG,MAAM,CAAC,oBAAP,CAA4B,KAAK,GAAG,CAApC,CAA/B;AAOA,MAAM,UAAU,GAAG,OAAO,CAAC,MAAR,CAAe,UAAC,GAAD,EAAkB,MAAlB,EAAqD;AACtF,QAAI,MAAM,CAAC,MAAP,IAAiB,sBAAjB,IAA2C,MAAM,CAAC,MAAP,IAAiB,aAAhE,EAA+E;AAC9E,MAAA,GAAG,CAAC,MAAM,CAAC,MAAR,CAAH,GAAqB,MAArB;AACA;;AAED,WAAO,GAAP;AACA,GANkB,EAMhB,EANgB,CAAnB;AASA,EAAA,MAAM,CAAC,KAAP,CACC;AACC,IAAA,UAAU,EAAE,YAAY,GAAG,eAD5B;AAEC,IAAA,QAAQ,EAAE,YAAY,GAAG;AAF1B,GADD,EAKC,yCALD;AAOA,MAAM,yBAAyB,GAAG,iBAAiB,CAAC;AACnD,IAAA,UAAU,EAAE,YAAY,GAAG,eADwB;AAEnD,IAAA,QAAQ,EAAE,YAAY,GAAG,eAF0B;AAGnD,IAAA,UAAU,EAAV,UAHmD;AAInD,IAAA,MAAM,EAAN;AAJmD,GAAD,CAAnD;AAQA,EAAA,MAAM,CAAC,KAAP,CACC;AACC,IAAA,UAAU,EAAE,cADb;AAEC,IAAA,QAAQ,EAAE;AAFX,GADD,EAKC,yCALD;AAOA,MAAM,yBAAyB,GAAG,iBAAiB,CAAC;AACnD,IAAA,UAAU,EAAE,cADuC;AAEnD,IAAA,QAAQ,EAAE,gBAFyC;AAGnD,IAAA,UAAU,EAAV,UAHmD;AAInD,IAAA,MAAM,EAAN;AAJmD,GAAD,CAAnD;AAOA,MAAM,WAAW,GAAG,UAAU,EAC7B,YAAY,CAAC,mBAAA,CAAA,WAAA,CAAY,YAAY,GAAG,eAA3B,EAA4C,gBAA5C,CAAD,CADiB,4BAE1B,yBAF0B,GAA9B;AAIA,MAAM,WAAW,GAAG,UAAU,EAC7B,YAAY,CAAC,mBAAA,CAAA,WAAA,CAAY,cAAZ,EAA4B,gBAA5B,CAAD,CADiB,4BAE1B,yBAF0B,GAA9B;AAKA,SAAO,CAAC,WAAD,EAAc,WAAd,CAAP;AACA,CAxEM;;AAAM,OAAA,CAAA,mBAAA,GAAmB,mBAAnB","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateRandomSeeds = exports.findPreviousHeaderOfDelegate = void 0;\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst NUMBER_BYTE_SIZE = 4;\nconst RANDOM_SEED_BYTE_SIZE = 16;\nconst strippedHash = (data) => {\n    if (!(data instanceof Buffer)) {\n        throw new Error('Hash input is not a valid type');\n    }\n    return lisk_cryptography_1.hash(data).slice(0, RANDOM_SEED_BYTE_SIZE);\n};\nconst bitwiseXOR = (bufferArray) => {\n    if (bufferArray.length === 1) {\n        return bufferArray[0];\n    }\n    const bufferSizes = new Set(bufferArray.map(buffer => buffer.length));\n    if (bufferSizes.size > 1) {\n        throw new Error('All input for XOR should be same size');\n    }\n    const outputSize = [...bufferSizes][0];\n    const result = Buffer.alloc(outputSize, 0);\n    for (let i = 0; i < outputSize; i += 1) {\n        result[i] = bufferArray.map(b => b[i]).reduce((a, b) => a ^ b, 0);\n    }\n    return result;\n};\nconst findPreviousHeaderOfDelegate = (header, searchTillHeight, headersMap) => {\n    const { height, generatorPublicKey } = header;\n    const searchTill = Math.max(searchTillHeight, 1);\n    for (let i = height - 1; i >= searchTill; i -= 1) {\n        const foundHeader = headersMap[i];\n        if (!foundHeader) {\n            return undefined;\n        }\n        if (headersMap[i].generatorPublicKey.equals(generatorPublicKey)) {\n            return headersMap[i];\n        }\n    }\n    return undefined;\n};\nexports.findPreviousHeaderOfDelegate = findPreviousHeaderOfDelegate;\nconst isValidSeedReveal = (seedReveal, previousSeedReveal) => strippedHash(seedReveal).equals(previousSeedReveal);\nconst selectSeedReveals = ({ fromHeight, toHeight, headersMap, rounds, }) => {\n    const selected = [];\n    for (let i = fromHeight; i >= toHeight; i -= 1) {\n        const header = headersMap[i];\n        if (!header) {\n            continue;\n        }\n        const blockRound = rounds.calcRound(header.height);\n        const lastForgedBlock = exports.findPreviousHeaderOfDelegate(header, rounds.calcRoundStartHeight(blockRound - 1), headersMap);\n        if (!lastForgedBlock) {\n            continue;\n        }\n        if (!isValidSeedReveal(header.asset.seedReveal, lastForgedBlock.asset.seedReveal)) {\n            continue;\n        }\n        selected.push(header.asset.seedReveal);\n    }\n    return selected;\n};\nconst generateRandomSeeds = ({ round, rounds, headers, logger, }) => {\n    const middleThreshold = Math.floor(rounds.blocksPerRound / 2);\n    const startOfRound = rounds.calcRoundStartHeight(round);\n    const middleOfRound = rounds.calcRoundMiddleHeight(round);\n    const startOfLastRound = rounds.calcRoundStartHeight(round - 1);\n    const endOfLastRound = rounds.calcRoundEndHeight(round - 1);\n    const startOfSecondLastRound = rounds.calcRoundStartHeight(round - 2);\n    const headersMap = headers.reduce((acc, header) => {\n        if (header.height >= startOfSecondLastRound && header.height <= middleOfRound) {\n            acc[header.height] = header;\n        }\n        return acc;\n    }, {});\n    logger.debug({\n        fromHeight: startOfRound + middleThreshold,\n        toHeight: startOfRound - middleThreshold,\n    }, 'Fetching seed reveals for random seed 1');\n    const seedRevealsForRandomSeed1 = selectSeedReveals({\n        fromHeight: startOfRound + middleThreshold,\n        toHeight: startOfRound - middleThreshold,\n        headersMap,\n        rounds,\n    });\n    logger.debug({\n        fromHeight: endOfLastRound,\n        toHeight: startOfLastRound,\n    }, 'Fetching seed reveals for random seed 2');\n    const seedRevealsForRandomSeed2 = selectSeedReveals({\n        fromHeight: endOfLastRound,\n        toHeight: startOfLastRound,\n        headersMap,\n        rounds,\n    });\n    const randomSeed1 = bitwiseXOR([\n        strippedHash(lisk_cryptography_1.intToBuffer(startOfRound + middleThreshold, NUMBER_BYTE_SIZE)),\n        ...seedRevealsForRandomSeed1,\n    ]);\n    const randomSeed2 = bitwiseXOR([\n        strippedHash(lisk_cryptography_1.intToBuffer(endOfLastRound, NUMBER_BYTE_SIZE)),\n        ...seedRevealsForRandomSeed2,\n    ]);\n    return [randomSeed1, randomSeed2];\n};\nexports.generateRandomSeeds = generateRandomSeeds;\n//# sourceMappingURL=random_seed.js.map"]},"metadata":{},"sourceType":"script"}