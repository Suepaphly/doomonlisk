{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _objectWithoutProperties = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _excluded = [\"asset\"],\n    _excluded2 = [\"asset\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Transaction = void 0;\n\nvar lisk_transactions_1 = require(\"@liskhq/lisk-transactions\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar codec_1 = require(\"./codec\");\n\nvar Transaction = /*#__PURE__*/function () {\n  function Transaction(channel, registeredSchema, nodeInfo) {\n    _classCallCheck(this, Transaction);\n\n    this._channel = channel;\n    this._schema = registeredSchema;\n    this._nodeInfo = nodeInfo;\n  }\n\n  _createClass(Transaction, [{\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(input, passphrase, options) {\n        var _a, txInput, networkIdentifier, _lisk_cryptography_1$, publicKey, address, accountHex, account, registeredModule, _registeredModule, registeredAsset, assetSchema;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                txInput = input;\n                networkIdentifier = Buffer.from(this._nodeInfo.networkIdentifier, 'hex');\n                _lisk_cryptography_1$ = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase), publicKey = _lisk_cryptography_1$.publicKey, address = _lisk_cryptography_1$.address;\n                _context.next = 5;\n                return this._channel.invoke('app:getAccount', {\n                  address: address.toString('hex')\n                });\n\n              case 5:\n                accountHex = _context.sent;\n                account = codec_1.decodeAccount(Buffer.from(accountHex, 'hex'), this._schema);\n\n                if (txInput.moduleID) {\n                  _context.next = 14;\n                  break;\n                }\n\n                if (txInput.moduleName) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new Error('Missing moduleID and moduleName');\n\n              case 10:\n                registeredModule = this._nodeInfo.registeredModules.find(function (module) {\n                  return module.name === input.moduleName;\n                });\n\n                if (registeredModule) {\n                  _context.next = 13;\n                  break;\n                }\n\n                throw new Error(\"Module corresponding to name \".concat(txInput.moduleName, \" not registered.\"));\n\n              case 13:\n                txInput.moduleID = registeredModule.id;\n\n              case 14:\n                if (!(typeof txInput.assetID !== 'number')) {\n                  _context.next = 24;\n                  break;\n                }\n\n                if (txInput.assetName) {\n                  _context.next = 17;\n                  break;\n                }\n\n                throw new Error('Missing assetID and assetName');\n\n              case 17:\n                _registeredModule = this._nodeInfo.registeredModules.find(function (m) {\n                  return m.id === txInput.moduleID;\n                });\n\n                if (_registeredModule) {\n                  _context.next = 20;\n                  break;\n                }\n\n                throw new Error(\"Module corresponding to id \".concat(txInput.moduleID, \" not registered.\"));\n\n              case 20:\n                registeredAsset = _registeredModule.transactionAssets.find(function (asset) {\n                  return asset.name === txInput.assetName;\n                });\n\n                if (registeredAsset) {\n                  _context.next = 23;\n                  break;\n                }\n\n                throw new Error(\"Asset corresponding to name \".concat(txInput.assetName, \" not registered.\"));\n\n              case 23:\n                txInput.assetID = registeredAsset.id;\n\n              case 24:\n                if (!(typeof txInput.nonce !== 'bigint')) {\n                  _context.next = 28;\n                  break;\n                }\n\n                if (!(typeof account.sequence !== 'object' || typeof account.sequence.nonce !== 'bigint')) {\n                  _context.next = 27;\n                  break;\n                }\n\n                throw new Error('Unsupported account type');\n\n              case 27:\n                txInput.nonce = account.sequence.nonce;\n\n              case 28:\n                if (!(txInput.nonce < BigInt(0))) {\n                  _context.next = 30;\n                  break;\n                }\n\n                throw new Error('Nonce must be greater or equal to zero');\n\n              case 30:\n                if (!txInput.senderPublicKey) {\n                  txInput.senderPublicKey = publicKey;\n                }\n\n                txInput.signatures = (_a = txInput.signatures) !== null && _a !== void 0 ? _a : [];\n                assetSchema = codec_1.getTransactionAssetSchema(txInput, this._schema);\n\n                if (!(account.keys && account.keys.numberOfSignatures > 0)) {\n                  _context.next = 35;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", lisk_transactions_1.signMultiSignatureTransaction(assetSchema, txInput, networkIdentifier, passphrase, account.keys, options === null || options === void 0 ? void 0 : options.includeSenderSignature));\n\n              case 35:\n                if (!((options === null || options === void 0 ? void 0 : options.multisignatureKeys) && (options === null || options === void 0 ? void 0 : options.includeSenderSignature))) {\n                  _context.next = 37;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", lisk_transactions_1.signMultiSignatureTransaction(assetSchema, txInput, networkIdentifier, passphrase, options.multisignatureKeys, options.includeSenderSignature));\n\n              case 37:\n                return _context.abrupt(\"return\", lisk_transactions_1.signTransaction(assetSchema, txInput, networkIdentifier, passphrase));\n\n              case 38:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function create(_x, _x2, _x3) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(id) {\n        var idString, transactionHex;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                idString = Buffer.isBuffer(id) ? id.toString('hex') : id;\n                _context2.next = 3;\n                return this._channel.invoke('app:getTransactionByID', {\n                  id: idString\n                });\n\n              case 3:\n                transactionHex = _context2.sent;\n                return _context2.abrupt(\"return\", codec_1.decodeTransaction(Buffer.from(transactionHex, 'hex'), this._schema));\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function get(_x4) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"getFromPool\",\n    value: function () {\n      var _getFromPool = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var transactionsHex, decodedTransactions, _iterator, _step, transactionHex;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._channel.invoke('app:getTransactionsFromPool');\n\n              case 2:\n                transactionsHex = _context3.sent;\n                decodedTransactions = [];\n                _iterator = _createForOfIteratorHelper(transactionsHex);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    transactionHex = _step.value;\n                    decodedTransactions.push(codec_1.decodeTransaction(Buffer.from(transactionHex, 'hex'), this._schema));\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                return _context3.abrupt(\"return\", decodedTransactions);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getFromPool() {\n        return _getFromPool.apply(this, arguments);\n      }\n\n      return getFromPool;\n    }()\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(transaction, passphrases, options) {\n        var assetSchema, networkIdentifier, address, accountHex, account, _iterator2, _step2, passphrase, _iterator3, _step3, _passphrase;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                assetSchema = codec_1.getTransactionAssetSchema(transaction, this._schema);\n                networkIdentifier = Buffer.from(this._nodeInfo.networkIdentifier, 'hex');\n                address = lisk_cryptography_1.getAddressFromPublicKey(transaction.senderPublicKey);\n                _context4.next = 5;\n                return this._channel.invoke('app:getAccount', {\n                  address: address.toString('hex')\n                });\n\n              case 5:\n                accountHex = _context4.sent;\n                account = codec_1.decodeAccount(Buffer.from(accountHex, 'hex'), this._schema);\n\n                if (!(account.keys && account.keys.numberOfSignatures > 0)) {\n                  _context4.next = 11;\n                  break;\n                }\n\n                _iterator2 = _createForOfIteratorHelper(passphrases);\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    passphrase = _step2.value;\n                    lisk_transactions_1.signMultiSignatureTransaction(assetSchema, transaction, networkIdentifier, passphrase, account.keys, options === null || options === void 0 ? void 0 : options.includeSenderSignature);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                return _context4.abrupt(\"return\", transaction);\n\n              case 11:\n                if (!((options === null || options === void 0 ? void 0 : options.multisignatureKeys) && (options === null || options === void 0 ? void 0 : options.includeSenderSignature))) {\n                  _context4.next = 15;\n                  break;\n                }\n\n                _iterator3 = _createForOfIteratorHelper(passphrases);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    _passphrase = _step3.value;\n                    lisk_transactions_1.signMultiSignatureTransaction(assetSchema, transaction, networkIdentifier, _passphrase, options.multisignatureKeys, options.includeSenderSignature);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                return _context4.abrupt(\"return\", transaction);\n\n              case 15:\n                return _context4.abrupt(\"return\", lisk_transactions_1.signTransaction(assetSchema, transaction, networkIdentifier, passphrases[0]));\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function sign(_x5, _x6, _x7) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(transaction) {\n        var encodedTx;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                encodedTx = codec_1.encodeTransaction(transaction, this._schema);\n                return _context5.abrupt(\"return\", this._channel.invoke('app:postTransaction', {\n                  transaction: encodedTx.toString('hex')\n                }));\n\n              case 2:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function send(_x8) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"decode\",\n    value: function decode(transaction) {\n      var transactionBuffer = Buffer.isBuffer(transaction) ? transaction : Buffer.from(transaction, 'hex');\n      return codec_1.decodeTransaction(transactionBuffer, this._schema);\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(transaction) {\n      return codec_1.encodeTransaction(transaction, this._schema);\n    }\n  }, {\n    key: \"computeMinFee\",\n    value: function computeMinFee(transaction) {\n      var assetSchema = codec_1.getTransactionAssetSchema(transaction, this._schema);\n      var numberOfSignatures = transaction.signatures ? transaction.signatures.length : 1;\n      var options = {\n        minFeePerByte: this._nodeInfo.genesisConfig.minFeePerByte,\n        baseFees: this._nodeInfo.genesisConfig.baseFees,\n        numberOfSignatures: numberOfSignatures\n      };\n      return lisk_transactions_1.computeMinFee(assetSchema, transaction, options);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(transaction) {\n      var txAsset = transaction.asset,\n          txRoot = _objectWithoutProperties(transaction, _excluded);\n\n      var tmpId = txRoot.id;\n      delete txRoot.id;\n      var schemaAsset = codec_1.getTransactionAssetSchema(txRoot, this._schema);\n      var jsonTxAsset = lisk_codec_1.codec.toJSON(schemaAsset, txAsset);\n      var jsonTxRoot = lisk_codec_1.codec.toJSON(this._schema.transaction, txRoot);\n\n      var jsonTx = _objectSpread(_objectSpread({}, jsonTxRoot), {}, {\n        asset: jsonTxAsset,\n        id: Buffer.isBuffer(tmpId) ? tmpId.toString('hex') : tmpId\n      });\n\n      return jsonTx;\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(transaction) {\n      var txAsset = transaction.asset,\n          txRoot = _objectWithoutProperties(transaction, _excluded2);\n\n      var tmpId = txRoot.id;\n      delete txRoot.id;\n      var schemaAsset = codec_1.getTransactionAssetSchema(txRoot, this._schema);\n      var txAssetObject = lisk_codec_1.codec.fromJSON(schemaAsset, txAsset);\n      var txRootObject = lisk_codec_1.codec.fromJSON(this._schema.transaction, txRoot);\n\n      var txObject = _objectSpread(_objectSpread({}, txRootObject), {}, {\n        asset: txAssetObject,\n        id: typeof tmpId === 'string' ? Buffer.from(tmpId, 'hex') : Buffer.alloc(0)\n      });\n\n      return txObject;\n    }\n  }]);\n\n  return Transaction;\n}();\n\nexports.Transaction = Transaction;","map":{"version":3,"sources":["../src/transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Transaction = void 0;\nconst lisk_transactions_1 = require(\"@liskhq/lisk-transactions\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst codec_1 = require(\"./codec\");\nclass Transaction {\n    constructor(channel, registeredSchema, nodeInfo) {\n        this._channel = channel;\n        this._schema = registeredSchema;\n        this._nodeInfo = nodeInfo;\n    }\n    async create(input, passphrase, options) {\n        var _a;\n        const txInput = input;\n        const networkIdentifier = Buffer.from(this._nodeInfo.networkIdentifier, 'hex');\n        const { publicKey, address } = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase);\n        const accountHex = await this._channel.invoke('app:getAccount', {\n            address: address.toString('hex'),\n        });\n        const account = codec_1.decodeAccount(Buffer.from(accountHex, 'hex'), this._schema);\n        if (!txInput.moduleID) {\n            if (!txInput.moduleName) {\n                throw new Error('Missing moduleID and moduleName');\n            }\n            const registeredModule = this._nodeInfo.registeredModules.find(module => module.name === input.moduleName);\n            if (!registeredModule) {\n                throw new Error(`Module corresponding to name ${txInput.moduleName} not registered.`);\n            }\n            txInput.moduleID = registeredModule.id;\n        }\n        if (typeof txInput.assetID !== 'number') {\n            if (!txInput.assetName) {\n                throw new Error('Missing assetID and assetName');\n            }\n            const registeredModule = this._nodeInfo.registeredModules.find(m => m.id === txInput.moduleID);\n            if (!registeredModule) {\n                throw new Error(`Module corresponding to id ${txInput.moduleID} not registered.`);\n            }\n            const registeredAsset = registeredModule.transactionAssets.find(asset => asset.name === txInput.assetName);\n            if (!registeredAsset) {\n                throw new Error(`Asset corresponding to name ${txInput.assetName} not registered.`);\n            }\n            txInput.assetID = registeredAsset.id;\n        }\n        if (typeof txInput.nonce !== 'bigint') {\n            if (typeof account.sequence !== 'object' ||\n                typeof account.sequence.nonce !== 'bigint') {\n                throw new Error('Unsupported account type');\n            }\n            txInput.nonce = account.sequence.nonce;\n        }\n        if (txInput.nonce < BigInt(0)) {\n            throw new Error('Nonce must be greater or equal to zero');\n        }\n        if (!txInput.senderPublicKey) {\n            txInput.senderPublicKey = publicKey;\n        }\n        txInput.signatures = (_a = txInput.signatures) !== null && _a !== void 0 ? _a : [];\n        const assetSchema = codec_1.getTransactionAssetSchema(txInput, this._schema);\n        if (account.keys && account.keys.numberOfSignatures > 0) {\n            return lisk_transactions_1.signMultiSignatureTransaction(assetSchema, txInput, networkIdentifier, passphrase, account.keys, options === null || options === void 0 ? void 0 : options.includeSenderSignature);\n        }\n        if ((options === null || options === void 0 ? void 0 : options.multisignatureKeys) && (options === null || options === void 0 ? void 0 : options.includeSenderSignature)) {\n            return lisk_transactions_1.signMultiSignatureTransaction(assetSchema, txInput, networkIdentifier, passphrase, options.multisignatureKeys, options.includeSenderSignature);\n        }\n        return lisk_transactions_1.signTransaction(assetSchema, txInput, networkIdentifier, passphrase);\n    }\n    async get(id) {\n        const idString = Buffer.isBuffer(id) ? id.toString('hex') : id;\n        const transactionHex = await this._channel.invoke('app:getTransactionByID', {\n            id: idString,\n        });\n        return codec_1.decodeTransaction(Buffer.from(transactionHex, 'hex'), this._schema);\n    }\n    async getFromPool() {\n        const transactionsHex = await this._channel.invoke('app:getTransactionsFromPool');\n        const decodedTransactions = [];\n        for (const transactionHex of transactionsHex) {\n            decodedTransactions.push(codec_1.decodeTransaction(Buffer.from(transactionHex, 'hex'), this._schema));\n        }\n        return decodedTransactions;\n    }\n    async sign(transaction, passphrases, options) {\n        const assetSchema = codec_1.getTransactionAssetSchema(transaction, this._schema);\n        const networkIdentifier = Buffer.from(this._nodeInfo.networkIdentifier, 'hex');\n        const address = lisk_cryptography_1.getAddressFromPublicKey(transaction.senderPublicKey);\n        const accountHex = await this._channel.invoke('app:getAccount', {\n            address: address.toString('hex'),\n        });\n        const account = codec_1.decodeAccount(Buffer.from(accountHex, 'hex'), this._schema);\n        if (account.keys && account.keys.numberOfSignatures > 0) {\n            for (const passphrase of passphrases) {\n                lisk_transactions_1.signMultiSignatureTransaction(assetSchema, transaction, networkIdentifier, passphrase, account.keys, options === null || options === void 0 ? void 0 : options.includeSenderSignature);\n            }\n            return transaction;\n        }\n        if ((options === null || options === void 0 ? void 0 : options.multisignatureKeys) && (options === null || options === void 0 ? void 0 : options.includeSenderSignature)) {\n            for (const passphrase of passphrases) {\n                lisk_transactions_1.signMultiSignatureTransaction(assetSchema, transaction, networkIdentifier, passphrase, options.multisignatureKeys, options.includeSenderSignature);\n            }\n            return transaction;\n        }\n        return lisk_transactions_1.signTransaction(assetSchema, transaction, networkIdentifier, passphrases[0]);\n    }\n    async send(transaction) {\n        const encodedTx = codec_1.encodeTransaction(transaction, this._schema);\n        return this._channel.invoke('app:postTransaction', { transaction: encodedTx.toString('hex') });\n    }\n    decode(transaction) {\n        const transactionBuffer = Buffer.isBuffer(transaction)\n            ? transaction\n            : Buffer.from(transaction, 'hex');\n        return codec_1.decodeTransaction(transactionBuffer, this._schema);\n    }\n    encode(transaction) {\n        return codec_1.encodeTransaction(transaction, this._schema);\n    }\n    computeMinFee(transaction) {\n        const assetSchema = codec_1.getTransactionAssetSchema(transaction, this._schema);\n        const numberOfSignatures = transaction.signatures\n            ? transaction.signatures.length\n            : 1;\n        const options = {\n            minFeePerByte: this._nodeInfo.genesisConfig.minFeePerByte,\n            baseFees: this._nodeInfo.genesisConfig.baseFees,\n            numberOfSignatures,\n        };\n        return lisk_transactions_1.computeMinFee(assetSchema, transaction, options);\n    }\n    toJSON(transaction) {\n        const { asset: txAsset, ...txRoot } = transaction;\n        const tmpId = txRoot.id;\n        delete txRoot.id;\n        const schemaAsset = codec_1.getTransactionAssetSchema(txRoot, this._schema);\n        const jsonTxAsset = lisk_codec_1.codec.toJSON(schemaAsset, txAsset);\n        const jsonTxRoot = lisk_codec_1.codec.toJSON(this._schema.transaction, txRoot);\n        const jsonTx = {\n            ...jsonTxRoot,\n            asset: jsonTxAsset,\n            id: Buffer.isBuffer(tmpId) ? tmpId.toString('hex') : tmpId,\n        };\n        return jsonTx;\n    }\n    fromJSON(transaction) {\n        const { asset: txAsset, ...txRoot } = transaction;\n        const tmpId = txRoot.id;\n        delete txRoot.id;\n        const schemaAsset = codec_1.getTransactionAssetSchema(txRoot, this._schema);\n        const txAssetObject = lisk_codec_1.codec.fromJSON(schemaAsset, txAsset);\n        const txRootObject = lisk_codec_1.codec.fromJSON(this._schema.transaction, txRoot);\n        const txObject = {\n            ...txRootObject,\n            asset: txAssetObject,\n            id: typeof tmpId === 'string' ? Buffer.from(tmpId, 'hex') : Buffer.alloc(0),\n        };\n        return txObject;\n    }\n}\nexports.Transaction = Transaction;\n//# sourceMappingURL=transaction.js.map"]},"metadata":{},"sourceType":"script"}