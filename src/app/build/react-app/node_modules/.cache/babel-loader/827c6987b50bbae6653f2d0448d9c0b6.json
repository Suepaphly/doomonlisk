{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hashOnion = exports.generateHashOnionSeed = void 0;\n\nvar hash_1 = require(\"./hash\");\n\nvar nacl_1 = require(\"./nacl\");\n\nvar HASH_SIZE = 16;\nvar INPUT_SIZE = 64;\nvar defaultCount = 1000000;\nvar defaultDistance = 1000;\n\nvar generateHashOnionSeed = function generateHashOnionSeed() {\n  return hash_1.hash(nacl_1.getRandomBytes(INPUT_SIZE)).slice(0, HASH_SIZE);\n};\n\nexports.generateHashOnionSeed = generateHashOnionSeed;\n\nvar hashOnion = function hashOnion(seed) {\n  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCount;\n  var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultDistance;\n\n  if (count < distance) {\n    throw new Error('Invalid count or distance. Count must be greater than distance');\n  }\n\n  if (count % distance !== 0) {\n    throw new Error('Invalid count. Count must be multiple of distance');\n  }\n\n  var previousHash = seed;\n  var hashes = [seed];\n\n  for (var i = 1; i <= count; i += 1) {\n    var nextHash = hash_1.hash(previousHash).slice(0, HASH_SIZE);\n\n    if (i % distance === 0) {\n      hashes.push(nextHash);\n    }\n\n    previousHash = nextHash;\n  }\n\n  return hashes.reverse();\n};\n\nexports.hashOnion = hashOnion;","map":{"version":3,"sources":["../src/hash_onion.ts"],"names":[],"mappings":";;;;;;;AAeA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAM,SAAS,GAAG,EAAlB;AACA,IAAM,UAAU,GAAG,EAAnB;AACA,IAAM,YAAY,GAAG,OAArB;AACA,IAAM,eAAe,GAAG,IAAxB;;AAEO,IAAM,qBAAqB,GAAG,SAAxB,qBAAwB;AAAA,SACpC,MAAA,CAAA,IAAA,CAAK,MAAA,CAAA,cAAA,CAAe,UAAf,CAAL,EAAiC,KAAjC,CAAuC,CAAvC,EAA0C,SAA1C,CADoC;AAAA,CAA9B;;AAAM,OAAA,CAAA,qBAAA,GAAqB,qBAArB;;AAGN,IAAM,SAAS,GAAG,SAAZ,SAAY,CACxB,IADwB,EAIE;AAAA,MAF1B,KAE0B,uEAFV,YAEU;AAAA,MAD1B,QAC0B,uEADP,eACO;;AAC1B,MAAI,KAAK,GAAG,QAAZ,EAAsB;AACrB,UAAM,IAAI,KAAJ,CAAU,gEAAV,CAAN;AACA;;AAED,MAAI,KAAK,GAAG,QAAR,KAAqB,CAAzB,EAA4B;AAC3B,UAAM,IAAI,KAAJ,CAAU,mDAAV,CAAN;AACA;;AAED,MAAI,YAAY,GAAG,IAAnB;AACA,MAAM,MAAM,GAAG,CAAC,IAAD,CAAf;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,KAArB,EAA4B,CAAC,IAAI,CAAjC,EAAoC;AACnC,QAAM,QAAQ,GAAG,MAAA,CAAA,IAAA,CAAK,YAAL,EAAmB,KAAnB,CAAyB,CAAzB,EAA4B,SAA5B,CAAjB;;AACA,QAAI,CAAC,GAAG,QAAJ,KAAiB,CAArB,EAAwB;AACvB,MAAA,MAAM,CAAC,IAAP,CAAY,QAAZ;AACA;;AACD,IAAA,YAAY,GAAG,QAAf;AACA;;AAED,SAAO,MAAM,CAAC,OAAP,EAAP;AACA,CAzBM;;AAAM,OAAA,CAAA,SAAA,GAAS,SAAT","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashOnion = exports.generateHashOnionSeed = void 0;\nconst hash_1 = require(\"./hash\");\nconst nacl_1 = require(\"./nacl\");\nconst HASH_SIZE = 16;\nconst INPUT_SIZE = 64;\nconst defaultCount = 1000000;\nconst defaultDistance = 1000;\nconst generateHashOnionSeed = () => hash_1.hash(nacl_1.getRandomBytes(INPUT_SIZE)).slice(0, HASH_SIZE);\nexports.generateHashOnionSeed = generateHashOnionSeed;\nconst hashOnion = (seed, count = defaultCount, distance = defaultDistance) => {\n    if (count < distance) {\n        throw new Error('Invalid count or distance. Count must be greater than distance');\n    }\n    if (count % distance !== 0) {\n        throw new Error('Invalid count. Count must be multiple of distance');\n    }\n    let previousHash = seed;\n    const hashes = [seed];\n    for (let i = 1; i <= count; i += 1) {\n        const nextHash = hash_1.hash(previousHash).slice(0, HASH_SIZE);\n        if (i % distance === 0) {\n            hashes.push(nextHash);\n        }\n        previousHash = nextHash;\n    }\n    return hashes.reverse();\n};\nexports.hashOnion = hashOnion;\n//# sourceMappingURL=hash_onion.js.map"]},"metadata":{},"sourceType":"script"}