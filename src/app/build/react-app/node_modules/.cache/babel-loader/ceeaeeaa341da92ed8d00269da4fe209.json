{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.postTransaction = exports.getTransaction = void 0;\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nvar transactionInputSchema = {\n  type: 'object',\n  required: ['moduleID', 'assetID', 'nonce', 'fee', 'senderPublicKey', 'asset', 'signatures'],\n  properties: {\n    moduleID: {\n      type: 'number',\n      description: 'Describes the Transaction module type.'\n    },\n    assetID: {\n      type: 'number',\n      description: 'Describes the Transaction asset type.'\n    },\n    fee: {\n      type: 'string',\n      description: 'Transaction fee associated with this transaction.\\n'\n    },\n    nonce: {\n      type: 'string',\n      examples: ['1'],\n      description: 'Unique sequence of number per account.\\n'\n    },\n    senderPublicKey: {\n      type: 'string',\n      format: 'hex',\n      description: 'Hex encoded value of the public key of the Senders account.\\n'\n    },\n    asset: {\n      type: 'object',\n      description: 'Object stored per transaction type'\n    },\n    signatures: {\n      type: 'array',\n      items: {\n        type: 'string',\n        anyOf: [{\n          const: ''\n        }, {\n          format: 'hex'\n        }],\n        description: 'Hex encoded value of the signature for the transaction.'\n      },\n      minItems: 1\n    }\n  }\n};\n\nvar getTransaction = function getTransaction(channel, codec) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(req, res) {\n      var transactionId, transaction;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              transactionId = req.params.id;\n\n              if (!(!transactionId || !lisk_validator_1.isHexString(transactionId))) {\n                _context.next = 4;\n                break;\n              }\n\n              res.status(400).send({\n                errors: [{\n                  message: 'Transaction id parameter should be a hex string.'\n                }]\n              });\n              return _context.abrupt(\"return\");\n\n            case 4:\n              _context.prev = 4;\n              _context.next = 7;\n              return channel.invoke('app:getTransactionByID', {\n                id: transactionId\n              });\n\n            case 7:\n              transaction = _context.sent;\n              _context.next = 14;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](4);\n              res.status(404).json({\n                errors: [{\n                  message: \"The transaction with id \\\"\".concat(transactionId, \"\\\" not found.\")\n                }]\n              });\n              return _context.abrupt(\"return\");\n\n            case 14:\n              res.status(200).json({\n                data: codec.decodeTransaction(transaction),\n                meta: {}\n              });\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[4, 10]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\n\nexports.getTransaction = getTransaction;\n\nvar postTransaction = function postTransaction(channel, codec) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(req, res) {\n      var errors, encodedTransaction, result;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              errors = lisk_validator_1.validator.validate(transactionInputSchema, req.body);\n\n              if (!errors.length) {\n                _context2.next = 4;\n                break;\n              }\n\n              res.status(400).send({\n                errors: [{\n                  message: new lisk_validator_1.LiskValidationError(_toConsumableArray(errors)).message\n                }]\n              });\n              return _context2.abrupt(\"return\");\n\n            case 4:\n              _context2.prev = 4;\n              encodedTransaction = codec.encodeTransaction(req.body);\n              _context2.next = 8;\n              return channel.invoke('app:postTransaction', {\n                transaction: encodedTransaction\n              });\n\n            case 8:\n              result = _context2.sent;\n              res.status(200).json({\n                data: result,\n                meta: {}\n              });\n              _context2.next = 15;\n              break;\n\n            case 12:\n              _context2.prev = 12;\n              _context2.t0 = _context2[\"catch\"](4);\n              res.status(409).json({\n                errors: [{\n                  message: _context2.t0.message\n                }]\n              });\n\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[4, 12]]);\n    }));\n\n    return function (_x3, _x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n};\n\nexports.postTransaction = postTransaction;","map":{"version":3,"sources":["../../src/controllers/transactions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.postTransaction = exports.getTransaction = void 0;\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst transactionInputSchema = {\n    type: 'object',\n    required: ['moduleID', 'assetID', 'nonce', 'fee', 'senderPublicKey', 'asset', 'signatures'],\n    properties: {\n        moduleID: {\n            type: 'number',\n            description: 'Describes the Transaction module type.',\n        },\n        assetID: {\n            type: 'number',\n            description: 'Describes the Transaction asset type.',\n        },\n        fee: {\n            type: 'string',\n            description: 'Transaction fee associated with this transaction.\\n',\n        },\n        nonce: {\n            type: 'string',\n            examples: ['1'],\n            description: 'Unique sequence of number per account.\\n',\n        },\n        senderPublicKey: {\n            type: 'string',\n            format: 'hex',\n            description: 'Hex encoded value of the public key of the Senders account.\\n',\n        },\n        asset: {\n            type: 'object',\n            description: 'Object stored per transaction type',\n        },\n        signatures: {\n            type: 'array',\n            items: {\n                type: 'string',\n                anyOf: [{ const: '' }, { format: 'hex' }],\n                description: 'Hex encoded value of the signature for the transaction.',\n            },\n            minItems: 1,\n        },\n    },\n};\nconst getTransaction = (channel, codec) => async (req, res) => {\n    const transactionId = req.params.id;\n    if (!transactionId || !lisk_validator_1.isHexString(transactionId)) {\n        res.status(400).send({\n            errors: [{ message: 'Transaction id parameter should be a hex string.' }],\n        });\n        return;\n    }\n    let transaction;\n    try {\n        transaction = await channel.invoke('app:getTransactionByID', {\n            id: transactionId,\n        });\n    }\n    catch (error) {\n        res.status(404).json({\n            errors: [{ message: `The transaction with id \"${transactionId}\" not found.` }],\n        });\n        return;\n    }\n    res.status(200).json({ data: codec.decodeTransaction(transaction), meta: {} });\n};\nexports.getTransaction = getTransaction;\nconst postTransaction = (channel, codec) => async (req, res) => {\n    const errors = lisk_validator_1.validator.validate(transactionInputSchema, req.body);\n    if (errors.length) {\n        res.status(400).send({\n            errors: [{ message: new lisk_validator_1.LiskValidationError([...errors]).message }],\n        });\n        return;\n    }\n    try {\n        const encodedTransaction = codec.encodeTransaction(req.body);\n        const result = await channel.invoke('app:postTransaction', {\n            transaction: encodedTransaction,\n        });\n        res.status(200).json({ data: result, meta: {} });\n    }\n    catch (err) {\n        res.status(409).json({\n            errors: [{ message: err.message }],\n        });\n    }\n};\nexports.postTransaction = postTransaction;\n//# sourceMappingURL=transactions.js.map"]},"metadata":{},"sourceType":"script"}