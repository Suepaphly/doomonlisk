{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IPCChannel = void 0;\n\nvar path = require(\"path\");\n\nvar axon = require(\"pm2-axon\");\n\nvar os_1 = require(\"os\");\n\nvar pm2_axon_rpc_1 = require(\"pm2-axon-rpc\");\n\nvar events_1 = require(\"events\");\n\nvar utils_1 = require(\"./utils\");\n\nvar CONNECTION_TIME_OUT = 2000;\n\nvar getSocketsPath = function getSocketsPath(dataPath) {\n  var socketDir = path.join(path.resolve(dataPath.replace('~', os_1.homedir())), 'tmp', 'sockets');\n  return {\n    root: \"unix://\".concat(socketDir),\n    pub: \"unix://\".concat(socketDir, \"/pub_socket.sock\"),\n    sub: \"unix://\".concat(socketDir, \"/sub_socket.sock\"),\n    rpc: \"unix://\".concat(socketDir, \"/bus_rpc_socket.sock\")\n  };\n};\n\nvar IPCChannel = /*#__PURE__*/function () {\n  function IPCChannel(dataPath) {\n    _classCallCheck(this, IPCChannel);\n\n    var socketsDir = getSocketsPath(dataPath);\n    this._eventPubSocketPath = socketsDir.pub;\n    this._eventSubSocketPath = socketsDir.sub;\n    this._rpcServerSocketPath = socketsDir.rpc;\n    this._pubSocket = axon.socket('push', {});\n    this._subSocket = axon.socket('sub', {});\n    this._rpcClient = new pm2_axon_rpc_1.Client(axon.socket('req'));\n    this._events = new events_1.EventEmitter();\n    this._id = 0;\n  }\n\n  _createClass(IPCChannel, [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return new Promise(function (resolve, reject) {\n                  var timeout = setTimeout(function () {\n                    reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n                  }, CONNECTION_TIME_OUT);\n\n                  _this._pubSocket.on('connect', function () {\n                    clearTimeout(timeout);\n                    resolve(undefined);\n                  });\n\n                  _this._pubSocket.on('error', reject);\n\n                  _this._pubSocket.connect(_this._eventSubSocketPath);\n                }).finally(function () {\n                  _this._pubSocket.removeAllListeners('connect');\n\n                  _this._pubSocket.removeAllListeners('error');\n                });\n\n              case 2:\n                _context.next = 4;\n                return new Promise(function (resolve, reject) {\n                  var timeout = setTimeout(function () {\n                    reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n                  }, CONNECTION_TIME_OUT);\n\n                  _this._subSocket.on('connect', function () {\n                    clearTimeout(timeout);\n                    resolve();\n                  });\n\n                  _this._subSocket.on('error', reject);\n\n                  _this._subSocket.connect(_this._eventPubSocketPath);\n                }).finally(function () {\n                  _this._subSocket.removeAllListeners('connect');\n\n                  _this._subSocket.removeAllListeners('error');\n                });\n\n              case 4:\n                _context.next = 6;\n                return new Promise(function (resolve, reject) {\n                  var timeout = setTimeout(function () {\n                    reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n                  }, CONNECTION_TIME_OUT);\n\n                  _this._rpcClient.sock.on('connect', function () {\n                    clearTimeout(timeout);\n                    resolve(undefined);\n                  });\n\n                  _this._rpcClient.sock.on('error', reject);\n\n                  _this._rpcClient.sock.connect(_this._rpcServerSocketPath);\n                }).finally(function () {\n                  _this._rpcClient.sock.removeAllListeners('connect');\n\n                  _this._rpcClient.sock.removeAllListeners('error');\n                });\n\n              case 6:\n                this._subSocket.on('message', function (eventData) {\n                  _this._events.emit(eventData.method, eventData.params);\n                });\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._subSocket.removeAllListeners();\n\n                this._pubSocket.close();\n\n                this._subSocket.close();\n\n                this._rpcClient.sock.close();\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }()\n  }, {\n    key: \"invoke\",\n    value: function () {\n      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(actionName, params) {\n        var _this2 = this;\n\n        var action;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._id += 1;\n                action = {\n                  id: this._id,\n                  jsonrpc: '2.0',\n                  method: actionName,\n                  params: params !== null && params !== void 0 ? params : {}\n                };\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this2._rpcClient.call('invoke', action, function (err, data) {\n                    if (err) {\n                      reject(utils_1.convertRPCError(err));\n                      return;\n                    }\n\n                    if (data.error) {\n                      reject(utils_1.convertRPCError(data.error));\n                      return;\n                    }\n\n                    resolve(data.result);\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function invoke(_x, _x2) {\n        return _invoke.apply(this, arguments);\n      }\n\n      return invoke;\n    }()\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(eventName, cb) {\n      this._events.on(eventName, cb);\n    }\n  }]);\n\n  return IPCChannel;\n}();\n\nexports.IPCChannel = IPCChannel;","map":{"version":3,"sources":["../src/ipc_channel.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IPCChannel = void 0;\nconst path = require(\"path\");\nconst axon = require(\"pm2-axon\");\nconst os_1 = require(\"os\");\nconst pm2_axon_rpc_1 = require(\"pm2-axon-rpc\");\nconst events_1 = require(\"events\");\nconst utils_1 = require(\"./utils\");\nconst CONNECTION_TIME_OUT = 2000;\nconst getSocketsPath = (dataPath) => {\n    const socketDir = path.join(path.resolve(dataPath.replace('~', os_1.homedir())), 'tmp', 'sockets');\n    return {\n        root: `unix://${socketDir}`,\n        pub: `unix://${socketDir}/pub_socket.sock`,\n        sub: `unix://${socketDir}/sub_socket.sock`,\n        rpc: `unix://${socketDir}/bus_rpc_socket.sock`,\n    };\n};\nclass IPCChannel {\n    constructor(dataPath) {\n        const socketsDir = getSocketsPath(dataPath);\n        this._eventPubSocketPath = socketsDir.pub;\n        this._eventSubSocketPath = socketsDir.sub;\n        this._rpcServerSocketPath = socketsDir.rpc;\n        this._pubSocket = axon.socket('push', {});\n        this._subSocket = axon.socket('sub', {});\n        this._rpcClient = new pm2_axon_rpc_1.Client(axon.socket('req'));\n        this._events = new events_1.EventEmitter();\n        this._id = 0;\n    }\n    async connect() {\n        await new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n            }, CONNECTION_TIME_OUT);\n            this._pubSocket.on('connect', () => {\n                clearTimeout(timeout);\n                resolve(undefined);\n            });\n            this._pubSocket.on('error', reject);\n            this._pubSocket.connect(this._eventSubSocketPath);\n        }).finally(() => {\n            this._pubSocket.removeAllListeners('connect');\n            this._pubSocket.removeAllListeners('error');\n        });\n        await new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n            }, CONNECTION_TIME_OUT);\n            this._subSocket.on('connect', () => {\n                clearTimeout(timeout);\n                resolve();\n            });\n            this._subSocket.on('error', reject);\n            this._subSocket.connect(this._eventPubSocketPath);\n        }).finally(() => {\n            this._subSocket.removeAllListeners('connect');\n            this._subSocket.removeAllListeners('error');\n        });\n        await new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n            }, CONNECTION_TIME_OUT);\n            this._rpcClient.sock.on('connect', () => {\n                clearTimeout(timeout);\n                resolve(undefined);\n            });\n            this._rpcClient.sock.on('error', reject);\n            this._rpcClient.sock.connect(this._rpcServerSocketPath);\n        }).finally(() => {\n            this._rpcClient.sock.removeAllListeners('connect');\n            this._rpcClient.sock.removeAllListeners('error');\n        });\n        this._subSocket.on('message', (eventData) => {\n            this._events.emit(eventData.method, eventData.params);\n        });\n    }\n    async disconnect() {\n        this._subSocket.removeAllListeners();\n        this._pubSocket.close();\n        this._subSocket.close();\n        this._rpcClient.sock.close();\n    }\n    async invoke(actionName, params) {\n        this._id += 1;\n        const action = {\n            id: this._id,\n            jsonrpc: '2.0',\n            method: actionName,\n            params: params !== null && params !== void 0 ? params : {},\n        };\n        return new Promise((resolve, reject) => {\n            this._rpcClient.call('invoke', action, (err, data) => {\n                if (err) {\n                    reject(utils_1.convertRPCError(err));\n                    return;\n                }\n                if (data.error) {\n                    reject(utils_1.convertRPCError(data.error));\n                    return;\n                }\n                resolve(data.result);\n            });\n        });\n    }\n    subscribe(eventName, cb) {\n        this._events.on(eventName, cb);\n    }\n}\nexports.IPCChannel = IPCChannel;\n//# sourceMappingURL=ipc_channel.js.map"]},"metadata":{},"sourceType":"script"}