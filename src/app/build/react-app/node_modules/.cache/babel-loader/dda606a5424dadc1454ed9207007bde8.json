{"ast":null,"code":"var SCServerSocket = require('./scserversocket');\n\nvar AuthEngine = require('sc-auth').AuthEngine;\n\nvar formatter = require('sc-formatter');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Emitter = require('component-emitter');\n\nvar base64id = require('base64id');\n\nvar async = require('async');\n\nvar url = require('url');\n\nvar crypto = require('crypto');\n\nvar uuid = require('uuid');\n\nvar SCSimpleBroker = require('sc-simple-broker').SCSimpleBroker;\n\nvar scErrors = require('sc-errors');\n\nvar AuthTokenExpiredError = scErrors.AuthTokenExpiredError;\nvar AuthTokenInvalidError = scErrors.AuthTokenInvalidError;\nvar AuthTokenNotBeforeError = scErrors.AuthTokenNotBeforeError;\nvar AuthTokenError = scErrors.AuthTokenError;\nvar SilentMiddlewareBlockedError = scErrors.SilentMiddlewareBlockedError;\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\nvar InvalidOptionsError = scErrors.InvalidOptionsError;\nvar InvalidActionError = scErrors.InvalidActionError;\nvar BrokerError = scErrors.BrokerError;\nvar ServerProtocolError = scErrors.ServerProtocolError;\n\nvar SCServer = function SCServer(options) {\n  var self = this;\n  EventEmitter.call(this);\n  var opts = {\n    brokerEngine: new SCSimpleBroker(),\n    wsEngine: 'ws',\n    wsEngineServerOptions: {},\n    maxPayload: null,\n    allowClientPublish: true,\n    ackTimeout: 10000,\n    handshakeTimeout: 10000,\n    strictHandshake: true,\n    pingTimeout: 20000,\n    pingTimeoutDisabled: false,\n    pingInterval: 8000,\n    origins: '*:*',\n    appName: uuid.v4(),\n    path: '/socketcluster/',\n    authDefaultExpiry: 86400,\n    authSignAsync: false,\n    authVerifyAsync: true,\n    pubSubBatchDuration: null,\n    middlewareEmitWarnings: true\n  };\n\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n\n  this.options = opts;\n  this.MIDDLEWARE_HANDSHAKE_WS = 'handshakeWS';\n  this.MIDDLEWARE_HANDSHAKE_SC = 'handshakeSC';\n  this.MIDDLEWARE_EMIT = 'emit';\n  this.MIDDLEWARE_SUBSCRIBE = 'subscribe';\n  this.MIDDLEWARE_PUBLISH_IN = 'publishIn';\n  this.MIDDLEWARE_PUBLISH_OUT = 'publishOut';\n  this.MIDDLEWARE_AUTHENTICATE = 'authenticate'; // Deprecated\n\n  this.MIDDLEWARE_PUBLISH = this.MIDDLEWARE_PUBLISH_IN;\n  this._middleware = {};\n  this._middleware[this.MIDDLEWARE_HANDSHAKE_WS] = [];\n  this._middleware[this.MIDDLEWARE_HANDSHAKE_SC] = [];\n  this._middleware[this.MIDDLEWARE_EMIT] = [];\n  this._middleware[this.MIDDLEWARE_SUBSCRIBE] = [];\n  this._middleware[this.MIDDLEWARE_PUBLISH_IN] = [];\n  this._middleware[this.MIDDLEWARE_PUBLISH_OUT] = [];\n  this._middleware[this.MIDDLEWARE_AUTHENTICATE] = [];\n  this.origins = opts.origins;\n  this._allowAllOrigins = this.origins.indexOf('*:*') !== -1;\n  this.ackTimeout = opts.ackTimeout;\n  this.handshakeTimeout = opts.handshakeTimeout;\n  this.pingInterval = opts.pingInterval;\n  this.pingTimeout = opts.pingTimeout;\n  this.pingTimeoutDisabled = opts.pingTimeoutDisabled;\n  this.allowClientPublish = opts.allowClientPublish;\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.httpServer = opts.httpServer;\n  this.socketChannelLimit = opts.socketChannelLimit;\n  this.strictHandshake = opts.strictHandshake;\n  this.brokerEngine = opts.brokerEngine;\n  this.appName = opts.appName || '';\n  this.middlewareEmitWarnings = opts.middlewareEmitWarnings; // Make sure there is always a leading and a trailing slash in the WS path.\n\n  this._path = opts.path.replace(/\\/?$/, '/').replace(/^\\/?/, '/');\n  this.isReady = false;\n  this.brokerEngine.once('ready', function () {\n    self.isReady = true;\n    EventEmitter.prototype.emit.call(self, 'ready');\n  });\n  var wsEngine = typeof opts.wsEngine === 'string' ? require(opts.wsEngine) : opts.wsEngine;\n\n  if (!wsEngine || !wsEngine.Server) {\n    throw new InvalidOptionsError('The wsEngine option must be a path or module name which points ' + 'to a valid WebSocket engine module with a compatible interface');\n  }\n\n  var WSServer = wsEngine.Server;\n\n  if (opts.authPrivateKey != null || opts.authPublicKey != null) {\n    if (opts.authPrivateKey == null) {\n      throw new InvalidOptionsError('The authPrivateKey option must be specified if authPublicKey is specified');\n    } else if (opts.authPublicKey == null) {\n      throw new InvalidOptionsError('The authPublicKey option must be specified if authPrivateKey is specified');\n    }\n\n    this.signatureKey = opts.authPrivateKey;\n    this.verificationKey = opts.authPublicKey;\n  } else {\n    if (opts.authKey == null) {\n      opts.authKey = crypto.randomBytes(32).toString('hex');\n    }\n\n    this.signatureKey = opts.authKey;\n    this.verificationKey = opts.authKey;\n  }\n\n  this.authVerifyAsync = opts.authVerifyAsync;\n  this.authSignAsync = opts.authSignAsync;\n  this.defaultVerificationOptions = {\n    async: this.authVerifyAsync\n  };\n\n  if (opts.authVerifyAlgorithms != null) {\n    this.defaultVerificationOptions.algorithms = opts.authVerifyAlgorithms;\n  } else if (opts.authAlgorithm != null) {\n    this.defaultVerificationOptions.algorithms = [opts.authAlgorithm];\n  }\n\n  this.defaultSignatureOptions = {\n    expiresIn: opts.authDefaultExpiry,\n    async: this.authSignAsync\n  };\n\n  if (opts.authAlgorithm != null) {\n    this.defaultSignatureOptions.algorithm = opts.authAlgorithm;\n  }\n\n  if (opts.authEngine) {\n    this.auth = opts.authEngine;\n  } else {\n    // Default authentication engine\n    this.auth = new AuthEngine();\n  }\n\n  if (opts.codecEngine) {\n    this.codec = opts.codecEngine;\n  } else {\n    // Default codec engine\n    this.codec = formatter;\n  }\n\n  this.clients = {};\n  this.clientsCount = 0;\n  this.pendingClients = {};\n  this.pendingClientsCount = 0;\n  this.exchange = this.brokerEngine.exchange();\n  var wsServerOptions = opts.wsEngineServerOptions || {};\n  wsServerOptions.server = this.httpServer;\n  wsServerOptions.verifyClient = this.verifyHandshake.bind(this);\n\n  if (wsServerOptions.path == null && this._path != null) {\n    wsServerOptions.path = this._path;\n  }\n\n  if (wsServerOptions.perMessageDeflate == null && this.perMessageDeflate != null) {\n    wsServerOptions.perMessageDeflate = this.perMessageDeflate;\n  }\n\n  if (wsServerOptions.handleProtocols == null && opts.handleProtocols != null) {\n    wsServerOptions.handleProtocols = opts.handleProtocols;\n  }\n\n  if (wsServerOptions.maxPayload == null && opts.maxPayload != null) {\n    wsServerOptions.maxPayload = opts.maxPayload;\n  }\n\n  if (wsServerOptions.clientTracking == null) {\n    wsServerOptions.clientTracking = false;\n  }\n\n  this.wsServer = new WSServer(wsServerOptions);\n  this.wsServer.on('error', this._handleServerError.bind(this));\n  this.wsServer.on('connection', this._handleSocketConnection.bind(this));\n};\n\nSCServer.prototype = Object.create(EventEmitter.prototype);\n\nSCServer.prototype.setAuthEngine = function (authEngine) {\n  this.auth = authEngine;\n};\n\nSCServer.prototype.setCodecEngine = function (codecEngine) {\n  this.codec = codecEngine;\n};\n\nSCServer.prototype._handleServerError = function (error) {\n  if (typeof error === 'string') {\n    error = new ServerProtocolError(error);\n  }\n\n  this.emit('error', error);\n};\n\nSCServer.prototype._handleSocketError = function (error) {\n  // We don't want to crash the entire worker on socket error\n  // so we emit it as a warning instead.\n  this.emit('warning', error);\n};\n\nSCServer.prototype._handleHandshakeTimeout = function (scSocket) {\n  scSocket.disconnect(4005);\n};\n\nSCServer.prototype._subscribeSocket = function (socket, channelOptions, callback) {\n  var self = this;\n\n  if (!channelOptions) {\n    callback && callback('Socket ' + socket.id + ' provided a malformated channel payload');\n    return;\n  }\n\n  if (this.socketChannelLimit && socket.channelSubscriptionsCount >= this.socketChannelLimit) {\n    callback && callback('Socket ' + socket.id + ' tried to exceed the channel subscription limit of ' + this.socketChannelLimit);\n    return;\n  }\n\n  var channelName = channelOptions.channel;\n\n  if (typeof channelName !== 'string') {\n    callback && callback('Socket ' + socket.id + ' provided an invalid channel name');\n    return;\n  }\n\n  if (socket.channelSubscriptionsCount == null) {\n    socket.channelSubscriptionsCount = 0;\n  }\n\n  if (socket.channelSubscriptions[channelName] == null) {\n    socket.channelSubscriptions[channelName] = true;\n    socket.channelSubscriptionsCount++;\n  }\n\n  this.brokerEngine.subscribeSocket(socket, channelName, function (err) {\n    if (err) {\n      delete socket.channelSubscriptions[channelName];\n      socket.channelSubscriptionsCount--;\n    } else {\n      Emitter.prototype.emit.call(socket, 'subscribe', channelName, channelOptions);\n      self.emit('subscription', socket, channelName, channelOptions);\n    }\n\n    callback && callback(err);\n  });\n};\n\nSCServer.prototype._unsubscribeSocketFromAllChannels = function (socket) {\n  var channels = [];\n\n  for (var channel in socket.channelSubscriptions) {\n    if (socket.channelSubscriptions.hasOwnProperty(channel)) {\n      channels.push(channel);\n    }\n  }\n\n  var len = channels.length;\n\n  for (var i = 0; i < len; i++) {\n    this._unsubscribeSocket(socket, channels[i]);\n  }\n};\n\nSCServer.prototype._unsubscribeSocket = function (socket, channel) {\n  if (typeof channel !== 'string') {\n    throw new InvalidActionError('Socket ' + socket.id + ' tried to unsubscribe from an invalid channel name');\n  }\n\n  if (!socket.channelSubscriptions[channel]) {\n    throw new InvalidActionError('Socket ' + socket.id + ' tried to unsubscribe from a channel which it is not subscribed to');\n  }\n\n  delete socket.channelSubscriptions[channel];\n\n  if (socket.channelSubscriptionsCount != null) {\n    socket.channelSubscriptionsCount--;\n  }\n\n  this.brokerEngine.unsubscribeSocket(socket, channel);\n  Emitter.prototype.emit.call(socket, 'unsubscribe', channel);\n  this.emit('unsubscription', socket, channel);\n};\n\nSCServer.prototype._processTokenError = function (err) {\n  var authError = null;\n  var isBadToken = true;\n\n  if (err) {\n    if (err.name === 'TokenExpiredError') {\n      authError = new AuthTokenExpiredError(err.message, err.expiredAt);\n    } else if (err.name === 'JsonWebTokenError') {\n      authError = new AuthTokenInvalidError(err.message);\n    } else if (err.name === 'NotBeforeError') {\n      authError = new AuthTokenNotBeforeError(err.message, err.date); // In this case, the token is good; it's just not active yet.\n\n      isBadToken = false;\n    } else {\n      authError = new AuthTokenError(err.message);\n    }\n  }\n\n  return {\n    authError: authError,\n    isBadToken: isBadToken\n  };\n};\n\nSCServer.prototype._emitBadAuthTokenError = function (scSocket, error, signedAuthToken) {\n  var badAuthStatus = {\n    authError: error,\n    signedAuthToken: signedAuthToken\n  };\n  Emitter.prototype.emit.call(scSocket, 'badAuthToken', badAuthStatus);\n  this.emit('badSocketAuthToken', scSocket, badAuthStatus);\n};\n\nSCServer.prototype._processAuthToken = function (scSocket, signedAuthToken, callback) {\n  var self = this;\n  var verificationOptions = Object.assign({\n    socket: scSocket\n  }, this.defaultVerificationOptions);\n  this.auth.verifyToken(signedAuthToken, this.verificationKey, verificationOptions, function (err, authToken) {\n    var oldState = scSocket.authState;\n\n    if (authToken) {\n      scSocket.signedAuthToken = signedAuthToken;\n      scSocket.authToken = authToken;\n      scSocket.authState = scSocket.AUTHENTICATED;\n    } else {\n      scSocket.signedAuthToken = null;\n      scSocket.authToken = null;\n      scSocket.authState = scSocket.UNAUTHENTICATED;\n    } // If the socket is authenticated, pass it through the MIDDLEWARE_AUTHENTICATE middleware.\n    // If the token is bad, we will tell the client to remove it.\n    // If there is an error but the token is good, then we will send back a 'quiet' error instead\n    // (as part of the status object only).\n\n\n    if (scSocket.authToken) {\n      self._passThroughAuthenticateMiddleware({\n        socket: scSocket,\n        signedAuthToken: scSocket.signedAuthToken,\n        authToken: scSocket.authToken\n      }, function (middlewareError, isBadToken) {\n        if (middlewareError) {\n          scSocket.authToken = null;\n          scSocket.authState = scSocket.UNAUTHENTICATED;\n\n          if (isBadToken) {\n            self._emitBadAuthTokenError(scSocket, middlewareError, signedAuthToken);\n          }\n        } // If an error is passed back from the authenticate middleware, it will be treated as a\n        // server warning and not a socket error.\n\n\n        callback(middlewareError, isBadToken || false, oldState);\n      });\n    } else {\n      var errorData = self._processTokenError(err); // If the error is related to the JWT being badly formatted, then we will\n      // treat the error as a socket error.\n\n\n      if (err && signedAuthToken != null) {\n        Emitter.prototype.emit.call(scSocket, 'error', errorData.authError);\n\n        if (errorData.isBadToken) {\n          self._emitBadAuthTokenError(scSocket, errorData.authError, signedAuthToken);\n        }\n      }\n\n      callback(errorData.authError, errorData.isBadToken, oldState);\n    }\n  });\n};\n\nSCServer.prototype._handleSocketConnection = function (wsSocket, upgradeReq) {\n  var self = this;\n\n  if (this.options.wsEngine === 'ws') {\n    wsSocket.upgradeReq = upgradeReq;\n  }\n\n  var id = this.generateId();\n  var scSocket = new SCServerSocket(id, this, wsSocket);\n  scSocket.exchange = self.exchange;\n  scSocket.on('error', function (err) {\n    self._handleSocketError(err);\n  });\n  self.pendingClients[id] = scSocket;\n  self.pendingClientsCount++;\n  scSocket.on('#authenticate', function (signedAuthToken, respond) {\n    self._processAuthToken(scSocket, signedAuthToken, function (err, isBadToken, oldState) {\n      if (err) {\n        if (isBadToken) {\n          scSocket.deauthenticate();\n        }\n      } else {\n        scSocket.triggerAuthenticationEvents(oldState);\n      }\n\n      var authStatus = {\n        isAuthenticated: !!scSocket.authToken,\n        authError: scErrors.dehydrateError(err)\n      };\n\n      if (err && isBadToken) {\n        respond(err, authStatus);\n      } else {\n        respond(null, authStatus);\n      }\n    });\n  });\n  scSocket.on('#removeAuthToken', function () {\n    scSocket.deauthenticateSelf();\n  });\n  scSocket.on('#subscribe', function (channelOptions, res) {\n    if (!channelOptions) {\n      channelOptions = {};\n    } else if (typeof channelOptions === 'string') {\n      channelOptions = {\n        channel: channelOptions\n      };\n    } // This is an invalid state; it means the client tried to subscribe before\n    // having completed the handshake.\n\n\n    if (scSocket.state === scSocket.OPEN) {\n      self._subscribeSocket(scSocket, channelOptions, function (err) {\n        if (err) {\n          var error = new BrokerError('Failed to subscribe socket to the ' + channelOptions.channel + ' channel - ' + err);\n          res(error);\n          Emitter.prototype.emit.call(scSocket, 'error', error);\n        } else {\n          if (channelOptions.batch) {\n            res(undefined, undefined, {\n              batch: true\n            });\n          } else {\n            res();\n          }\n        }\n      });\n    } else {\n      var error = new InvalidActionError('Cannot subscribe socket to a channel before it has completed the handshake');\n      res(error);\n      self.emit('warning', error);\n    }\n  });\n  scSocket.on('#unsubscribe', function (channel, res) {\n    var error;\n\n    try {\n      self._unsubscribeSocket(scSocket, channel);\n    } catch (err) {\n      error = new BrokerError('Failed to unsubscribe socket from the ' + channel + ' channel - ' + err.message);\n    }\n\n    if (error) {\n      res(error);\n      Emitter.prototype.emit.call(scSocket, 'error', error);\n    } else {\n      res();\n    }\n  });\n\n  var cleanupSocket = function cleanupSocket(type, code, data) {\n    clearTimeout(scSocket._handshakeTimeoutRef);\n    scSocket.off('#handshake');\n    scSocket.off('#authenticate');\n    scSocket.off('#removeAuthToken');\n    scSocket.off('#subscribe');\n    scSocket.off('#unsubscribe');\n    scSocket.off('authenticate');\n    scSocket.off('authStateChange');\n    scSocket.off('deauthenticate');\n    scSocket.off('_disconnect');\n    scSocket.off('_connectAbort');\n    var isClientFullyConnected = !!self.clients[id];\n\n    if (isClientFullyConnected) {\n      delete self.clients[id];\n      self.clientsCount--;\n    }\n\n    var isClientPending = !!self.pendingClients[id];\n\n    if (isClientPending) {\n      delete self.pendingClients[id];\n      self.pendingClientsCount--;\n    }\n\n    self._unsubscribeSocketFromAllChannels(scSocket);\n\n    if (type === 'disconnect') {\n      self.emit('_disconnection', scSocket, code, data);\n      self.emit('disconnection', scSocket, code, data);\n    } else if (type === 'abort') {\n      self.emit('_connectionAbort', scSocket, code, data);\n      self.emit('connectionAbort', scSocket, code, data);\n    }\n\n    self.emit('_closure', scSocket, code, data);\n    self.emit('closure', scSocket, code, data);\n  };\n\n  scSocket.once('_disconnect', cleanupSocket.bind(scSocket, 'disconnect'));\n  scSocket.once('_connectAbort', cleanupSocket.bind(scSocket, 'abort'));\n  scSocket._handshakeTimeoutRef = setTimeout(this._handleHandshakeTimeout.bind(this, scSocket), this.handshakeTimeout);\n  scSocket.once('#handshake', function (data, respond) {\n    if (!data) {\n      data = {};\n    }\n\n    var signedAuthToken = data.authToken || null;\n    clearTimeout(scSocket._handshakeTimeoutRef);\n\n    self._passThroughHandshakeSCMiddleware({\n      socket: scSocket\n    }, function (err, statusCode) {\n      if (err) {\n        var clientSocketErrorStatus = {\n          code: statusCode\n        };\n        respond(err, clientSocketErrorStatus);\n        scSocket.disconnect(statusCode);\n        return;\n      }\n\n      self._processAuthToken(scSocket, signedAuthToken, function (err, isBadToken, oldState) {\n        if (scSocket.state === scSocket.CLOSED) {\n          return;\n        }\n\n        var clientSocketStatus = {\n          id: scSocket.id,\n          pingTimeout: self.pingTimeout\n        };\n        var serverSocketStatus = {\n          id: scSocket.id,\n          pingTimeout: self.pingTimeout\n        };\n\n        if (err) {\n          if (signedAuthToken != null) {\n            // Because the token is optional as part of the handshake, we don't count\n            // it as an error if the token wasn't provided.\n            clientSocketStatus.authError = scErrors.dehydrateError(err);\n            serverSocketStatus.authError = err;\n\n            if (isBadToken) {\n              scSocket.deauthenticate();\n            }\n          }\n        }\n\n        clientSocketStatus.isAuthenticated = !!scSocket.authToken;\n        serverSocketStatus.isAuthenticated = clientSocketStatus.isAuthenticated;\n\n        if (self.pendingClients[id]) {\n          delete self.pendingClients[id];\n          self.pendingClientsCount--;\n        }\n\n        self.clients[id] = scSocket;\n        self.clientsCount++;\n        scSocket.state = scSocket.OPEN;\n        Emitter.prototype.emit.call(scSocket, 'connect', serverSocketStatus);\n        Emitter.prototype.emit.call(scSocket, '_connect', serverSocketStatus);\n        self.emit('_connection', scSocket, serverSocketStatus);\n        self.emit('connection', scSocket, serverSocketStatus);\n\n        if (clientSocketStatus.isAuthenticated) {\n          scSocket.triggerAuthenticationEvents(oldState);\n        } // Treat authentication failure as a 'soft' error\n\n\n        respond(null, clientSocketStatus);\n      });\n    });\n  }); // Emit event to signal that a socket handshake has been initiated.\n  // The _handshake event is for internal use (including third-party plugins)\n\n  this.emit('_handshake', scSocket);\n  this.emit('handshake', scSocket);\n};\n\nSCServer.prototype.close = function () {\n  this.isReady = false;\n  this.wsServer.close.apply(this.wsServer, arguments);\n};\n\nSCServer.prototype.getPath = function () {\n  return this._path;\n};\n\nSCServer.prototype.generateId = function () {\n  return base64id.generateId();\n};\n\nSCServer.prototype.addMiddleware = function (type, middleware) {\n  if (!this._middleware[type]) {\n    throw new InvalidArgumentsError(\"Middleware type \\\"\".concat(type, \"\\\" is not supported\")); // Read more: https://socketcluster.io/#!/docs/middleware-and-authorization\n  }\n\n  this._middleware[type].push(middleware);\n};\n\nSCServer.prototype.removeMiddleware = function (type, middleware) {\n  var middlewareFunctions = this._middleware[type];\n  this._middleware[type] = middlewareFunctions.filter(function (fn) {\n    return fn !== middleware;\n  });\n};\n\nSCServer.prototype.verifyHandshake = function (info, cb) {\n  var self = this;\n  var req = info.req;\n  var origin = info.origin;\n\n  if (origin === 'null' || origin == null) {\n    origin = '*';\n  }\n\n  var ok = false;\n\n  if (this._allowAllOrigins) {\n    ok = true;\n  } else {\n    try {\n      var parts = url.parse(origin);\n      parts.port = parts.port || (parts.protocol === 'https:' ? 443 : 80);\n      ok = ~this.origins.indexOf(parts.hostname + ':' + parts.port) || ~this.origins.indexOf(parts.hostname + ':*') || ~this.origins.indexOf('*:' + parts.port);\n    } catch (e) {}\n  }\n\n  if (ok) {\n    var handshakeMiddleware = this._middleware[this.MIDDLEWARE_HANDSHAKE_WS];\n\n    if (handshakeMiddleware.length) {\n      var callbackInvoked = false;\n      async.applyEachSeries(handshakeMiddleware, req)(function (err) {\n        if (callbackInvoked) {\n          self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_HANDSHAKE_WS + ' middleware was already invoked'));\n        } else {\n          callbackInvoked = true;\n\n          if (err) {\n            if (err === true || err.silent) {\n              err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_HANDSHAKE_WS + ' middleware', self.MIDDLEWARE_HANDSHAKE_WS);\n            } else if (self.middlewareEmitWarnings) {\n              self.emit('warning', err);\n            }\n\n            cb(false, 401, typeof err === 'string' ? err : err.message);\n          } else {\n            cb(true);\n          }\n        }\n      });\n    } else {\n      cb(true);\n    }\n  } else {\n    var err = new ServerProtocolError('Failed to authorize socket handshake - Invalid origin: ' + origin);\n    this.emit('warning', err);\n    cb(false, 403, err.message);\n  }\n};\n\nSCServer.prototype._isPrivateTransmittedEvent = function (event) {\n  return typeof event === 'string' && event.indexOf('#') === 0;\n};\n\nSCServer.prototype.verifyInboundEvent = function (socket, eventName, eventData, cb) {\n  var request = {\n    socket: socket,\n    event: eventName,\n    data: eventData\n  };\n  var token = socket.getAuthToken();\n\n  if (this.isAuthTokenExpired(token)) {\n    request.authTokenExpiredError = new AuthTokenExpiredError('The socket auth token has expired', token.exp);\n    socket.deauthenticate();\n  }\n\n  this._passThroughMiddleware(request, cb);\n};\n\nSCServer.prototype.isAuthTokenExpired = function (token) {\n  if (token && token.exp != null) {\n    var currentTime = Date.now();\n    var expiryMilliseconds = token.exp * 1000;\n    return currentTime > expiryMilliseconds;\n  }\n\n  return false;\n};\n\nSCServer.prototype._passThroughMiddleware = function (options, cb) {\n  var self = this;\n  var callbackInvoked = false;\n  var request = {\n    socket: options.socket\n  };\n\n  if (options.authTokenExpiredError != null) {\n    request.authTokenExpiredError = options.authTokenExpiredError;\n  }\n\n  var event = options.event;\n\n  if (this._isPrivateTransmittedEvent(event)) {\n    if (event === '#subscribe') {\n      var eventData = options.data || {};\n      request.channel = eventData.channel;\n      request.waitForAuth = eventData.waitForAuth;\n      request.data = eventData.data;\n\n      if (request.waitForAuth && request.authTokenExpiredError) {\n        // If the channel has the waitForAuth flag set, then we will handle the expiry quietly\n        // and we won't pass this request through the subscribe middleware.\n        cb(request.authTokenExpiredError, eventData);\n      } else {\n        async.applyEachSeries(this._middleware[this.MIDDLEWARE_SUBSCRIBE], request)(function (err) {\n          if (callbackInvoked) {\n            self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_SUBSCRIBE + ' middleware was already invoked'));\n          } else {\n            callbackInvoked = true;\n\n            if (err) {\n              if (err === true || err.silent) {\n                err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_SUBSCRIBE + ' middleware', self.MIDDLEWARE_SUBSCRIBE);\n              } else if (self.middlewareEmitWarnings) {\n                self.emit('warning', err);\n              }\n            }\n\n            if (request.data !== undefined) {\n              eventData.data = request.data;\n            }\n\n            cb(err, eventData);\n          }\n        });\n      }\n    } else if (event === '#publish') {\n      if (this.allowClientPublish) {\n        var eventData = options.data || {};\n        request.channel = eventData.channel;\n        request.data = eventData.data;\n        async.applyEachSeries(this._middleware[this.MIDDLEWARE_PUBLISH_IN], request)(function (err) {\n          if (callbackInvoked) {\n            self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_PUBLISH_IN + ' middleware was already invoked'));\n          } else {\n            callbackInvoked = true;\n\n            if (request.data !== undefined) {\n              eventData.data = request.data;\n            }\n\n            if (err) {\n              if (err === true || err.silent) {\n                err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_PUBLISH_IN + ' middleware', self.MIDDLEWARE_PUBLISH_IN);\n              } else if (self.middlewareEmitWarnings) {\n                self.emit('warning', err);\n              }\n\n              cb(err, eventData, request.ackData);\n            } else {\n              if (typeof request.channel !== 'string') {\n                err = new BrokerError('Socket ' + request.socket.id + ' tried to publish to an invalid ' + request.channel + ' channel');\n                self.emit('warning', err);\n                cb(err, eventData, request.ackData);\n                return;\n              }\n\n              self.exchange.publish(request.channel, request.data, function (err) {\n                if (err) {\n                  self.emit('warning', err);\n                }\n\n                cb(err, eventData, request.ackData);\n              });\n            }\n          }\n        });\n      } else {\n        var noPublishError = new InvalidActionError('Client publish feature is disabled');\n        self.emit('warning', noPublishError);\n        cb(noPublishError, options.data);\n      }\n    } else {\n      // Do not allow blocking other reserved events or it could interfere with SC behaviour\n      cb(null, options.data);\n    }\n  } else {\n    request.event = event;\n    request.data = options.data;\n    async.applyEachSeries(this._middleware[this.MIDDLEWARE_EMIT], request)(function (err) {\n      if (callbackInvoked) {\n        self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_EMIT + ' middleware was already invoked'));\n      } else {\n        callbackInvoked = true;\n\n        if (err) {\n          if (err === true || err.silent) {\n            err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_EMIT + ' middleware', self.MIDDLEWARE_EMIT);\n          } else if (self.middlewareEmitWarnings) {\n            self.emit('warning', err);\n          }\n        }\n\n        cb(err, request.data);\n      }\n    });\n  }\n};\n\nSCServer.prototype._passThroughAuthenticateMiddleware = function (options, cb) {\n  var self = this;\n  var callbackInvoked = false;\n  var request = {\n    socket: options.socket,\n    authToken: options.authToken\n  };\n  async.applyEachSeries(this._middleware[this.MIDDLEWARE_AUTHENTICATE], request)(function (err, results) {\n    if (callbackInvoked) {\n      self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_AUTHENTICATE + ' middleware was already invoked'));\n    } else {\n      callbackInvoked = true;\n      var isBadToken = false;\n\n      if (results.length) {\n        isBadToken = results[results.length - 1] || false;\n      }\n\n      if (err) {\n        if (err === true || err.silent) {\n          err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_AUTHENTICATE + ' middleware', self.MIDDLEWARE_AUTHENTICATE);\n        } else if (self.middlewareEmitWarnings) {\n          self.emit('warning', err);\n        }\n      }\n\n      cb(err, isBadToken);\n    }\n  });\n};\n\nSCServer.prototype._passThroughHandshakeSCMiddleware = function (options, cb) {\n  var self = this;\n  var callbackInvoked = false;\n  var request = {\n    socket: options.socket\n  };\n  async.applyEachSeries(this._middleware[this.MIDDLEWARE_HANDSHAKE_SC], request)(function (err, results) {\n    if (callbackInvoked) {\n      self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_HANDSHAKE_SC + ' middleware was already invoked'));\n    } else {\n      callbackInvoked = true;\n      var statusCode;\n\n      if (results.length) {\n        statusCode = results[results.length - 1] || 4008;\n      } else {\n        statusCode = 4008;\n      }\n\n      if (err) {\n        if (err.statusCode != null) {\n          statusCode = err.statusCode;\n        }\n\n        if (err === true || err.silent) {\n          err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_HANDSHAKE_SC + ' middleware', self.MIDDLEWARE_HANDSHAKE_SC);\n        } else if (self.middlewareEmitWarnings) {\n          self.emit('warning', err);\n        }\n      }\n\n      cb(err, statusCode);\n    }\n  });\n};\n\nSCServer.prototype.verifyOutboundEvent = function (socket, eventName, eventData, options, cb) {\n  var self = this;\n  var callbackInvoked = false;\n\n  if (eventName === '#publish') {\n    var request = {\n      socket: socket,\n      channel: eventData.channel,\n      data: eventData.data\n    };\n    async.applyEachSeries(this._middleware[this.MIDDLEWARE_PUBLISH_OUT], request)(function (err) {\n      if (callbackInvoked) {\n        self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_PUBLISH_OUT + ' middleware was already invoked'));\n      } else {\n        callbackInvoked = true;\n\n        if (request.data !== undefined) {\n          eventData.data = request.data;\n        }\n\n        if (err) {\n          if (err === true || err.silent) {\n            err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_PUBLISH_OUT + ' middleware', self.MIDDLEWARE_PUBLISH_OUT);\n          } else if (self.middlewareEmitWarnings) {\n            self.emit('warning', err);\n          }\n\n          cb(err, eventData);\n        } else {\n          if (options && request.useCache) {\n            options.useCache = true;\n          }\n\n          cb(null, eventData);\n        }\n      }\n    });\n  } else {\n    cb(null, eventData);\n  }\n};\n\nmodule.exports = SCServer;","map":{"version":3,"sources":["/home/lisk/doomonlisk/node_modules/socketcluster-server/scserver.js"],"names":["SCServerSocket","require","AuthEngine","formatter","EventEmitter","Emitter","base64id","async","url","crypto","uuid","SCSimpleBroker","scErrors","AuthTokenExpiredError","AuthTokenInvalidError","AuthTokenNotBeforeError","AuthTokenError","SilentMiddlewareBlockedError","InvalidArgumentsError","InvalidOptionsError","InvalidActionError","BrokerError","ServerProtocolError","SCServer","options","self","call","opts","brokerEngine","wsEngine","wsEngineServerOptions","maxPayload","allowClientPublish","ackTimeout","handshakeTimeout","strictHandshake","pingTimeout","pingTimeoutDisabled","pingInterval","origins","appName","v4","path","authDefaultExpiry","authSignAsync","authVerifyAsync","pubSubBatchDuration","middlewareEmitWarnings","i","hasOwnProperty","MIDDLEWARE_HANDSHAKE_WS","MIDDLEWARE_HANDSHAKE_SC","MIDDLEWARE_EMIT","MIDDLEWARE_SUBSCRIBE","MIDDLEWARE_PUBLISH_IN","MIDDLEWARE_PUBLISH_OUT","MIDDLEWARE_AUTHENTICATE","MIDDLEWARE_PUBLISH","_middleware","_allowAllOrigins","indexOf","perMessageDeflate","httpServer","socketChannelLimit","_path","replace","isReady","once","prototype","emit","Server","WSServer","authPrivateKey","authPublicKey","signatureKey","verificationKey","authKey","randomBytes","toString","defaultVerificationOptions","authVerifyAlgorithms","algorithms","authAlgorithm","defaultSignatureOptions","expiresIn","algorithm","authEngine","auth","codecEngine","codec","clients","clientsCount","pendingClients","pendingClientsCount","exchange","wsServerOptions","server","verifyClient","verifyHandshake","bind","handleProtocols","clientTracking","wsServer","on","_handleServerError","_handleSocketConnection","Object","create","setAuthEngine","setCodecEngine","error","_handleSocketError","_handleHandshakeTimeout","scSocket","disconnect","_subscribeSocket","socket","channelOptions","callback","id","channelSubscriptionsCount","channelName","channel","channelSubscriptions","subscribeSocket","err","_unsubscribeSocketFromAllChannels","channels","push","len","length","_unsubscribeSocket","unsubscribeSocket","_processTokenError","authError","isBadToken","name","message","expiredAt","date","_emitBadAuthTokenError","signedAuthToken","badAuthStatus","_processAuthToken","verificationOptions","assign","verifyToken","authToken","oldState","authState","AUTHENTICATED","UNAUTHENTICATED","_passThroughAuthenticateMiddleware","middlewareError","errorData","wsSocket","upgradeReq","generateId","respond","deauthenticate","triggerAuthenticationEvents","authStatus","isAuthenticated","dehydrateError","deauthenticateSelf","res","state","OPEN","batch","undefined","cleanupSocket","type","code","data","clearTimeout","_handshakeTimeoutRef","off","isClientFullyConnected","isClientPending","setTimeout","_passThroughHandshakeSCMiddleware","statusCode","clientSocketErrorStatus","CLOSED","clientSocketStatus","serverSocketStatus","close","apply","arguments","getPath","addMiddleware","middleware","removeMiddleware","middlewareFunctions","filter","fn","info","cb","req","origin","ok","parts","parse","port","protocol","hostname","e","handshakeMiddleware","callbackInvoked","applyEachSeries","silent","_isPrivateTransmittedEvent","event","verifyInboundEvent","eventName","eventData","request","token","getAuthToken","isAuthTokenExpired","authTokenExpiredError","exp","_passThroughMiddleware","currentTime","Date","now","expiryMilliseconds","waitForAuth","ackData","publish","noPublishError","results","verifyOutboundEvent","useCache","module","exports"],"mappings":"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","sourcesContent":["var SCServerSocket = require('./scserversocket');\nvar AuthEngine = require('sc-auth').AuthEngine;\nvar formatter = require('sc-formatter');\nvar EventEmitter = require('events').EventEmitter;\nvar Emitter = require('component-emitter');\nvar base64id = require('base64id');\nvar async = require('async');\nvar url = require('url');\nvar crypto = require('crypto');\nvar uuid = require('uuid');\nvar SCSimpleBroker = require('sc-simple-broker').SCSimpleBroker;\n\nvar scErrors = require('sc-errors');\nvar AuthTokenExpiredError = scErrors.AuthTokenExpiredError;\nvar AuthTokenInvalidError = scErrors.AuthTokenInvalidError;\nvar AuthTokenNotBeforeError = scErrors.AuthTokenNotBeforeError;\nvar AuthTokenError = scErrors.AuthTokenError;\nvar SilentMiddlewareBlockedError = scErrors.SilentMiddlewareBlockedError;\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\nvar InvalidOptionsError = scErrors.InvalidOptionsError;\nvar InvalidActionError = scErrors.InvalidActionError;\nvar BrokerError = scErrors.BrokerError;\nvar ServerProtocolError = scErrors.ServerProtocolError;\n\n\nvar SCServer = function (options) {\n  var self = this;\n\n  EventEmitter.call(this);\n\n  var opts = {\n    brokerEngine: new SCSimpleBroker(),\n    wsEngine: 'ws',\n    wsEngineServerOptions: {},\n    maxPayload: null,\n    allowClientPublish: true,\n    ackTimeout: 10000,\n    handshakeTimeout: 10000,\n    strictHandshake: true,\n    pingTimeout: 20000,\n    pingTimeoutDisabled: false,\n    pingInterval: 8000,\n    origins: '*:*',\n    appName: uuid.v4(),\n    path: '/socketcluster/',\n    authDefaultExpiry: 86400,\n    authSignAsync: false,\n    authVerifyAsync: true,\n    pubSubBatchDuration: null,\n    middlewareEmitWarnings: true\n  };\n\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n\n  this.options = opts;\n\n  this.MIDDLEWARE_HANDSHAKE_WS = 'handshakeWS';\n  this.MIDDLEWARE_HANDSHAKE_SC = 'handshakeSC';\n  this.MIDDLEWARE_EMIT = 'emit';\n  this.MIDDLEWARE_SUBSCRIBE = 'subscribe';\n  this.MIDDLEWARE_PUBLISH_IN = 'publishIn';\n  this.MIDDLEWARE_PUBLISH_OUT = 'publishOut';\n  this.MIDDLEWARE_AUTHENTICATE = 'authenticate';\n\n  // Deprecated\n  this.MIDDLEWARE_PUBLISH = this.MIDDLEWARE_PUBLISH_IN;\n\n  this._middleware = {};\n  this._middleware[this.MIDDLEWARE_HANDSHAKE_WS] = [];\n  this._middleware[this.MIDDLEWARE_HANDSHAKE_SC] = [];\n  this._middleware[this.MIDDLEWARE_EMIT] = [];\n  this._middleware[this.MIDDLEWARE_SUBSCRIBE] = [];\n  this._middleware[this.MIDDLEWARE_PUBLISH_IN] = [];\n  this._middleware[this.MIDDLEWARE_PUBLISH_OUT] = [];\n  this._middleware[this.MIDDLEWARE_AUTHENTICATE] = [];\n\n  this.origins = opts.origins;\n  this._allowAllOrigins = this.origins.indexOf('*:*') !== -1;\n\n  this.ackTimeout = opts.ackTimeout;\n  this.handshakeTimeout = opts.handshakeTimeout;\n  this.pingInterval = opts.pingInterval;\n  this.pingTimeout = opts.pingTimeout;\n  this.pingTimeoutDisabled = opts.pingTimeoutDisabled;\n  this.allowClientPublish = opts.allowClientPublish;\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.httpServer = opts.httpServer;\n  this.socketChannelLimit = opts.socketChannelLimit;\n  this.strictHandshake = opts.strictHandshake;\n\n  this.brokerEngine = opts.brokerEngine;\n  this.appName = opts.appName || '';\n  this.middlewareEmitWarnings = opts.middlewareEmitWarnings;\n\n  // Make sure there is always a leading and a trailing slash in the WS path.\n  this._path = opts.path.replace(/\\/?$/, '/').replace(/^\\/?/, '/');\n  this.isReady = false;\n\n  this.brokerEngine.once('ready', function () {\n    self.isReady = true;\n    EventEmitter.prototype.emit.call(self, 'ready');\n  });\n\n  var wsEngine = typeof opts.wsEngine === 'string' ? require(opts.wsEngine) : opts.wsEngine;\n  if (!wsEngine || !wsEngine.Server) {\n    throw new InvalidOptionsError('The wsEngine option must be a path or module name which points ' +\n      'to a valid WebSocket engine module with a compatible interface');\n  }\n  var WSServer = wsEngine.Server;\n\n  if (opts.authPrivateKey != null || opts.authPublicKey != null) {\n    if (opts.authPrivateKey == null) {\n      throw new InvalidOptionsError('The authPrivateKey option must be specified if authPublicKey is specified');\n    } else if (opts.authPublicKey == null) {\n      throw new InvalidOptionsError('The authPublicKey option must be specified if authPrivateKey is specified');\n    }\n    this.signatureKey = opts.authPrivateKey;\n    this.verificationKey = opts.authPublicKey;\n  } else {\n    if (opts.authKey == null) {\n      opts.authKey = crypto.randomBytes(32).toString('hex');\n    }\n    this.signatureKey = opts.authKey;\n    this.verificationKey = opts.authKey;\n  }\n\n  this.authVerifyAsync = opts.authVerifyAsync;\n  this.authSignAsync = opts.authSignAsync;\n\n  this.defaultVerificationOptions = {\n    async: this.authVerifyAsync\n  };\n  if (opts.authVerifyAlgorithms != null) {\n    this.defaultVerificationOptions.algorithms = opts.authVerifyAlgorithms;\n  } else if (opts.authAlgorithm != null) {\n    this.defaultVerificationOptions.algorithms = [opts.authAlgorithm];\n  }\n\n  this.defaultSignatureOptions = {\n    expiresIn: opts.authDefaultExpiry,\n    async: this.authSignAsync\n  };\n  if (opts.authAlgorithm != null) {\n    this.defaultSignatureOptions.algorithm = opts.authAlgorithm;\n  }\n\n  if (opts.authEngine) {\n    this.auth = opts.authEngine;\n  } else {\n    // Default authentication engine\n    this.auth = new AuthEngine();\n  }\n\n  if (opts.codecEngine) {\n    this.codec = opts.codecEngine;\n  } else {\n    // Default codec engine\n    this.codec = formatter;\n  }\n\n  this.clients = {};\n  this.clientsCount = 0;\n\n  this.pendingClients = {};\n  this.pendingClientsCount = 0;\n\n  this.exchange = this.brokerEngine.exchange();\n\n  var wsServerOptions = opts.wsEngineServerOptions || {};\n  wsServerOptions.server = this.httpServer;\n  wsServerOptions.verifyClient = this.verifyHandshake.bind(this);\n\n  if (wsServerOptions.path == null && this._path != null) {\n    wsServerOptions.path = this._path;\n  }\n  if (wsServerOptions.perMessageDeflate == null && this.perMessageDeflate != null) {\n    wsServerOptions.perMessageDeflate = this.perMessageDeflate;\n  }\n  if (wsServerOptions.handleProtocols == null && opts.handleProtocols != null) {\n    wsServerOptions.handleProtocols = opts.handleProtocols;\n  }\n  if (wsServerOptions.maxPayload == null && opts.maxPayload != null) {\n    wsServerOptions.maxPayload = opts.maxPayload;\n  }\n  if (wsServerOptions.clientTracking == null) {\n    wsServerOptions.clientTracking = false;\n  }\n\n  this.wsServer = new WSServer(wsServerOptions);\n\n  this.wsServer.on('error', this._handleServerError.bind(this));\n  this.wsServer.on('connection', this._handleSocketConnection.bind(this));\n};\n\nSCServer.prototype = Object.create(EventEmitter.prototype);\n\nSCServer.prototype.setAuthEngine = function (authEngine) {\n  this.auth = authEngine;\n};\n\nSCServer.prototype.setCodecEngine = function (codecEngine) {\n  this.codec = codecEngine;\n};\n\nSCServer.prototype._handleServerError = function (error) {\n  if (typeof error === 'string') {\n    error = new ServerProtocolError(error);\n  }\n  this.emit('error', error);\n};\n\nSCServer.prototype._handleSocketError = function (error) {\n  // We don't want to crash the entire worker on socket error\n  // so we emit it as a warning instead.\n  this.emit('warning', error);\n};\n\nSCServer.prototype._handleHandshakeTimeout = function (scSocket) {\n  scSocket.disconnect(4005);\n};\n\nSCServer.prototype._subscribeSocket = function (socket, channelOptions, callback) {\n  var self = this;\n\n  if (!channelOptions) {\n    callback && callback('Socket ' + socket.id + ' provided a malformated channel payload');\n    return;\n  }\n\n  if (this.socketChannelLimit && socket.channelSubscriptionsCount >= this.socketChannelLimit) {\n    callback && callback('Socket ' + socket.id + ' tried to exceed the channel subscription limit of ' +\n      this.socketChannelLimit);\n    return;\n  }\n\n  var channelName = channelOptions.channel;\n\n  if (typeof channelName !== 'string') {\n    callback && callback('Socket ' + socket.id + ' provided an invalid channel name');\n    return;\n  }\n\n  if (socket.channelSubscriptionsCount == null) {\n    socket.channelSubscriptionsCount = 0;\n  }\n  if (socket.channelSubscriptions[channelName] == null) {\n    socket.channelSubscriptions[channelName] = true;\n    socket.channelSubscriptionsCount++;\n  }\n\n  this.brokerEngine.subscribeSocket(socket, channelName, function (err) {\n    if (err) {\n      delete socket.channelSubscriptions[channelName];\n      socket.channelSubscriptionsCount--;\n    } else {\n      Emitter.prototype.emit.call(socket, 'subscribe', channelName, channelOptions);\n      self.emit('subscription', socket, channelName, channelOptions);\n    }\n    callback && callback(err);\n  });\n};\n\nSCServer.prototype._unsubscribeSocketFromAllChannels = function (socket) {\n  var channels = [];\n  for (var channel in socket.channelSubscriptions) {\n    if (socket.channelSubscriptions.hasOwnProperty(channel)) {\n      channels.push(channel);\n    }\n  }\n  var len = channels.length;\n  for (var i = 0; i < len; i++) {\n    this._unsubscribeSocket(socket, channels[i]);\n  }\n};\n\nSCServer.prototype._unsubscribeSocket = function (socket, channel) {\n  if (typeof channel !== 'string') {\n    throw new InvalidActionError('Socket ' + socket.id + ' tried to unsubscribe from an invalid channel name');\n  }\n  if (!socket.channelSubscriptions[channel]) {\n    throw new InvalidActionError('Socket ' + socket.id + ' tried to unsubscribe from a channel which it is not subscribed to');\n  }\n\n  delete socket.channelSubscriptions[channel];\n  if (socket.channelSubscriptionsCount != null) {\n    socket.channelSubscriptionsCount--;\n  }\n\n  this.brokerEngine.unsubscribeSocket(socket, channel);\n\n  Emitter.prototype.emit.call(socket, 'unsubscribe', channel);\n  this.emit('unsubscription', socket, channel);\n};\n\nSCServer.prototype._processTokenError = function (err) {\n  var authError = null;\n  var isBadToken = true;\n\n  if (err) {\n    if (err.name === 'TokenExpiredError') {\n      authError = new AuthTokenExpiredError(err.message, err.expiredAt);\n    } else if (err.name === 'JsonWebTokenError') {\n      authError = new AuthTokenInvalidError(err.message);\n    } else if (err.name === 'NotBeforeError') {\n      authError = new AuthTokenNotBeforeError(err.message, err.date);\n      // In this case, the token is good; it's just not active yet.\n      isBadToken = false;\n    } else {\n      authError = new AuthTokenError(err.message);\n    }\n  }\n\n  return {\n    authError: authError,\n    isBadToken: isBadToken\n  };\n};\n\nSCServer.prototype._emitBadAuthTokenError = function (scSocket, error, signedAuthToken) {\n  var badAuthStatus = {\n    authError: error,\n    signedAuthToken: signedAuthToken\n  };\n  Emitter.prototype.emit.call(scSocket, 'badAuthToken', badAuthStatus);\n  this.emit('badSocketAuthToken', scSocket, badAuthStatus);\n};\n\nSCServer.prototype._processAuthToken = function (scSocket, signedAuthToken, callback) {\n  var self = this;\n\n  var verificationOptions = Object.assign({socket: scSocket}, this.defaultVerificationOptions);\n  this.auth.verifyToken(signedAuthToken, this.verificationKey, verificationOptions, function (err, authToken) {\n    var oldState = scSocket.authState;\n    if (authToken) {\n      scSocket.signedAuthToken = signedAuthToken;\n      scSocket.authToken = authToken;\n      scSocket.authState = scSocket.AUTHENTICATED;\n    } else {\n      scSocket.signedAuthToken = null;\n      scSocket.authToken = null;\n      scSocket.authState = scSocket.UNAUTHENTICATED;\n    }\n\n    // If the socket is authenticated, pass it through the MIDDLEWARE_AUTHENTICATE middleware.\n    // If the token is bad, we will tell the client to remove it.\n    // If there is an error but the token is good, then we will send back a 'quiet' error instead\n    // (as part of the status object only).\n    if (scSocket.authToken) {\n      self._passThroughAuthenticateMiddleware({\n        socket: scSocket,\n        signedAuthToken: scSocket.signedAuthToken,\n        authToken: scSocket.authToken\n      }, function (middlewareError, isBadToken) {\n        if (middlewareError) {\n          scSocket.authToken = null;\n          scSocket.authState = scSocket.UNAUTHENTICATED;\n          if (isBadToken) {\n            self._emitBadAuthTokenError(scSocket, middlewareError, signedAuthToken);\n          }\n        }\n        // If an error is passed back from the authenticate middleware, it will be treated as a\n        // server warning and not a socket error.\n        callback(middlewareError, isBadToken || false, oldState);\n      });\n    } else {\n      var errorData = self._processTokenError(err);\n\n      // If the error is related to the JWT being badly formatted, then we will\n      // treat the error as a socket error.\n      if (err && signedAuthToken != null) {\n        Emitter.prototype.emit.call(scSocket, 'error', errorData.authError);\n        if (errorData.isBadToken) {\n          self._emitBadAuthTokenError(scSocket, errorData.authError, signedAuthToken);\n        }\n      }\n      callback(errorData.authError, errorData.isBadToken, oldState);\n    }\n  });\n};\n\nSCServer.prototype._handleSocketConnection = function (wsSocket, upgradeReq) {\n  var self = this;\n\n  if (this.options.wsEngine === 'ws') {\n    wsSocket.upgradeReq = upgradeReq;\n  }\n\n  var id = this.generateId();\n\n  var scSocket = new SCServerSocket(id, this, wsSocket);\n  scSocket.exchange = self.exchange;\n\n  scSocket.on('error', function (err) {\n    self._handleSocketError(err);\n  });\n\n  self.pendingClients[id] = scSocket;\n  self.pendingClientsCount++;\n\n  scSocket.on('#authenticate', function (signedAuthToken, respond) {\n    self._processAuthToken(scSocket, signedAuthToken, function (err, isBadToken, oldState) {\n      if (err) {\n        if (isBadToken) {\n          scSocket.deauthenticate();\n        }\n      } else {\n        scSocket.triggerAuthenticationEvents(oldState);\n      }\n      var authStatus = {\n        isAuthenticated: !!scSocket.authToken,\n        authError: scErrors.dehydrateError(err)\n      };\n      if (err && isBadToken) {\n        respond(err, authStatus);\n      } else {\n        respond(null, authStatus);\n      }\n    });\n  });\n\n  scSocket.on('#removeAuthToken', function () {\n    scSocket.deauthenticateSelf();\n  });\n\n  scSocket.on('#subscribe', function (channelOptions, res) {\n    if (!channelOptions) {\n      channelOptions = {};\n    } else if (typeof channelOptions === 'string') {\n      channelOptions = {\n        channel: channelOptions\n      };\n    }\n    // This is an invalid state; it means the client tried to subscribe before\n    // having completed the handshake.\n    if (scSocket.state === scSocket.OPEN) {\n      self._subscribeSocket(scSocket, channelOptions, function (err) {\n        if (err) {\n          var error = new BrokerError('Failed to subscribe socket to the ' + channelOptions.channel + ' channel - ' + err);\n          res(error);\n          Emitter.prototype.emit.call(scSocket, 'error', error);\n        } else {\n          if (channelOptions.batch) {\n            res(undefined, undefined, {batch: true});\n          } else {\n            res();\n          }\n        }\n      });\n    } else {\n      var error = new InvalidActionError('Cannot subscribe socket to a channel before it has completed the handshake');\n      res(error);\n      self.emit('warning', error);\n    }\n  });\n\n  scSocket.on('#unsubscribe', function (channel, res) {\n    var error;\n    try {\n      self._unsubscribeSocket(scSocket, channel);\n    } catch (err) {\n      error = new BrokerError('Failed to unsubscribe socket from the ' + channel + ' channel - ' + err.message);\n    }\n    if (error) {\n      res(error);\n      Emitter.prototype.emit.call(scSocket, 'error', error);\n    } else {\n      res();\n    }\n  });\n\n  var cleanupSocket = function (type, code, data) {\n    clearTimeout(scSocket._handshakeTimeoutRef);\n\n    scSocket.off('#handshake');\n    scSocket.off('#authenticate');\n    scSocket.off('#removeAuthToken');\n    scSocket.off('#subscribe');\n    scSocket.off('#unsubscribe');\n    scSocket.off('authenticate');\n    scSocket.off('authStateChange');\n    scSocket.off('deauthenticate');\n    scSocket.off('_disconnect');\n    scSocket.off('_connectAbort');\n\n    var isClientFullyConnected = !!self.clients[id];\n\n    if (isClientFullyConnected) {\n      delete self.clients[id];\n      self.clientsCount--;\n    }\n\n    var isClientPending = !!self.pendingClients[id];\n    if (isClientPending) {\n      delete self.pendingClients[id];\n      self.pendingClientsCount--;\n    }\n\n    self._unsubscribeSocketFromAllChannels(scSocket);\n\n    if (type === 'disconnect') {\n      self.emit('_disconnection', scSocket, code, data);\n      self.emit('disconnection', scSocket, code, data);\n    } else if (type === 'abort') {\n      self.emit('_connectionAbort', scSocket, code, data);\n      self.emit('connectionAbort', scSocket, code, data);\n    }\n    self.emit('_closure', scSocket, code, data);\n    self.emit('closure', scSocket, code, data);\n  };\n\n  scSocket.once('_disconnect', cleanupSocket.bind(scSocket, 'disconnect'));\n  scSocket.once('_connectAbort', cleanupSocket.bind(scSocket, 'abort'));\n\n  scSocket._handshakeTimeoutRef = setTimeout(this._handleHandshakeTimeout.bind(this, scSocket), this.handshakeTimeout);\n  scSocket.once('#handshake', function (data, respond) {\n    if (!data) {\n      data = {};\n    }\n    var signedAuthToken = data.authToken || null;\n    clearTimeout(scSocket._handshakeTimeoutRef);\n\n    self._passThroughHandshakeSCMiddleware({\n      socket: scSocket\n    }, function (err, statusCode) {\n      if (err) {\n        var clientSocketErrorStatus = {\n          code: statusCode\n        };\n        respond(err, clientSocketErrorStatus);\n        scSocket.disconnect(statusCode);\n        return;\n      }\n      self._processAuthToken(scSocket, signedAuthToken, function (err, isBadToken, oldState) {\n        if (scSocket.state === scSocket.CLOSED) {\n          return;\n        }\n\n        var clientSocketStatus = {\n          id: scSocket.id,\n          pingTimeout: self.pingTimeout\n        };\n        var serverSocketStatus = {\n          id: scSocket.id,\n          pingTimeout: self.pingTimeout\n        };\n\n        if (err) {\n          if (signedAuthToken != null) {\n            // Because the token is optional as part of the handshake, we don't count\n            // it as an error if the token wasn't provided.\n            clientSocketStatus.authError = scErrors.dehydrateError(err);\n            serverSocketStatus.authError = err;\n\n            if (isBadToken) {\n              scSocket.deauthenticate();\n            }\n          }\n        }\n        clientSocketStatus.isAuthenticated = !!scSocket.authToken;\n        serverSocketStatus.isAuthenticated = clientSocketStatus.isAuthenticated;\n\n        if (self.pendingClients[id]) {\n          delete self.pendingClients[id];\n          self.pendingClientsCount--;\n        }\n        self.clients[id] = scSocket;\n        self.clientsCount++;\n\n        scSocket.state = scSocket.OPEN;\n\n        Emitter.prototype.emit.call(scSocket, 'connect', serverSocketStatus);\n        Emitter.prototype.emit.call(scSocket, '_connect', serverSocketStatus);\n\n        self.emit('_connection', scSocket, serverSocketStatus);\n        self.emit('connection', scSocket, serverSocketStatus);\n\n        if (clientSocketStatus.isAuthenticated) {\n          scSocket.triggerAuthenticationEvents(oldState);\n        }\n        // Treat authentication failure as a 'soft' error\n        respond(null, clientSocketStatus);\n      });\n    });\n  });\n\n  // Emit event to signal that a socket handshake has been initiated.\n  // The _handshake event is for internal use (including third-party plugins)\n  this.emit('_handshake', scSocket);\n  this.emit('handshake', scSocket);\n};\n\nSCServer.prototype.close = function () {\n  this.isReady = false;\n  this.wsServer.close.apply(this.wsServer, arguments);\n};\n\nSCServer.prototype.getPath = function () {\n  return this._path;\n};\n\nSCServer.prototype.generateId = function () {\n  return base64id.generateId();\n};\n\nSCServer.prototype.addMiddleware = function (type, middleware) {\n  if (!this._middleware[type]) {\n    throw new InvalidArgumentsError(`Middleware type \"${type}\" is not supported`);\n    // Read more: https://socketcluster.io/#!/docs/middleware-and-authorization\n  }\n  this._middleware[type].push(middleware);\n};\n\nSCServer.prototype.removeMiddleware = function (type, middleware) {\n  var middlewareFunctions = this._middleware[type];\n\n  this._middleware[type] = middlewareFunctions.filter(function (fn) {\n    return fn !== middleware;\n  });\n};\n\nSCServer.prototype.verifyHandshake = function (info, cb) {\n  var self = this;\n\n  var req = info.req;\n  var origin = info.origin;\n  if (origin === 'null' || origin == null) {\n    origin = '*';\n  }\n  var ok = false;\n\n  if (this._allowAllOrigins) {\n    ok = true;\n  } else {\n    try {\n      var parts = url.parse(origin);\n      parts.port = parts.port || (parts.protocol === 'https:' ? 443 : 80);\n      ok = ~this.origins.indexOf(parts.hostname + ':' + parts.port) ||\n        ~this.origins.indexOf(parts.hostname + ':*') ||\n        ~this.origins.indexOf('*:' + parts.port);\n    } catch (e) {}\n  }\n\n  if (ok) {\n    var handshakeMiddleware = this._middleware[this.MIDDLEWARE_HANDSHAKE_WS];\n    if (handshakeMiddleware.length) {\n      var callbackInvoked = false;\n      async.applyEachSeries(handshakeMiddleware, req)(function (err) {\n        if (callbackInvoked) {\n          self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_HANDSHAKE_WS + ' middleware was already invoked'));\n        } else {\n          callbackInvoked = true;\n          if (err) {\n            if (err === true || err.silent) {\n              err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_HANDSHAKE_WS + ' middleware', self.MIDDLEWARE_HANDSHAKE_WS);\n            } else if (self.middlewareEmitWarnings) {\n              self.emit('warning', err);\n            }\n            cb(false, 401, typeof err === 'string' ? err : err.message);\n          } else {\n            cb(true);\n          }\n        }\n      });\n    } else {\n      cb(true);\n    }\n  } else {\n    var err = new ServerProtocolError('Failed to authorize socket handshake - Invalid origin: ' + origin);\n    this.emit('warning', err);\n    cb(false, 403, err.message);\n  }\n};\n\nSCServer.prototype._isPrivateTransmittedEvent = function (event) {\n  return typeof event === 'string' && event.indexOf('#') === 0;\n};\n\nSCServer.prototype.verifyInboundEvent = function (socket, eventName, eventData, cb) {\n  var request = {\n    socket: socket,\n    event: eventName,\n    data: eventData\n  };\n\n  var token = socket.getAuthToken();\n  if (this.isAuthTokenExpired(token)) {\n    request.authTokenExpiredError = new AuthTokenExpiredError('The socket auth token has expired', token.exp);\n\n    socket.deauthenticate();\n  }\n\n  this._passThroughMiddleware(request, cb);\n};\n\nSCServer.prototype.isAuthTokenExpired = function (token) {\n  if (token && token.exp != null) {\n    var currentTime = Date.now();\n    var expiryMilliseconds = token.exp * 1000;\n    return currentTime > expiryMilliseconds;\n  }\n  return false;\n};\n\nSCServer.prototype._passThroughMiddleware = function (options, cb) {\n  var self = this;\n\n  var callbackInvoked = false;\n\n  var request = {\n    socket: options.socket\n  };\n\n  if (options.authTokenExpiredError != null) {\n    request.authTokenExpiredError = options.authTokenExpiredError;\n  }\n\n  var event = options.event;\n\n  if (this._isPrivateTransmittedEvent(event)) {\n    if (event === '#subscribe') {\n      var eventData = options.data || {};\n      request.channel = eventData.channel;\n      request.waitForAuth = eventData.waitForAuth;\n      request.data = eventData.data;\n\n      if (request.waitForAuth && request.authTokenExpiredError) {\n        // If the channel has the waitForAuth flag set, then we will handle the expiry quietly\n        // and we won't pass this request through the subscribe middleware.\n        cb(request.authTokenExpiredError, eventData);\n      } else {\n        async.applyEachSeries(this._middleware[this.MIDDLEWARE_SUBSCRIBE], request)(\n          function (err) {\n            if (callbackInvoked) {\n              self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_SUBSCRIBE + ' middleware was already invoked'));\n            } else {\n              callbackInvoked = true;\n              if (err) {\n                if (err === true || err.silent) {\n                  err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_SUBSCRIBE + ' middleware', self.MIDDLEWARE_SUBSCRIBE);\n                } else if (self.middlewareEmitWarnings) {\n                  self.emit('warning', err);\n                }\n              }\n              if (request.data !== undefined) {\n                eventData.data = request.data;\n              }\n              cb(err, eventData);\n            }\n          }\n        );\n      }\n    } else if (event === '#publish') {\n      if (this.allowClientPublish) {\n        var eventData = options.data || {};\n        request.channel = eventData.channel;\n        request.data = eventData.data;\n\n        async.applyEachSeries(this._middleware[this.MIDDLEWARE_PUBLISH_IN], request)(\n          function (err) {\n            if (callbackInvoked) {\n              self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_PUBLISH_IN + ' middleware was already invoked'));\n            } else {\n              callbackInvoked = true;\n              if (request.data !== undefined) {\n                eventData.data = request.data;\n              }\n              if (err) {\n                if (err === true || err.silent) {\n                  err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_PUBLISH_IN + ' middleware', self.MIDDLEWARE_PUBLISH_IN);\n                } else if (self.middlewareEmitWarnings) {\n                  self.emit('warning', err);\n                }\n                cb(err, eventData, request.ackData);\n              } else {\n                if (typeof request.channel !== 'string') {\n                  err = new BrokerError('Socket ' + request.socket.id + ' tried to publish to an invalid ' + request.channel + ' channel');\n                  self.emit('warning', err);\n                  cb(err, eventData, request.ackData);\n                  return;\n                }\n                self.exchange.publish(request.channel, request.data, function (err) {\n                  if (err) {\n                    self.emit('warning', err);\n                  }\n                  cb(err, eventData, request.ackData);\n                });\n              }\n            }\n          }\n        );\n      } else {\n        var noPublishError = new InvalidActionError('Client publish feature is disabled');\n        self.emit('warning', noPublishError);\n        cb(noPublishError, options.data);\n      }\n    } else {\n      // Do not allow blocking other reserved events or it could interfere with SC behaviour\n      cb(null, options.data);\n    }\n  } else {\n    request.event = event;\n    request.data = options.data;\n\n    async.applyEachSeries(this._middleware[this.MIDDLEWARE_EMIT], request)(\n      function (err) {\n        if (callbackInvoked) {\n          self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_EMIT + ' middleware was already invoked'));\n        } else {\n          callbackInvoked = true;\n          if (err) {\n            if (err === true || err.silent) {\n              err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_EMIT + ' middleware', self.MIDDLEWARE_EMIT);\n            } else if (self.middlewareEmitWarnings) {\n              self.emit('warning', err);\n            }\n          }\n          cb(err, request.data);\n        }\n      }\n    );\n  }\n};\n\nSCServer.prototype._passThroughAuthenticateMiddleware = function (options, cb) {\n  var self = this;\n  var callbackInvoked = false;\n\n  var request = {\n    socket: options.socket,\n    authToken: options.authToken\n  };\n\n  async.applyEachSeries(this._middleware[this.MIDDLEWARE_AUTHENTICATE], request)(\n    function (err, results) {\n      if (callbackInvoked) {\n        self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_AUTHENTICATE + ' middleware was already invoked'));\n      } else {\n        callbackInvoked = true;\n        var isBadToken = false;\n        if (results.length) {\n          isBadToken = results[results.length - 1] || false;\n        }\n        if (err) {\n          if (err === true || err.silent) {\n            err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_AUTHENTICATE + ' middleware', self.MIDDLEWARE_AUTHENTICATE);\n          } else if (self.middlewareEmitWarnings) {\n            self.emit('warning', err);\n          }\n        }\n        cb(err, isBadToken);\n      }\n    }\n  );\n};\n\nSCServer.prototype._passThroughHandshakeSCMiddleware = function (options, cb) {\n  var self = this;\n  var callbackInvoked = false;\n\n  var request = {\n    socket: options.socket\n  };\n\n  async.applyEachSeries(this._middleware[this.MIDDLEWARE_HANDSHAKE_SC], request)(\n    function (err, results) {\n      if (callbackInvoked) {\n        self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_HANDSHAKE_SC + ' middleware was already invoked'));\n      } else {\n        callbackInvoked = true;\n        var statusCode;\n        if (results.length) {\n          statusCode = results[results.length - 1] || 4008;\n        } else {\n          statusCode = 4008;\n        }\n        if (err) {\n          if (err.statusCode != null) {\n            statusCode = err.statusCode;\n          }\n          if (err === true || err.silent) {\n            err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_HANDSHAKE_SC + ' middleware', self.MIDDLEWARE_HANDSHAKE_SC);\n          } else if (self.middlewareEmitWarnings) {\n            self.emit('warning', err);\n          }\n        }\n        cb(err, statusCode);\n      }\n    }\n  );\n};\n\nSCServer.prototype.verifyOutboundEvent = function (socket, eventName, eventData, options, cb) {\n  var self = this;\n\n  var callbackInvoked = false;\n\n  if (eventName === '#publish') {\n    var request = {\n      socket: socket,\n      channel: eventData.channel,\n      data: eventData.data\n    };\n    async.applyEachSeries(this._middleware[this.MIDDLEWARE_PUBLISH_OUT], request)(\n      function (err) {\n        if (callbackInvoked) {\n          self.emit('warning', new InvalidActionError('Callback for ' + self.MIDDLEWARE_PUBLISH_OUT + ' middleware was already invoked'));\n        } else {\n          callbackInvoked = true;\n          if (request.data !== undefined) {\n            eventData.data = request.data;\n          }\n          if (err) {\n            if (err === true || err.silent) {\n              err = new SilentMiddlewareBlockedError('Action was silently blocked by ' + self.MIDDLEWARE_PUBLISH_OUT + ' middleware', self.MIDDLEWARE_PUBLISH_OUT);\n            } else if (self.middlewareEmitWarnings) {\n              self.emit('warning', err);\n            }\n            cb(err, eventData);\n          } else {\n            if (options && request.useCache) {\n              options.useCache = true;\n            }\n            cb(null, eventData);\n          }\n        }\n      }\n    );\n  } else {\n    cb(null, eventData);\n  }\n};\n\nmodule.exports = SCServer;\n"]},"metadata":{},"sourceType":"script"}