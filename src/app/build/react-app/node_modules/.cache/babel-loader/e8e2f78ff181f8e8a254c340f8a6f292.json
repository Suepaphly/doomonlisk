{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseList = void 0;\n\nvar errors_1 = require(\"../errors\");\n\nvar utils_1 = require(\"../utils\");\n\nvar BaseList = /*#__PURE__*/function () {\n  function BaseList(_ref) {\n    var bucketSize = _ref.bucketSize,\n        numOfBuckets = _ref.numOfBuckets,\n        secret = _ref.secret,\n        peerType = _ref.peerType;\n\n    _classCallCheck(this, BaseList);\n\n    this.peerListConfig = {\n      bucketSize: bucketSize,\n      numOfBuckets: numOfBuckets,\n      peerType: peerType,\n      secret: secret\n    };\n    this.bucketIdToBucket = new Map();\n\n    this._initBuckets();\n\n    this.peerIdToPeerInfo = new Map();\n  }\n\n  _createClass(BaseList, [{\n    key: \"peerList\",\n    get: function get() {\n      var peerListMap = [];\n\n      for (var _i = 0, _arr = _toConsumableArray(this.bucketIdToBucket.values()); _i < _arr.length; _i++) {\n        var peerList = _arr[_i];\n\n        for (var _i2 = 0, _arr2 = _toConsumableArray(peerList.values()); _i2 < _arr2.length; _i2++) {\n          var peer = _arr2[_i2];\n          peerListMap.push(utils_1.sanitizeEnhancedPeerInfo(peer));\n        }\n      }\n\n      return peerListMap;\n    }\n  }, {\n    key: \"hasPeer\",\n    value: function hasPeer(incomingPeerId) {\n      return this.peerIdToPeerInfo.has(incomingPeerId);\n    }\n  }, {\n    key: \"addPeer\",\n    value: function addPeer(incomingPeerInfo) {\n      if (this.hasPeer(incomingPeerInfo.peerId)) {\n        throw new errors_1.ExistingPeerError(incomingPeerInfo);\n      }\n\n      var _this$calculateBucket = this.calculateBucket(incomingPeerInfo.ipAddress, this.type === utils_1.PEER_TYPE.NEW_PEER ? incomingPeerInfo.sourceAddress : undefined),\n          bucketId = _this$calculateBucket.bucketId,\n          bucket = _this$calculateBucket.bucket;\n\n      var evictedPeer = bucket.size >= this.peerListConfig.bucketSize ? this.makeSpace(bucket) : undefined;\n\n      var internalPeerInfo = _objectSpread(_objectSpread({}, incomingPeerInfo), {}, {\n        numOfConnectionFailures: 0,\n        dateAdded: new Date(),\n        bucketId: bucketId\n      });\n\n      bucket.set(incomingPeerInfo.peerId, internalPeerInfo);\n      this.peerIdToPeerInfo.set(incomingPeerInfo.peerId, internalPeerInfo);\n      return evictedPeer;\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer(incomingPeerId) {\n      var peerInfo = this.peerIdToPeerInfo.get(incomingPeerId);\n\n      if (!peerInfo) {\n        return undefined;\n      }\n\n      return utils_1.sanitizeEnhancedPeerInfo(peerInfo);\n    }\n  }, {\n    key: \"updatePeer\",\n    value: function updatePeer(incomingPeerInfo) {\n      var bucket = this.getBucket(incomingPeerInfo.peerId);\n\n      if (!bucket) {\n        return false;\n      }\n\n      var updatedInternalPeerInfo = _objectSpread(_objectSpread({}, bucket.get(incomingPeerInfo.peerId)), incomingPeerInfo);\n\n      bucket.set(incomingPeerInfo.peerId, updatedInternalPeerInfo);\n      this.peerIdToPeerInfo.set(incomingPeerInfo.peerId, updatedInternalPeerInfo);\n      return true;\n    }\n  }, {\n    key: \"removePeer\",\n    value: function removePeer(incomingPeerInfo) {\n      var bucket = this.getBucket(incomingPeerInfo.peerId);\n\n      if (bucket === null || bucket === void 0 ? void 0 : bucket.has(incomingPeerInfo.peerId)) {\n        var removedFromBucket = bucket.delete(incomingPeerInfo.peerId);\n        var removedFromPeerLookup = this.peerIdToPeerInfo.delete(incomingPeerInfo.peerId);\n        return removedFromBucket && removedFromPeerLookup;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"makeSpace\",\n    value: function makeSpace(bucket) {\n      return utils_1.evictPeerRandomlyFromBucket(bucket);\n    }\n  }, {\n    key: \"failedConnectionAction\",\n    value: function failedConnectionAction(incomingPeerInfo) {\n      return this.removePeer(incomingPeerInfo);\n    }\n  }, {\n    key: \"calculateBucket\",\n    value: function calculateBucket(targetAddress, sourceAddress) {\n      var bucketId = utils_1.getBucketId({\n        secret: this.peerListConfig.secret,\n        peerType: this.peerListConfig.peerType,\n        targetAddress: targetAddress,\n        sourceAddress: this.type === utils_1.PEER_TYPE.NEW_PEER ? sourceAddress : undefined,\n        bucketCount: this.peerListConfig.numOfBuckets\n      });\n      return {\n        bucketId: bucketId,\n        bucket: this.bucketIdToBucket.get(bucketId)\n      };\n    }\n  }, {\n    key: \"getBucket\",\n    value: function getBucket(peerId) {\n      var internalPeerInfo = this.peerIdToPeerInfo.get(peerId);\n\n      if (typeof (internalPeerInfo === null || internalPeerInfo === void 0 ? void 0 : internalPeerInfo.bucketId) !== 'number') {\n        return undefined;\n      }\n\n      var bucket = this.bucketIdToBucket.get(internalPeerInfo.bucketId);\n\n      if (!bucket) {\n        return undefined;\n      }\n\n      return bucket;\n    }\n  }, {\n    key: \"_initBuckets\",\n    value: function _initBuckets() {\n      for (var _i3 = 0, _arr3 = _toConsumableArray(new Array(this.peerListConfig.numOfBuckets).keys()); _i3 < _arr3.length; _i3++) {\n        var bucketId = _arr3[_i3];\n        this.bucketIdToBucket.set(bucketId, new Map());\n      }\n    }\n  }]);\n\n  return BaseList;\n}();\n\nexports.BaseList = BaseList;","map":{"version":3,"sources":["../../src/peer_book/base_list.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BaseList = void 0;\nconst errors_1 = require(\"../errors\");\nconst utils_1 = require(\"../utils\");\nclass BaseList {\n    constructor({ bucketSize, numOfBuckets, secret, peerType }) {\n        this.peerListConfig = {\n            bucketSize,\n            numOfBuckets,\n            peerType,\n            secret,\n        };\n        this.bucketIdToBucket = new Map();\n        this._initBuckets();\n        this.peerIdToPeerInfo = new Map();\n    }\n    get peerList() {\n        const peerListMap = [];\n        for (const peerList of [...this.bucketIdToBucket.values()]) {\n            for (const peer of [...peerList.values()]) {\n                peerListMap.push(utils_1.sanitizeEnhancedPeerInfo(peer));\n            }\n        }\n        return peerListMap;\n    }\n    hasPeer(incomingPeerId) {\n        return this.peerIdToPeerInfo.has(incomingPeerId);\n    }\n    addPeer(incomingPeerInfo) {\n        if (this.hasPeer(incomingPeerInfo.peerId)) {\n            throw new errors_1.ExistingPeerError(incomingPeerInfo);\n        }\n        const { bucketId, bucket } = this.calculateBucket(incomingPeerInfo.ipAddress, this.type === utils_1.PEER_TYPE.NEW_PEER ? incomingPeerInfo.sourceAddress : undefined);\n        const evictedPeer = bucket.size >= this.peerListConfig.bucketSize ? this.makeSpace(bucket) : undefined;\n        const internalPeerInfo = {\n            ...incomingPeerInfo,\n            numOfConnectionFailures: 0,\n            dateAdded: new Date(),\n            bucketId,\n        };\n        bucket.set(incomingPeerInfo.peerId, internalPeerInfo);\n        this.peerIdToPeerInfo.set(incomingPeerInfo.peerId, internalPeerInfo);\n        return evictedPeer;\n    }\n    getPeer(incomingPeerId) {\n        const peerInfo = this.peerIdToPeerInfo.get(incomingPeerId);\n        if (!peerInfo) {\n            return undefined;\n        }\n        return utils_1.sanitizeEnhancedPeerInfo(peerInfo);\n    }\n    updatePeer(incomingPeerInfo) {\n        const bucket = this.getBucket(incomingPeerInfo.peerId);\n        if (!bucket) {\n            return false;\n        }\n        const updatedInternalPeerInfo = {\n            ...bucket.get(incomingPeerInfo.peerId),\n            ...incomingPeerInfo,\n        };\n        bucket.set(incomingPeerInfo.peerId, updatedInternalPeerInfo);\n        this.peerIdToPeerInfo.set(incomingPeerInfo.peerId, updatedInternalPeerInfo);\n        return true;\n    }\n    removePeer(incomingPeerInfo) {\n        const bucket = this.getBucket(incomingPeerInfo.peerId);\n        if (bucket === null || bucket === void 0 ? void 0 : bucket.has(incomingPeerInfo.peerId)) {\n            const removedFromBucket = bucket.delete(incomingPeerInfo.peerId);\n            const removedFromPeerLookup = this.peerIdToPeerInfo.delete(incomingPeerInfo.peerId);\n            return removedFromBucket && removedFromPeerLookup;\n        }\n        return false;\n    }\n    makeSpace(bucket) {\n        return utils_1.evictPeerRandomlyFromBucket(bucket);\n    }\n    failedConnectionAction(incomingPeerInfo) {\n        return this.removePeer(incomingPeerInfo);\n    }\n    calculateBucket(targetAddress, sourceAddress) {\n        const bucketId = utils_1.getBucketId({\n            secret: this.peerListConfig.secret,\n            peerType: this.peerListConfig.peerType,\n            targetAddress,\n            sourceAddress: this.type === utils_1.PEER_TYPE.NEW_PEER ? sourceAddress : undefined,\n            bucketCount: this.peerListConfig.numOfBuckets,\n        });\n        return { bucketId, bucket: this.bucketIdToBucket.get(bucketId) };\n    }\n    getBucket(peerId) {\n        const internalPeerInfo = this.peerIdToPeerInfo.get(peerId);\n        if (typeof (internalPeerInfo === null || internalPeerInfo === void 0 ? void 0 : internalPeerInfo.bucketId) !== 'number') {\n            return undefined;\n        }\n        const bucket = this.bucketIdToBucket.get(internalPeerInfo.bucketId);\n        if (!bucket) {\n            return undefined;\n        }\n        return bucket;\n    }\n    _initBuckets() {\n        for (const bucketId of [...new Array(this.peerListConfig.numOfBuckets).keys()]) {\n            this.bucketIdToBucket.set(bucketId, new Map());\n        }\n    }\n}\nexports.BaseList = BaseList;\n//# sourceMappingURL=base_list.js.map"]},"metadata":{},"sourceType":"script"}