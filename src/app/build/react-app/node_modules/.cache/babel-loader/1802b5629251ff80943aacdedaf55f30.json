{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validator = exports.liskSchemaIdentifier = void 0;\n\nvar ajv_1 = require(\"ajv\");\n\nvar ajv_formats_1 = require(\"ajv-formats\");\n\nvar formats = require(\"./formats\");\n\nvar errors_1 = require(\"./errors\");\n\nvar field_number_1 = require(\"./keywords/field_number\");\n\nvar data_type_1 = require(\"./keywords/data_type\");\n\nvar lisk_meta_schema_1 = require(\"./lisk_meta_schema\");\n\nexports.liskSchemaIdentifier = lisk_meta_schema_1.liskMetaSchema.$id;\n\nvar LiskValidator = /*#__PURE__*/function () {\n  function LiskValidator() {\n    _classCallCheck(this, LiskValidator);\n\n    this._validator = new ajv_1.default({\n      strict: true,\n      strictSchema: true,\n      allErrors: true,\n      useDefaults: false,\n      addUsedSchema: false,\n      strictTypes: false\n    });\n    ajv_formats_1.default(this._validator);\n\n    for (var _i = 0, _Object$keys = Object.keys(formats); _i < _Object$keys.length; _i++) {\n      var formatName = _Object$keys[_i];\n\n      this._validator.addFormat(formatName, formats[formatName]);\n    }\n\n    this._validator.addKeyword({\n      keyword: 'uniqueSignedPublicKeys',\n      type: 'array',\n      compile: function compile() {\n        return function (data) {\n          return new Set(data.filter(function (datum) {\n            return typeof datum === 'string';\n          }).map(function (key) {\n            return key.slice(1);\n          })).size === data.length;\n        };\n      }\n    });\n\n    this._validator.compile(lisk_meta_schema_1.liskMetaSchema);\n\n    this._validator.addMetaSchema(lisk_meta_schema_1.liskMetaSchema);\n\n    this._validator.addKeyword(field_number_1.fieldNumberKeyword);\n\n    this._validator.addKeyword(data_type_1.dataTypeKeyword);\n  }\n\n  _createClass(LiskValidator, [{\n    key: \"validate\",\n    value: function validate(schema, data) {\n      if (!this._validator.validate(schema, data)) {\n        return errors_1.convertErrorsToLegacyFormat(this._validator.errors);\n      }\n\n      return [];\n    }\n  }, {\n    key: \"validateSchema\",\n    value: function validateSchema(schema) {\n      if (!this._validator.validateSchema(schema)) {\n        return errors_1.convertErrorsToLegacyFormat(this._validator.errors);\n      }\n\n      return [];\n    }\n  }, {\n    key: \"compile\",\n    value: function compile(schema) {\n      try {\n        return this._validator.compile(schema);\n      } catch (error) {\n        if (error instanceof errors_1.LiskValidationError) {\n          throw error;\n        }\n\n        throw new errors_1.LiskValidationError([{\n          message: error.message.toString(),\n          dataPath: '',\n          keyword: '',\n          schemaPath: '',\n          params: {}\n        }]);\n      }\n    }\n  }, {\n    key: \"removeSchema\",\n    value: function removeSchema(schemaKeyRef) {\n      return this._validator.removeSchema(schemaKeyRef);\n    }\n  }]);\n\n  return LiskValidator;\n}();\n\nexports.validator = new LiskValidator();","map":{"version":3,"sources":["../src/lisk_validator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validator = exports.liskSchemaIdentifier = void 0;\nconst ajv_1 = require(\"ajv\");\nconst ajv_formats_1 = require(\"ajv-formats\");\nconst formats = require(\"./formats\");\nconst errors_1 = require(\"./errors\");\nconst field_number_1 = require(\"./keywords/field_number\");\nconst data_type_1 = require(\"./keywords/data_type\");\nconst lisk_meta_schema_1 = require(\"./lisk_meta_schema\");\nexports.liskSchemaIdentifier = lisk_meta_schema_1.liskMetaSchema.$id;\nclass LiskValidator {\n    constructor() {\n        this._validator = new ajv_1.default({\n            strict: true,\n            strictSchema: true,\n            allErrors: true,\n            useDefaults: false,\n            addUsedSchema: false,\n            strictTypes: false,\n        });\n        ajv_formats_1.default(this._validator);\n        for (const formatName of Object.keys(formats)) {\n            this._validator.addFormat(formatName, formats[formatName]);\n        }\n        this._validator.addKeyword({\n            keyword: 'uniqueSignedPublicKeys',\n            type: 'array',\n            compile: () => (data) => new Set(data.filter(datum => typeof datum === 'string').map((key) => key.slice(1)))\n                .size === data.length,\n        });\n        this._validator.compile(lisk_meta_schema_1.liskMetaSchema);\n        this._validator.addMetaSchema(lisk_meta_schema_1.liskMetaSchema);\n        this._validator.addKeyword(field_number_1.fieldNumberKeyword);\n        this._validator.addKeyword(data_type_1.dataTypeKeyword);\n    }\n    validate(schema, data) {\n        if (!this._validator.validate(schema, data)) {\n            return errors_1.convertErrorsToLegacyFormat(this._validator.errors);\n        }\n        return [];\n    }\n    validateSchema(schema) {\n        if (!this._validator.validateSchema(schema)) {\n            return errors_1.convertErrorsToLegacyFormat(this._validator.errors);\n        }\n        return [];\n    }\n    compile(schema) {\n        try {\n            return this._validator.compile(schema);\n        }\n        catch (error) {\n            if (error instanceof errors_1.LiskValidationError) {\n                throw error;\n            }\n            throw new errors_1.LiskValidationError([\n                {\n                    message: error.message.toString(),\n                    dataPath: '',\n                    keyword: '',\n                    schemaPath: '',\n                    params: {},\n                },\n            ]);\n        }\n    }\n    removeSchema(schemaKeyRef) {\n        return this._validator.removeSchema(schemaKeyRef);\n    }\n}\nexports.validator = new LiskValidator();\n//# sourceMappingURL=lisk_validator.js.map"]},"metadata":{},"sourceType":"script"}