{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPairLocation = exports.getBinary = exports.getBinaryString = exports.getLayerStructure = exports.getMaxIdxAtLayer = exports.generateHash = exports.isLeaf = void 0;\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar constants_1 = require(\"./constants\");\n\nvar isLeaf = function isLeaf(value) {\n  return value[0] === constants_1.LEAF_PREFIX[0];\n};\n\nexports.isLeaf = isLeaf;\n\nvar generateHash = function generateHash(prefix, leftHash, rightHash) {\n  return lisk_cryptography_1.hash(Buffer.concat([prefix, leftHash, rightHash], prefix.length + leftHash.length + rightHash.length));\n};\n\nexports.generateHash = generateHash;\n\nvar getMaxIdxAtLayer = function getMaxIdxAtLayer(layer, dataLength) {\n  var max = dataLength,\n      r = 0;\n\n  for (var i = 0; i < layer; i += 1) {\n    var _ref = [[Math.floor, Math.ceil][r % 2](max / 2), r + max % 2];\n    max = _ref[0];\n    r = _ref[1];\n  }\n\n  return max;\n};\n\nexports.getMaxIdxAtLayer = getMaxIdxAtLayer;\n\nvar getLayerStructure = function getLayerStructure(dataLength) {\n  var structure = [];\n\n  for (var i = 0; i <= Math.ceil(Math.log2(dataLength)); i += 1) {\n    structure.push(exports.getMaxIdxAtLayer(i, dataLength));\n  }\n\n  return structure;\n};\n\nexports.getLayerStructure = getLayerStructure;\n\nvar getBinaryString = function getBinaryString(num, length) {\n  if (length === 0) {\n    return '';\n  }\n\n  var binaryString = num.toString(2);\n\n  while (binaryString.length < length) {\n    binaryString = \"0\".concat(binaryString);\n  }\n\n  return binaryString;\n};\n\nexports.getBinaryString = getBinaryString;\n\nvar getBinary = function getBinary(num, length) {\n  var binaryString = exports.getBinaryString(num, length);\n  return binaryString.split('').map(function (d) {\n    return parseInt(d, 10);\n  });\n};\n\nexports.getBinary = getBinary;\n\nvar getPairLocation = function getPairLocation(nodeInfo) {\n  var layerIndex = nodeInfo.layerIndex,\n      nodeIndex = nodeInfo.nodeIndex,\n      dataLength = nodeInfo.dataLength;\n  var treeHeight = Math.ceil(Math.log2(dataLength)) + 1;\n  var layerStructure = exports.getLayerStructure(dataLength);\n  var numberOfNodesInLayer = layerStructure[layerIndex];\n  var binary = exports.getBinary(nodeIndex, treeHeight - layerIndex);\n  var side = [0, 1][binary[binary.length - 1]];\n  var pairSide = side === 0 ? 1 : 0;\n\n  if (layerIndex + 1 === treeHeight) {\n    return {\n      layerIndex: treeHeight - 1,\n      nodeIndex: 0\n    };\n  }\n\n  if (side === 0 && nodeIndex < numberOfNodesInLayer - 1) {\n    var pairNodeIndex = nodeIndex + 1;\n    return {\n      layerIndex: layerIndex,\n      nodeIndex: pairNodeIndex,\n      side: pairSide\n    };\n  }\n\n  if (side === 1 && (numberOfNodesInLayer % 2 === 0 && nodeIndex === numberOfNodesInLayer - 1 || nodeIndex < numberOfNodesInLayer - 1 && nodeIndex < numberOfNodesInLayer - 1)) {\n    var _pairNodeIndex = nodeIndex - 1;\n\n    return {\n      layerIndex: layerIndex,\n      nodeIndex: _pairNodeIndex,\n      side: pairSide\n    };\n  }\n\n  var currentLayer = layerIndex;\n  var numOfOddLayers = layerStructure.slice(0, currentLayer).filter(function (num) {\n    return num % 2 !== 0;\n  }).reduce(function (acc, val) {\n    return acc + val;\n  }, 0);\n  var direction = numOfOddLayers % 2 === 0 ? 1 : -1;\n  var pairLocation;\n  currentLayer += direction;\n\n  while (currentLayer >= 0 && currentLayer <= treeHeight - 1) {\n    if (layerStructure[currentLayer] % 2 !== 0) {\n      var _pairNodeIndex2 = direction === 1 ? layerStructure[currentLayer] + direction * -1 : layerStructure[currentLayer] - direction * -1;\n\n      pairLocation = {\n        layerIndex: currentLayer,\n        nodeIndex: _pairNodeIndex2,\n        side: direction === -1 ? 1 : 0\n      };\n      break;\n    }\n\n    currentLayer += direction;\n  }\n\n  return pairLocation;\n};\n\nexports.getPairLocation = getPairLocation;","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPairLocation = exports.getBinary = exports.getBinaryString = exports.getLayerStructure = exports.getMaxIdxAtLayer = exports.generateHash = exports.isLeaf = void 0;\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst constants_1 = require(\"./constants\");\nconst isLeaf = (value) => value[0] === constants_1.LEAF_PREFIX[0];\nexports.isLeaf = isLeaf;\nconst generateHash = (prefix, leftHash, rightHash) => lisk_cryptography_1.hash(Buffer.concat([prefix, leftHash, rightHash], prefix.length + leftHash.length + rightHash.length));\nexports.generateHash = generateHash;\nconst getMaxIdxAtLayer = (layer, dataLength) => {\n    let [max, r] = [dataLength, 0];\n    for (let i = 0; i < layer; i += 1) {\n        [max, r] = [[Math.floor, Math.ceil][r % 2](max / 2), r + (max % 2)];\n    }\n    return max;\n};\nexports.getMaxIdxAtLayer = getMaxIdxAtLayer;\nconst getLayerStructure = (dataLength) => {\n    const structure = [];\n    for (let i = 0; i <= Math.ceil(Math.log2(dataLength)); i += 1) {\n        structure.push(exports.getMaxIdxAtLayer(i, dataLength));\n    }\n    return structure;\n};\nexports.getLayerStructure = getLayerStructure;\nconst getBinaryString = (num, length) => {\n    if (length === 0) {\n        return '';\n    }\n    let binaryString = num.toString(2);\n    while (binaryString.length < length)\n        binaryString = `0${binaryString}`;\n    return binaryString;\n};\nexports.getBinaryString = getBinaryString;\nconst getBinary = (num, length) => {\n    const binaryString = exports.getBinaryString(num, length);\n    return binaryString.split('').map(d => parseInt(d, 10));\n};\nexports.getBinary = getBinary;\nconst getPairLocation = (nodeInfo) => {\n    const { layerIndex, nodeIndex, dataLength } = nodeInfo;\n    const treeHeight = Math.ceil(Math.log2(dataLength)) + 1;\n    const layerStructure = exports.getLayerStructure(dataLength);\n    const numberOfNodesInLayer = layerStructure[layerIndex];\n    const binary = exports.getBinary(nodeIndex, treeHeight - layerIndex);\n    const side = [0, 1][binary[binary.length - 1]];\n    const pairSide = side === 0 ? 1 : 0;\n    if (layerIndex + 1 === treeHeight) {\n        return { layerIndex: treeHeight - 1, nodeIndex: 0 };\n    }\n    if (side === 0 && nodeIndex < numberOfNodesInLayer - 1) {\n        const pairNodeIndex = nodeIndex + 1;\n        return { layerIndex, nodeIndex: pairNodeIndex, side: pairSide };\n    }\n    if (side === 1 &&\n        ((numberOfNodesInLayer % 2 === 0 && nodeIndex === numberOfNodesInLayer - 1) ||\n            (nodeIndex < numberOfNodesInLayer - 1 && nodeIndex < numberOfNodesInLayer - 1))) {\n        const pairNodeIndex = nodeIndex - 1;\n        return { layerIndex, nodeIndex: pairNodeIndex, side: pairSide };\n    }\n    let currentLayer = layerIndex;\n    const numOfOddLayers = layerStructure\n        .slice(0, currentLayer)\n        .filter(num => num % 2 !== 0)\n        .reduce((acc, val) => acc + val, 0);\n    const direction = numOfOddLayers % 2 === 0 ? 1 : -1;\n    let pairLocation;\n    currentLayer += direction;\n    while (currentLayer >= 0 && currentLayer <= treeHeight - 1) {\n        if (layerStructure[currentLayer] % 2 !== 0) {\n            const pairNodeIndex = direction === 1\n                ? layerStructure[currentLayer] + direction * -1\n                : layerStructure[currentLayer] - direction * -1;\n            pairLocation = {\n                layerIndex: currentLayer,\n                nodeIndex: pairNodeIndex,\n                side: direction === -1 ? 1 : 0,\n            };\n            break;\n        }\n        currentLayer += direction;\n    }\n    return pairLocation;\n};\nexports.getPairLocation = getPairLocation;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}