{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createBlock = exports.createFakeBlockHeader = exports.createBlockHeaderWithDefaults = exports.encodeBlockHeader = void 0;\n\nvar lisk_chain_1 = require(\"@liskhq/lisk-chain\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar lisk_tree_1 = require(\"@liskhq/lisk-tree\");\n\nvar encodeBlockHeader = function encodeBlockHeader(header) {\n  var skipSignature = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var encodedAsset = lisk_codec_1.codec.encode(lisk_chain_1.blockHeaderAssetSchema, header.asset);\n\n  var rawHeader = _objectSpread(_objectSpread({}, header), {}, {\n    asset: encodedAsset\n  });\n\n  var schema = skipSignature ? lisk_chain_1.signingBlockHeaderSchema : lisk_chain_1.blockHeaderSchema;\n  return lisk_codec_1.codec.encode(schema, rawHeader);\n};\n\nexports.encodeBlockHeader = encodeBlockHeader;\n\nvar createBlockHeaderWithDefaults = function createBlockHeaderWithDefaults(header) {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n\n  return {\n    version: (_a = header === null || header === void 0 ? void 0 : header.version) !== null && _a !== void 0 ? _a : 2,\n    timestamp: (_b = header === null || header === void 0 ? void 0 : header.timestamp) !== null && _b !== void 0 ? _b : 0,\n    height: (_c = header === null || header === void 0 ? void 0 : header.height) !== null && _c !== void 0 ? _c : 1,\n    previousBlockID: (_d = header === null || header === void 0 ? void 0 : header.previousBlockID) !== null && _d !== void 0 ? _d : lisk_cryptography_1.hash(lisk_cryptography_1.getRandomBytes(4)),\n    transactionRoot: (_e = header === null || header === void 0 ? void 0 : header.transactionRoot) !== null && _e !== void 0 ? _e : lisk_cryptography_1.hash(lisk_cryptography_1.getRandomBytes(4)),\n    generatorPublicKey: (_f = header === null || header === void 0 ? void 0 : header.generatorPublicKey) !== null && _f !== void 0 ? _f : lisk_cryptography_1.getRandomBytes(32),\n    reward: (_g = header === null || header === void 0 ? void 0 : header.reward) !== null && _g !== void 0 ? _g : BigInt(0),\n    asset: (_h = header === null || header === void 0 ? void 0 : header.asset) !== null && _h !== void 0 ? _h : {\n      maxHeightPreviouslyForged: 0,\n      maxHeightPrevoted: 0,\n      seedReveal: lisk_cryptography_1.getRandomBytes(16)\n    }\n  };\n};\n\nexports.createBlockHeaderWithDefaults = createBlockHeaderWithDefaults;\n\nvar createFakeBlockHeader = function createFakeBlockHeader(header) {\n  var headerWithDefault = exports.createBlockHeaderWithDefaults(header);\n  var headerWithSignature = lisk_utils_1.objects.mergeDeep({}, headerWithDefault, {\n    signature: lisk_cryptography_1.getRandomBytes(64)\n  });\n  var id = lisk_cryptography_1.hash(exports.encodeBlockHeader(headerWithSignature));\n  return _objectSpread(_objectSpread({}, headerWithSignature), {}, {\n    id: id\n  });\n};\n\nexports.createFakeBlockHeader = createFakeBlockHeader;\n\nvar createBlock = function createBlock(_ref) {\n  var passphrase = _ref.passphrase,\n      networkIdentifier = _ref.networkIdentifier,\n      timestamp = _ref.timestamp,\n      previousBlockID = _ref.previousBlockID,\n      payload = _ref.payload,\n      header = _ref.header;\n\n  var _a;\n\n  var _lisk_cryptography_1$ = lisk_cryptography_1.getPrivateAndPublicKeyFromPassphrase(passphrase),\n      publicKey = _lisk_cryptography_1$.publicKey,\n      privateKey = _lisk_cryptography_1$.privateKey;\n\n  var txTree = new lisk_tree_1.MerkleTree(payload === null || payload === void 0 ? void 0 : payload.map(function (tx) {\n    return tx.id;\n  }));\n\n  var asset = _objectSpread({\n    maxHeightPreviouslyForged: 0,\n    maxHeightPrevoted: 0,\n    seedReveal: lisk_cryptography_1.getRandomBytes(16)\n  }, header === null || header === void 0 ? void 0 : header.asset);\n\n  var blockHeader = exports.createBlockHeaderWithDefaults(_objectSpread(_objectSpread({\n    previousBlockID: previousBlockID,\n    timestamp: timestamp,\n    transactionRoot: (_a = header === null || header === void 0 ? void 0 : header.transactionRoot) !== null && _a !== void 0 ? _a : txTree.root,\n    generatorPublicKey: publicKey\n  }, header), {}, {\n    asset: asset\n  }));\n  var headerBytesWithoutSignature = exports.encodeBlockHeader(blockHeader, true);\n  var signature = lisk_cryptography_1.signDataWithPrivateKey(Buffer.concat([networkIdentifier, headerBytesWithoutSignature]), privateKey);\n  var headerBytes = exports.encodeBlockHeader(_objectSpread(_objectSpread({}, blockHeader), {}, {\n    signature: signature\n  }));\n  var id = lisk_cryptography_1.hash(headerBytes);\n  var block = {\n    header: _objectSpread(_objectSpread({}, blockHeader), {}, {\n      signature: signature,\n      id: id\n    }),\n    payload: payload\n  };\n  return block;\n};\n\nexports.createBlock = createBlock;","map":{"version":3,"sources":["../../src/testing/create_block.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createBlock = exports.createFakeBlockHeader = exports.createBlockHeaderWithDefaults = exports.encodeBlockHeader = void 0;\nconst lisk_chain_1 = require(\"@liskhq/lisk-chain\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst lisk_tree_1 = require(\"@liskhq/lisk-tree\");\nconst encodeBlockHeader = (header, skipSignature = false) => {\n    const encodedAsset = lisk_codec_1.codec.encode(lisk_chain_1.blockHeaderAssetSchema, header.asset);\n    const rawHeader = { ...header, asset: encodedAsset };\n    const schema = skipSignature ? lisk_chain_1.signingBlockHeaderSchema : lisk_chain_1.blockHeaderSchema;\n    return lisk_codec_1.codec.encode(schema, rawHeader);\n};\nexports.encodeBlockHeader = encodeBlockHeader;\nconst createBlockHeaderWithDefaults = (header) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    return ({\n        version: (_a = header === null || header === void 0 ? void 0 : header.version) !== null && _a !== void 0 ? _a : 2,\n        timestamp: (_b = header === null || header === void 0 ? void 0 : header.timestamp) !== null && _b !== void 0 ? _b : 0,\n        height: (_c = header === null || header === void 0 ? void 0 : header.height) !== null && _c !== void 0 ? _c : 1,\n        previousBlockID: (_d = header === null || header === void 0 ? void 0 : header.previousBlockID) !== null && _d !== void 0 ? _d : lisk_cryptography_1.hash(lisk_cryptography_1.getRandomBytes(4)),\n        transactionRoot: (_e = header === null || header === void 0 ? void 0 : header.transactionRoot) !== null && _e !== void 0 ? _e : lisk_cryptography_1.hash(lisk_cryptography_1.getRandomBytes(4)),\n        generatorPublicKey: (_f = header === null || header === void 0 ? void 0 : header.generatorPublicKey) !== null && _f !== void 0 ? _f : lisk_cryptography_1.getRandomBytes(32),\n        reward: (_g = header === null || header === void 0 ? void 0 : header.reward) !== null && _g !== void 0 ? _g : BigInt(0),\n        asset: ((_h = header === null || header === void 0 ? void 0 : header.asset) !== null && _h !== void 0 ? _h : {\n            maxHeightPreviouslyForged: 0,\n            maxHeightPrevoted: 0,\n            seedReveal: lisk_cryptography_1.getRandomBytes(16),\n        }),\n    });\n};\nexports.createBlockHeaderWithDefaults = createBlockHeaderWithDefaults;\nconst createFakeBlockHeader = (header) => {\n    const headerWithDefault = exports.createBlockHeaderWithDefaults(header);\n    const headerWithSignature = lisk_utils_1.objects.mergeDeep({}, headerWithDefault, {\n        signature: lisk_cryptography_1.getRandomBytes(64),\n    });\n    const id = lisk_cryptography_1.hash(exports.encodeBlockHeader(headerWithSignature));\n    return {\n        ...headerWithSignature,\n        id,\n    };\n};\nexports.createFakeBlockHeader = createFakeBlockHeader;\nconst createBlock = ({ passphrase, networkIdentifier, timestamp, previousBlockID, payload, header, }) => {\n    var _a;\n    const { publicKey, privateKey } = lisk_cryptography_1.getPrivateAndPublicKeyFromPassphrase(passphrase);\n    const txTree = new lisk_tree_1.MerkleTree(payload === null || payload === void 0 ? void 0 : payload.map(tx => tx.id));\n    const asset = {\n        maxHeightPreviouslyForged: 0,\n        maxHeightPrevoted: 0,\n        seedReveal: lisk_cryptography_1.getRandomBytes(16),\n        ...header === null || header === void 0 ? void 0 : header.asset,\n    };\n    const blockHeader = exports.createBlockHeaderWithDefaults({\n        previousBlockID,\n        timestamp,\n        transactionRoot: (_a = header === null || header === void 0 ? void 0 : header.transactionRoot) !== null && _a !== void 0 ? _a : txTree.root,\n        generatorPublicKey: publicKey,\n        ...header,\n        asset,\n    });\n    const headerBytesWithoutSignature = exports.encodeBlockHeader(blockHeader, true);\n    const signature = lisk_cryptography_1.signDataWithPrivateKey(Buffer.concat([networkIdentifier, headerBytesWithoutSignature]), privateKey);\n    const headerBytes = exports.encodeBlockHeader({\n        ...blockHeader,\n        signature,\n    });\n    const id = lisk_cryptography_1.hash(headerBytes);\n    const block = {\n        header: {\n            ...blockHeader,\n            signature,\n            id,\n        },\n        payload,\n    };\n    return block;\n};\nexports.createBlock = createBlock;\n//# sourceMappingURL=create_block.js.map"]},"metadata":{},"sourceType":"script"}