{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5, _templateObject6, _templateObject7, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16, _templateObject17;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar dataType_1 = require(\"../../compile/validate/dataType\");\n\nvar codegen_1 = require(\"../../compile/codegen\");\n\nvar util_1 = require(\"../../compile/util\");\n\nvar equal_1 = require(\"../../runtime/equal\");\n\nvar error = {\n  message: function message(_ref) {\n    var _ref$params = _ref.params,\n        i = _ref$params.i,\n        j = _ref$params.j;\n    return codegen_1.str(_templateObject || (_templateObject = _taggedTemplateLiteral([\"must NOT have duplicate items (items ## \", \" and \", \" are identical)\"])), j, i);\n  },\n  params: function params(_ref2) {\n    var _ref2$params = _ref2.params,\n        i = _ref2$params.i,\n        j = _ref2$params.j;\n    return codegen_1._(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"{i: \", \", j: \", \"}\"])), i, j);\n  }\n};\nvar def = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error: error,\n  code: function code(cxt) {\n    var gen = cxt.gen,\n        data = cxt.data,\n        $data = cxt.$data,\n        schema = cxt.schema,\n        parentSchema = cxt.parentSchema,\n        schemaCode = cxt.schemaCode,\n        it = cxt.it;\n    if (!$data && !schema) return;\n    var valid = gen.let(\"valid\");\n    var itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];\n    cxt.block$data(valid, validateUniqueItems, codegen_1._(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\", \" === false\"])), schemaCode));\n    cxt.ok(valid);\n\n    function validateUniqueItems() {\n      var i = gen.let(\"i\", codegen_1._(_templateObject4 || (_templateObject4 = _taggedTemplateLiteral([\"\", \".length\"])), data));\n      var j = gen.let(\"j\");\n      cxt.setParams({\n        i: i,\n        j: j\n      });\n      gen.assign(valid, true);\n      gen.if(codegen_1._(_templateObject5 || (_templateObject5 = _taggedTemplateLiteral([\"\", \" > 1\"])), i), function () {\n        return (canOptimize() ? loopN : loopN2)(i, j);\n      });\n    }\n\n    function canOptimize() {\n      return itemTypes.length > 0 && !itemTypes.some(function (t) {\n        return t === \"object\" || t === \"array\";\n      });\n    }\n\n    function loopN(i, j) {\n      var item = gen.name(\"item\");\n      var wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n      var indices = gen.const(\"indices\", codegen_1._(_templateObject6 || (_templateObject6 = _taggedTemplateLiteral([\"{}\"]))));\n      gen.for(codegen_1._(_templateObject7 || (_templateObject7 = _taggedTemplateLiteral([\";\", \"--;\"])), i), function () {\n        gen.let(item, codegen_1._(_templateObject8 || (_templateObject8 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), data, i));\n        gen.if(wrongType, codegen_1._(_templateObject9 || (_templateObject9 = _taggedTemplateLiteral([\"continue\"]))));\n        if (itemTypes.length > 1) gen.if(codegen_1._(_templateObject10 || (_templateObject10 = _taggedTemplateLiteral([\"typeof \", \" == \\\"string\\\"\"])), item), codegen_1._(_templateObject11 || (_templateObject11 = _taggedTemplateLiteral([\"\", \" += \\\"_\\\"\"])), item));\n        gen.if(codegen_1._(_templateObject12 || (_templateObject12 = _taggedTemplateLiteral([\"typeof \", \"[\", \"] == \\\"number\\\"\"])), indices, item), function () {\n          gen.assign(j, codegen_1._(_templateObject13 || (_templateObject13 = _taggedTemplateLiteral([\"\", \"[\", \"]\"])), indices, item));\n          cxt.error();\n          gen.assign(valid, false).break();\n        }).code(codegen_1._(_templateObject14 || (_templateObject14 = _taggedTemplateLiteral([\"\", \"[\", \"] = \", \"\"])), indices, item, i));\n      });\n    }\n\n    function loopN2(i, j) {\n      var eql = util_1.useFunc(gen, equal_1.default);\n      var outer = gen.name(\"outer\");\n      gen.label(outer).for(codegen_1._(_templateObject15 || (_templateObject15 = _taggedTemplateLiteral([\";\", \"--;\"])), i), function () {\n        return gen.for(codegen_1._(_templateObject16 || (_templateObject16 = _taggedTemplateLiteral([\"\", \" = \", \"; \", \"--;\"])), j, i, j), function () {\n          return gen.if(codegen_1._(_templateObject17 || (_templateObject17 = _taggedTemplateLiteral([\"\", \"(\", \"[\", \"], \", \"[\", \"])\"])), eql, data, i, data, j), function () {\n            cxt.error();\n            gen.assign(valid, false).break(outer);\n          });\n        });\n      });\n    }\n  }\n};\nexports.default = def;","map":{"version":3,"sources":["../../../lib/vocabularies/validation/uniqueItems.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst dataType_1 = require(\"../../compile/validate/dataType\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst util_1 = require(\"../../compile/util\");\nconst equal_1 = require(\"../../runtime/equal\");\nconst error = {\n    message: ({ params: { i, j } }) => codegen_1.str `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => codegen_1._ `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let(\"valid\");\n        const itemTypes = parentSchema.items ? dataType_1.getSchemaTypes(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, codegen_1._ `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let(\"i\", codegen_1._ `${data}.length`);\n            const j = gen.let(\"j\");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if(codegen_1._ `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\");\n        }\n        function loopN(i, j) {\n            const item = gen.name(\"item\");\n            const wrongType = dataType_1.checkDataTypes(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const(\"indices\", codegen_1._ `{}`);\n            gen.for(codegen_1._ `;${i}--;`, () => {\n                gen.let(item, codegen_1._ `${data}[${i}]`);\n                gen.if(wrongType, codegen_1._ `continue`);\n                if (itemTypes.length > 1)\n                    gen.if(codegen_1._ `typeof ${item} == \"string\"`, codegen_1._ `${item} += \"_\"`);\n                gen\n                    .if(codegen_1._ `typeof ${indices}[${item}] == \"number\"`, () => {\n                    gen.assign(j, codegen_1._ `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code(codegen_1._ `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = util_1.useFunc(gen, equal_1.default);\n            const outer = gen.name(\"outer\");\n            gen.label(outer).for(codegen_1._ `;${i}--;`, () => gen.for(codegen_1._ `${j} = ${i}; ${j}--;`, () => gen.if(codegen_1._ `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports.default = def;\n//# sourceMappingURL=uniqueItems.js.map"]},"metadata":{},"sourceType":"script"}