{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutProperties = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _excluded = [\"options\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OutboundPeer = void 0;\n\nvar querystring = require(\"querystring\");\n\nvar socketClusterClient = require(\"socketcluster-client\");\n\nvar constants_1 = require(\"../constants\");\n\nvar events_1 = require(\"../events\");\n\nvar base_1 = require(\"./base\");\n\nvar p2p_request_1 = require(\"../p2p_request\");\n\nvar OutboundPeer = /*#__PURE__*/function (_base_1$Peer) {\n  _inherits(OutboundPeer, _base_1$Peer);\n\n  var _super = _createSuper(OutboundPeer);\n\n  function OutboundPeer(peerInfo, peerConfig) {\n    var _this;\n\n    _classCallCheck(this, OutboundPeer);\n\n    _this = _super.call(this, peerInfo, peerConfig);\n    _this._peerInfo.internalState.connectionKind = constants_1.ConnectionKind.OUTBOUND;\n    return _this;\n  }\n\n  _createClass(OutboundPeer, [{\n    key: \"socket\",\n    set: function set(scClientSocket) {\n      if (this._socket) {\n        this._unbindHandlersFromOutboundSocket(this._socket);\n      }\n\n      this._socket = scClientSocket;\n\n      this._bindHandlersToOutboundSocket(this._socket);\n    }\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      if (!this._socket) {\n        this._socket = this._createOutboundSocket();\n      }\n\n      this._socket.connect();\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : constants_1.INTENTIONAL_DISCONNECT_CODE;\n      var reason = arguments.length > 1 ? arguments[1] : undefined;\n\n      _get(_getPrototypeOf(OutboundPeer.prototype), \"disconnect\", this).call(this, code, reason);\n\n      if (this._socket) {\n        this._unbindHandlersFromOutboundSocket(this._socket);\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function send(packet) {\n      if (!this._socket) {\n        this._socket = this._createOutboundSocket();\n      }\n\n      _get(_getPrototypeOf(OutboundPeer.prototype), \"send\", this).call(this, packet);\n    }\n  }, {\n    key: \"request\",\n    value: function () {\n      var _request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(packet) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._socket) {\n                  this._socket = this._createOutboundSocket();\n                }\n\n                return _context.abrupt(\"return\", _get(_getPrototypeOf(OutboundPeer.prototype), \"request\", this).call(this, packet));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function request(_x) {\n        return _request.apply(this, arguments);\n      }\n\n      return request;\n    }()\n  }, {\n    key: \"_createOutboundSocket\",\n    value: function _createOutboundSocket() {\n      var connectTimeout = this._peerConfig.connectTimeout ? this._peerConfig.connectTimeout : constants_1.DEFAULT_CONNECT_TIMEOUT;\n      var ackTimeout = this._peerConfig.ackTimeout ? this._peerConfig.ackTimeout : constants_1.DEFAULT_ACK_TIMEOUT;\n\n      var _this$_serverNodeInfo = this._serverNodeInfo,\n          options = _this$_serverNodeInfo.options,\n          nodeInfo = _objectWithoutProperties(_this$_serverNodeInfo, _excluded);\n\n      var queryObject = {\n        networkVersion: nodeInfo.networkVersion,\n        networkIdentifier: nodeInfo.networkIdentifier,\n        nonce: nodeInfo.nonce,\n        advertiseAddress: nodeInfo.advertiseAddress,\n        port: this._peerConfig.hostPort\n      };\n      var clientOptions = {\n        hostname: this.ipAddress,\n        path: constants_1.DEFAULT_HTTP_PATH,\n        port: this.port,\n        query: querystring.stringify(queryObject),\n        connectTimeout: connectTimeout,\n        ackTimeout: ackTimeout,\n        multiplex: false,\n        autoConnect: true,\n        autoReconnect: false,\n        maxPayload: this._peerConfig.wsMaxPayload\n      };\n      var outboundSocket = socketClusterClient.create(clientOptions);\n\n      this._bindHandlersToOutboundSocket(outboundSocket);\n\n      return outboundSocket;\n    }\n  }, {\n    key: \"_bindHandlersToOutboundSocket\",\n    value: function _bindHandlersToOutboundSocket(outboundSocket) {\n      var _this2 = this;\n\n      outboundSocket.on('error', function (error) {\n        _this2.emit(events_1.EVENT_OUTBOUND_SOCKET_ERROR, error);\n      });\n      outboundSocket.on('connect', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return _this2.fetchAndUpdateStatus();\n\n              case 3:\n                _context2.next = 9;\n                break;\n\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](0);\n\n                _this2.emit(events_1.EVENT_FAILED_TO_COLLECT_PEER_DETAILS_ON_CONNECT, _context2.t0);\n\n                return _context2.abrupt(\"return\");\n\n              case 9:\n                _context2.prev = 9;\n                _context2.next = 12;\n                return _this2.discoverPeers();\n\n              case 12:\n                _context2.next = 17;\n                break;\n\n              case 14:\n                _context2.prev = 14;\n                _context2.t1 = _context2[\"catch\"](9);\n\n                _this2.emit(events_1.EVENT_FAILED_TO_COLLECT_PEER_DETAILS_ON_CONNECT, _context2.t1);\n\n              case 17:\n                _this2.emit(events_1.EVENT_CONNECT_OUTBOUND, _this2._peerInfo);\n\n              case 18:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 5], [9, 14]]);\n      })));\n      outboundSocket.on('connectAbort', function () {\n        _this2.emit(events_1.EVENT_CONNECT_ABORT_OUTBOUND, _this2._peerInfo);\n      });\n      outboundSocket.on('close', function (code, reasonMessage) {\n        var _a;\n\n        var reason = reasonMessage !== undefined && reasonMessage !== '' ? reasonMessage : (_a = base_1.socketErrorStatusCodes[code]) !== null && _a !== void 0 ? _a : 'Unknown reason';\n\n        _this2.emit(events_1.EVENT_CLOSE_OUTBOUND, {\n          peerInfo: _this2._peerInfo,\n          code: code,\n          reason: reason\n        });\n      });\n      outboundSocket.on('message', this._handleWSMessage);\n      outboundSocket.on(events_1.REMOTE_SC_EVENT_RPC_REQUEST, function (rawRequestPacket, respond) {\n        if (rawRequestPacket.procedure === events_1.REMOTE_EVENT_PING) {\n          _this2._updateOutboundRPCCounter(rawRequestPacket);\n\n          var rate = _this2._getOutboundRPCRate(rawRequestPacket);\n\n          var request = new p2p_request_1.P2PRequest({\n            procedure: rawRequestPacket.procedure,\n            data: rawRequestPacket.data,\n            id: _this2.peerInfo.peerId,\n            rate: rate,\n            productivity: _this2.internalState.productivity\n          }, respond);\n          request.end(events_1.REMOTE_EVENT_PONG);\n          return;\n        }\n\n        _this2._handleRawRPC(rawRequestPacket, respond);\n      });\n      outboundSocket.on(events_1.REMOTE_SC_EVENT_MESSAGE, this._handleRawMessage);\n      var transportSocket = outboundSocket.transport;\n\n      if ((transportSocket === null || transportSocket === void 0 ? void 0 : transportSocket.socket) && transportSocket.socket.on) {\n        transportSocket.socket.on(events_1.REMOTE_EVENT_PING, function () {\n          transportSocket.socket.terminate();\n\n          _this2.applyPenalty(100);\n        });\n        transportSocket.socket.on(events_1.REMOTE_EVENT_PONG, function () {\n          transportSocket.socket.terminate();\n\n          _this2.applyPenalty(100);\n        });\n      }\n    }\n  }, {\n    key: \"_unbindHandlersFromOutboundSocket\",\n    value: function _unbindHandlersFromOutboundSocket(outboundSocket) {\n      outboundSocket.off('connect');\n      outboundSocket.off('connectAbort');\n      outboundSocket.off('close');\n      outboundSocket.off('message', this._handleWSMessage);\n      outboundSocket.off(events_1.REMOTE_SC_EVENT_RPC_REQUEST, this._handleRawRPC);\n      outboundSocket.off(events_1.REMOTE_SC_EVENT_MESSAGE, this._handleRawMessage);\n      outboundSocket.off(events_1.REMOTE_EVENT_PING);\n    }\n  }, {\n    key: \"_updateOutboundRPCCounter\",\n    value: function _updateOutboundRPCCounter(packet) {\n      var _a;\n\n      var key = packet.procedure;\n      var count = ((_a = this.internalState.rpcCounter.get(key)) !== null && _a !== void 0 ? _a : 0) + 1;\n      this.peerInfo.internalState.rpcCounter.set(key, count);\n    }\n  }, {\n    key: \"_getOutboundRPCRate\",\n    value: function _getOutboundRPCRate(packet) {\n      var _a;\n\n      var rate = (_a = this.peerInfo.internalState.rpcRates.get(packet.procedure)) !== null && _a !== void 0 ? _a : 0;\n      return rate * base_1.RATE_NORMALIZATION_FACTOR;\n    }\n  }]);\n\n  return OutboundPeer;\n}(base_1.Peer);\n\nexports.OutboundPeer = OutboundPeer;","map":{"version":3,"sources":["../../src/peer/outbound.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OutboundPeer = void 0;\nconst querystring = require(\"querystring\");\nconst socketClusterClient = require(\"socketcluster-client\");\nconst constants_1 = require(\"../constants\");\nconst events_1 = require(\"../events\");\nconst base_1 = require(\"./base\");\nconst p2p_request_1 = require(\"../p2p_request\");\nclass OutboundPeer extends base_1.Peer {\n    constructor(peerInfo, peerConfig) {\n        super(peerInfo, peerConfig);\n        this._peerInfo.internalState.connectionKind = constants_1.ConnectionKind.OUTBOUND;\n    }\n    set socket(scClientSocket) {\n        if (this._socket) {\n            this._unbindHandlersFromOutboundSocket(this._socket);\n        }\n        this._socket = scClientSocket;\n        this._bindHandlersToOutboundSocket(this._socket);\n    }\n    connect() {\n        if (!this._socket) {\n            this._socket = this._createOutboundSocket();\n        }\n        this._socket.connect();\n    }\n    disconnect(code = constants_1.INTENTIONAL_DISCONNECT_CODE, reason) {\n        super.disconnect(code, reason);\n        if (this._socket) {\n            this._unbindHandlersFromOutboundSocket(this._socket);\n        }\n    }\n    send(packet) {\n        if (!this._socket) {\n            this._socket = this._createOutboundSocket();\n        }\n        super.send(packet);\n    }\n    async request(packet) {\n        if (!this._socket) {\n            this._socket = this._createOutboundSocket();\n        }\n        return super.request(packet);\n    }\n    _createOutboundSocket() {\n        const connectTimeout = this._peerConfig.connectTimeout\n            ? this._peerConfig.connectTimeout\n            : constants_1.DEFAULT_CONNECT_TIMEOUT;\n        const ackTimeout = this._peerConfig.ackTimeout\n            ? this._peerConfig.ackTimeout\n            : constants_1.DEFAULT_ACK_TIMEOUT;\n        const { options, ...nodeInfo } = this._serverNodeInfo;\n        const queryObject = {\n            networkVersion: nodeInfo.networkVersion,\n            networkIdentifier: nodeInfo.networkIdentifier,\n            nonce: nodeInfo.nonce,\n            advertiseAddress: nodeInfo.advertiseAddress,\n            port: this._peerConfig.hostPort,\n        };\n        const clientOptions = {\n            hostname: this.ipAddress,\n            path: constants_1.DEFAULT_HTTP_PATH,\n            port: this.port,\n            query: querystring.stringify(queryObject),\n            connectTimeout,\n            ackTimeout,\n            multiplex: false,\n            autoConnect: true,\n            autoReconnect: false,\n            maxPayload: this._peerConfig.wsMaxPayload,\n        };\n        const outboundSocket = socketClusterClient.create(clientOptions);\n        this._bindHandlersToOutboundSocket(outboundSocket);\n        return outboundSocket;\n    }\n    _bindHandlersToOutboundSocket(outboundSocket) {\n        outboundSocket.on('error', (error) => {\n            this.emit(events_1.EVENT_OUTBOUND_SOCKET_ERROR, error);\n        });\n        outboundSocket.on('connect', async () => {\n            try {\n                await this.fetchAndUpdateStatus();\n            }\n            catch (error) {\n                this.emit(events_1.EVENT_FAILED_TO_COLLECT_PEER_DETAILS_ON_CONNECT, error);\n                return;\n            }\n            try {\n                await this.discoverPeers();\n            }\n            catch (error) {\n                this.emit(events_1.EVENT_FAILED_TO_COLLECT_PEER_DETAILS_ON_CONNECT, error);\n            }\n            this.emit(events_1.EVENT_CONNECT_OUTBOUND, this._peerInfo);\n        });\n        outboundSocket.on('connectAbort', () => {\n            this.emit(events_1.EVENT_CONNECT_ABORT_OUTBOUND, this._peerInfo);\n        });\n        outboundSocket.on('close', (code, reasonMessage) => {\n            var _a;\n            const reason = reasonMessage !== undefined && reasonMessage !== ''\n                ? reasonMessage\n                : (_a = base_1.socketErrorStatusCodes[code]) !== null && _a !== void 0 ? _a : 'Unknown reason';\n            this.emit(events_1.EVENT_CLOSE_OUTBOUND, {\n                peerInfo: this._peerInfo,\n                code,\n                reason,\n            });\n        });\n        outboundSocket.on('message', this._handleWSMessage);\n        outboundSocket.on(events_1.REMOTE_SC_EVENT_RPC_REQUEST, (rawRequestPacket, respond) => {\n            if (rawRequestPacket.procedure === events_1.REMOTE_EVENT_PING) {\n                this._updateOutboundRPCCounter(rawRequestPacket);\n                const rate = this._getOutboundRPCRate(rawRequestPacket);\n                const request = new p2p_request_1.P2PRequest({\n                    procedure: rawRequestPacket.procedure,\n                    data: rawRequestPacket.data,\n                    id: this.peerInfo.peerId,\n                    rate,\n                    productivity: this.internalState.productivity,\n                }, respond);\n                request.end(events_1.REMOTE_EVENT_PONG);\n                return;\n            }\n            this._handleRawRPC(rawRequestPacket, respond);\n        });\n        outboundSocket.on(events_1.REMOTE_SC_EVENT_MESSAGE, this._handleRawMessage);\n        const transportSocket = outboundSocket.transport;\n        if ((transportSocket === null || transportSocket === void 0 ? void 0 : transportSocket.socket) && transportSocket.socket.on) {\n            transportSocket.socket.on(events_1.REMOTE_EVENT_PING, () => {\n                transportSocket.socket.terminate();\n                this.applyPenalty(100);\n            });\n            transportSocket.socket.on(events_1.REMOTE_EVENT_PONG, () => {\n                transportSocket.socket.terminate();\n                this.applyPenalty(100);\n            });\n        }\n    }\n    _unbindHandlersFromOutboundSocket(outboundSocket) {\n        outboundSocket.off('connect');\n        outboundSocket.off('connectAbort');\n        outboundSocket.off('close');\n        outboundSocket.off('message', this._handleWSMessage);\n        outboundSocket.off(events_1.REMOTE_SC_EVENT_RPC_REQUEST, this._handleRawRPC);\n        outboundSocket.off(events_1.REMOTE_SC_EVENT_MESSAGE, this._handleRawMessage);\n        outboundSocket.off(events_1.REMOTE_EVENT_PING);\n    }\n    _updateOutboundRPCCounter(packet) {\n        var _a;\n        const key = packet.procedure;\n        const count = ((_a = this.internalState.rpcCounter.get(key)) !== null && _a !== void 0 ? _a : 0) + 1;\n        this.peerInfo.internalState.rpcCounter.set(key, count);\n    }\n    _getOutboundRPCRate(packet) {\n        var _a;\n        const rate = (_a = this.peerInfo.internalState.rpcRates.get(packet.procedure)) !== null && _a !== void 0 ? _a : 0;\n        return rate * base_1.RATE_NORMALIZATION_FACTOR;\n    }\n}\nexports.OutboundPeer = OutboundPeer;\n//# sourceMappingURL=outbound.js.map"]},"metadata":{},"sourceType":"script"}