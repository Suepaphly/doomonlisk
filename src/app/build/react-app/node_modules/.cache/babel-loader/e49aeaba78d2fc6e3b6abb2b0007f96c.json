{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IPCChannel = void 0;\n\nvar eventemitter2_1 = require(\"eventemitter2\");\n\nvar action_1 = require(\"../action\");\n\nvar event_1 = require(\"../event\");\n\nvar base_channel_1 = require(\"./base_channel\");\n\nvar ipc_client_1 = require(\"../ipc/ipc_client\");\n\nvar IPCChannel = /*#__PURE__*/function (_base_channel_1$BaseC) {\n  _inherits(IPCChannel, _base_channel_1$BaseC);\n\n  var _super = _createSuper(IPCChannel);\n\n  function IPCChannel(moduleAlias, events, actions, options) {\n    var _this;\n\n    _classCallCheck(this, IPCChannel);\n\n    _this = _super.call(this, moduleAlias, events, actions, options);\n    _this._ipcClient = new ipc_client_1.IPCClient({\n      socketsDir: options.socketsPath.root,\n      name: moduleAlias,\n      rpcServerSocketPath: \"unix://\".concat(options.socketsPath.root, \"/bus_rpc_socket.sock\")\n    });\n    _this._emitter = new eventemitter2_1.EventEmitter2({\n      wildcard: true,\n      delimiter: ':',\n      maxListeners: 1000\n    });\n    return _this;\n  }\n\n  _createClass(IPCChannel, [{\n    key: \"startAndListen\",\n    value: function () {\n      var _startAndListen = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._ipcClient.start();\n\n              case 2:\n                this._subSocket.on('message', function (eventData) {\n                  var event = event_1.Event.fromJSONRPCNotification(eventData);\n\n                  if (event.module !== _this2.moduleAlias) {\n                    _this2._emitter.emit(event.key(), event.toJSONRPCNotification());\n                  }\n                });\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function startAndListen() {\n        return _startAndListen.apply(this, arguments);\n      }\n\n      return startAndListen;\n    }()\n  }, {\n    key: \"registerToBus\",\n    value: function () {\n      var _registerToBus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.startAndListen();\n\n              case 2:\n                _context2.next = 4;\n                return new Promise(function (resolve, reject) {\n                  var actionsInfo = {};\n                  actionsInfo = Object.keys(_this3.actions).reduce(function (accumulator, value) {\n                    accumulator[value] = {\n                      name: value,\n                      module: _this3.moduleAlias\n                    };\n                    return accumulator;\n                  }, actionsInfo);\n\n                  _this3._rpcClient.call('registerChannel', _this3.moduleAlias, _this3.eventsList.map(function (event) {\n                    return event;\n                  }), actionsInfo, {\n                    type: 'ipcSocket',\n                    rpcSocketPath: _this3._ipcClient.rpcServerSocketPath\n                  }, function (err, result) {\n                    if (err !== undefined && err !== null) {\n                      reject(err);\n                    }\n\n                    resolve(result);\n                  });\n                });\n\n              case 4:\n                if (this.actionsList.length > 0) {\n                  this._rpcServer.expose('invoke', function (action, cb) {\n                    var parsedAction = action_1.Action.fromJSONRPCRequest(action);\n\n                    _this3.invoke(parsedAction.key(), parsedAction.params).then(function (data) {\n                      return cb(null, parsedAction.buildJSONRPCResponse({\n                        result: data\n                      }));\n                    }).catch(function (error) {\n                      return cb(error);\n                    });\n                  });\n                }\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function registerToBus() {\n        return _registerToBus.apply(this, arguments);\n      }\n\n      return registerToBus;\n    }()\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(eventName, cb) {\n      var event = new event_1.Event(eventName);\n\n      this._emitter.on(event.key(), function (notification) {\n        return setImmediate(cb, event_1.Event.fromJSONRPCNotification(notification).data);\n      });\n    }\n  }, {\n    key: \"once\",\n    value: function once(eventName, cb) {\n      var event = new event_1.Event(eventName);\n\n      this._emitter.once(event.key(), function (notification) {\n        setImmediate(cb, event_1.Event.fromJSONRPCNotification(notification).data);\n      });\n    }\n  }, {\n    key: \"publish\",\n    value: function publish(eventName, data) {\n      var event = new event_1.Event(eventName, data);\n\n      if (event.module !== this.moduleAlias || !this.eventsList.includes(event.name)) {\n        throw new Error(\"Event \\\"\".concat(eventName, \"\\\" not registered in \\\"\").concat(this.moduleAlias, \"\\\" module.\"));\n      }\n\n      this._pubSocket.send(event.toJSONRPCNotification());\n    }\n  }, {\n    key: \"invoke\",\n    value: function () {\n      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(actionName, params) {\n        var _this4 = this;\n\n        var _a, action, handler;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                action = new action_1.Action(null, actionName, params);\n\n                if (!(action.module === this.moduleAlias)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                handler = (_a = this.actions[action.name]) === null || _a === void 0 ? void 0 : _a.handler;\n\n                if (handler) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new Error('Handler does not exist.');\n\n              case 5:\n                return _context3.abrupt(\"return\", handler(action.params));\n\n              case 6:\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  _this4._rpcClient.call('invoke', action.toJSONRPCRequest(), function (err, res) {\n                    if (err) {\n                      return reject(err);\n                    }\n\n                    return resolve(res.result);\n                  });\n                }));\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function invoke(_x, _x2) {\n        return _invoke.apply(this, arguments);\n      }\n\n      return invoke;\n    }()\n  }, {\n    key: \"cleanup\",\n    value: function cleanup(_status, _message) {\n      this._ipcClient.stop();\n    }\n  }, {\n    key: \"_rpcServer\",\n    get: function get() {\n      return this._ipcClient.rpcServer;\n    }\n  }, {\n    key: \"_rpcClient\",\n    get: function get() {\n      return this._ipcClient.rpcClient;\n    }\n  }, {\n    key: \"_pubSocket\",\n    get: function get() {\n      return this._ipcClient.pubSocket;\n    }\n  }, {\n    key: \"_subSocket\",\n    get: function get() {\n      return this._ipcClient.subSocket;\n    }\n  }]);\n\n  return IPCChannel;\n}(base_channel_1.BaseChannel);\n\nexports.IPCChannel = IPCChannel;","map":{"version":3,"sources":["../../../src/controller/channels/ipc_channel.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IPCChannel = void 0;\nconst eventemitter2_1 = require(\"eventemitter2\");\nconst action_1 = require(\"../action\");\nconst event_1 = require(\"../event\");\nconst base_channel_1 = require(\"./base_channel\");\nconst ipc_client_1 = require(\"../ipc/ipc_client\");\nclass IPCChannel extends base_channel_1.BaseChannel {\n    constructor(moduleAlias, events, actions, options) {\n        super(moduleAlias, events, actions, options);\n        this._ipcClient = new ipc_client_1.IPCClient({\n            socketsDir: options.socketsPath.root,\n            name: moduleAlias,\n            rpcServerSocketPath: `unix://${options.socketsPath.root}/bus_rpc_socket.sock`,\n        });\n        this._emitter = new eventemitter2_1.EventEmitter2({\n            wildcard: true,\n            delimiter: ':',\n            maxListeners: 1000,\n        });\n    }\n    async startAndListen() {\n        await this._ipcClient.start();\n        this._subSocket.on('message', (eventData) => {\n            const event = event_1.Event.fromJSONRPCNotification(eventData);\n            if (event.module !== this.moduleAlias) {\n                this._emitter.emit(event.key(), event.toJSONRPCNotification());\n            }\n        });\n    }\n    async registerToBus() {\n        await this.startAndListen();\n        await new Promise((resolve, reject) => {\n            let actionsInfo = {};\n            actionsInfo = Object.keys(this.actions).reduce((accumulator, value) => {\n                accumulator[value] = {\n                    name: value,\n                    module: this.moduleAlias,\n                };\n                return accumulator;\n            }, actionsInfo);\n            this._rpcClient.call('registerChannel', this.moduleAlias, this.eventsList.map((event) => event), actionsInfo, {\n                type: 'ipcSocket',\n                rpcSocketPath: this._ipcClient.rpcServerSocketPath,\n            }, (err, result) => {\n                if (err !== undefined && err !== null) {\n                    reject(err);\n                }\n                resolve(result);\n            });\n        });\n        if (this.actionsList.length > 0) {\n            this._rpcServer.expose('invoke', (action, cb) => {\n                const parsedAction = action_1.Action.fromJSONRPCRequest(action);\n                this.invoke(parsedAction.key(), parsedAction.params)\n                    .then(data => cb(null, parsedAction.buildJSONRPCResponse({ result: data })))\n                    .catch(error => cb(error));\n            });\n        }\n    }\n    subscribe(eventName, cb) {\n        const event = new event_1.Event(eventName);\n        this._emitter.on(event.key(), (notification) => setImmediate(cb, event_1.Event.fromJSONRPCNotification(notification).data));\n    }\n    once(eventName, cb) {\n        const event = new event_1.Event(eventName);\n        this._emitter.once(event.key(), (notification) => {\n            setImmediate(cb, event_1.Event.fromJSONRPCNotification(notification).data);\n        });\n    }\n    publish(eventName, data) {\n        const event = new event_1.Event(eventName, data);\n        if (event.module !== this.moduleAlias || !this.eventsList.includes(event.name)) {\n            throw new Error(`Event \"${eventName}\" not registered in \"${this.moduleAlias}\" module.`);\n        }\n        this._pubSocket.send(event.toJSONRPCNotification());\n    }\n    async invoke(actionName, params) {\n        var _a;\n        const action = new action_1.Action(null, actionName, params);\n        if (action.module === this.moduleAlias) {\n            const handler = (_a = this.actions[action.name]) === null || _a === void 0 ? void 0 : _a.handler;\n            if (!handler) {\n                throw new Error('Handler does not exist.');\n            }\n            return handler(action.params);\n        }\n        return new Promise((resolve, reject) => {\n            this._rpcClient.call('invoke', action.toJSONRPCRequest(), (err, res) => {\n                if (err) {\n                    return reject(err);\n                }\n                return resolve(res.result);\n            });\n        });\n    }\n    cleanup(_status, _message) {\n        this._ipcClient.stop();\n    }\n    get _rpcServer() {\n        return this._ipcClient.rpcServer;\n    }\n    get _rpcClient() {\n        return this._ipcClient.rpcClient;\n    }\n    get _pubSocket() {\n        return this._ipcClient.pubSocket;\n    }\n    get _subSocket() {\n        return this._ipcClient.subSocket;\n    }\n}\nexports.IPCChannel = IPCChannel;\n//# sourceMappingURL=ipc_channel.js.map"]},"metadata":{},"sourceType":"script"}