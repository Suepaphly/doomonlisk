{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Forger = void 0;\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar lisk_tree_1 = require(\"@liskhq/lisk-tree\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar strategies_1 = require(\"./strategies\");\n\nvar data_access_1 = require(\"./data_access\");\n\nvar BLOCK_VERSION = 2;\n\nvar isSyncedWithNetwork = function isSyncedWithNetwork(lastBlockHeader, forgingInput) {\n  if (lastBlockHeader.version === 0) {\n    return forgingInput.height <= lastBlockHeader.height && forgingInput.maxHeightPrevoted <= lastBlockHeader.height;\n  }\n\n  return forgingInput.maxHeightPrevoted < lastBlockHeader.asset.maxHeightPrevoted || forgingInput.maxHeightPrevoted === lastBlockHeader.asset.maxHeightPrevoted && forgingInput.height < lastBlockHeader.height;\n};\n\nvar isZeroForgingInfo = function isZeroForgingInfo(info) {\n  return info.height === 0 && info.maxHeightPrevoted === 0 && info.maxHeightPreviouslyForged === 0;\n};\n\nvar IsEqualForgingInfo = function IsEqualForgingInfo(info1, info2) {\n  return info1.height === info2.height && info1.maxHeightPreviouslyForged === info2.maxHeightPreviouslyForged && info1.maxHeightPrevoted === info2.maxHeightPrevoted;\n};\n\nvar Forger = /*#__PURE__*/function () {\n  function Forger(_ref) {\n    var forgingStrategy = _ref.forgingStrategy,\n        logger = _ref.logger,\n        db = _ref.db,\n        processorModule = _ref.processorModule,\n        bftModule = _ref.bftModule,\n        transactionPoolModule = _ref.transactionPoolModule,\n        chainModule = _ref.chainModule,\n        forgingDelegates = _ref.forgingDelegates,\n        forgingForce = _ref.forgingForce,\n        forgingDefaultPassword = _ref.forgingDefaultPassword,\n        forgingWaitThreshold = _ref.forgingWaitThreshold;\n\n    _classCallCheck(this, Forger);\n\n    this._keypairs = new lisk_utils_1.dataStructures.BufferMap();\n    this._logger = logger;\n    this._db = db;\n    this._config = {\n      forging: {\n        delegates: forgingDelegates,\n        force: forgingForce,\n        defaultPassword: forgingDefaultPassword,\n        waitThreshold: forgingWaitThreshold\n      }\n    };\n    this._processorModule = processorModule;\n    this._bftModule = bftModule;\n    this._transactionPoolModule = transactionPoolModule;\n    this._chainModule = chainModule;\n    this._forgingStrategy = forgingStrategy !== null && forgingStrategy !== void 0 ? forgingStrategy : new strategies_1.HighFeeForgingStrategy({\n      transactionPoolModule: this._transactionPoolModule,\n      chainModule: this._chainModule,\n      maxPayloadLength: this._chainModule.constants.maxPayloadLength,\n      processorModule: this._processorModule\n    });\n  }\n\n  _createClass(Forger, [{\n    key: \"delegatesEnabled\",\n    value: function delegatesEnabled() {\n      return this._keypairs.values().length > 0;\n    }\n  }, {\n    key: \"updateForgingStatus\",\n    value: function () {\n      var _updateForgingStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(forgerAddress, password, forging, height, maxHeightPreviouslyForged, maxHeightPrevoted, overwrite) {\n        var encryptedForgers, encryptedForger, passphrase, keypair, lastBlockHeader, previouslyForgedMap, forgingInput, forgerInfo;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                encryptedForgers = this._config.forging.delegates;\n                encryptedForger = encryptedForgers === null || encryptedForgers === void 0 ? void 0 : encryptedForgers.find(function (item) {\n                  return item.address.equals(forgerAddress);\n                });\n\n                if (encryptedForger) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error(\"Delegate with address: \".concat(forgerAddress.toString('hex'), \" not found\"));\n\n              case 4:\n                _context.prev = 4;\n                passphrase = lisk_cryptography_1.decryptPassphraseWithPassword(lisk_cryptography_1.parseEncryptedPassphrase(encryptedForger.encryptedPassphrase), password);\n                _context.next = 11;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](4);\n                throw new Error('Invalid password and public key combination');\n\n              case 11:\n                keypair = lisk_cryptography_1.getPrivateAndPublicKeyFromPassphrase(passphrase);\n\n                if (lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey).equals(forgerAddress)) {\n                  _context.next = 14;\n                  break;\n                }\n\n                throw new Error(\"Invalid keypair: \".concat(lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey).toString('hex'), \"  and address: \").concat(forgerAddress.toString('hex'), \" combination\"));\n\n              case 14:\n                if (forging) {\n                  _context.next = 18;\n                  break;\n                }\n\n                this._keypairs.delete(forgerAddress);\n\n                this._logger.info(\"Forging disabled on account: \".concat(forgerAddress.toString('hex')));\n\n                return _context.abrupt(\"return\", {\n                  address: forgerAddress,\n                  forging: forging\n                });\n\n              case 18:\n                lastBlockHeader = this._chainModule.lastBlock.header;\n                _context.next = 21;\n                return data_access_1.getPreviouslyForgedMap(this._db);\n\n              case 21:\n                previouslyForgedMap = _context.sent;\n                forgingInput = {\n                  height: height,\n                  maxHeightPreviouslyForged: maxHeightPreviouslyForged,\n                  maxHeightPrevoted: maxHeightPrevoted\n                };\n\n                if (isSyncedWithNetwork(lastBlockHeader, forgingInput)) {\n                  _context.next = 25;\n                  break;\n                }\n\n                throw new Error('Failed to enable forging as the node is not synced to the network.');\n\n              case 25:\n                forgerInfo = previouslyForgedMap.get(forgerAddress);\n\n                if (!(overwrite !== true)) {\n                  _context.next = 31;\n                  break;\n                }\n\n                if (!(forgerInfo !== undefined && !IsEqualForgingInfo(forgerInfo, forgingInput))) {\n                  _context.next = 29;\n                  break;\n                }\n\n                throw new Error(\"Failed to enable forging due to contradicting forger info. Current stored: \".concat(JSON.stringify(forgerInfo)));\n\n              case 29:\n                if (!(forgerInfo === undefined && !isZeroForgingInfo(forgingInput))) {\n                  _context.next = 31;\n                  break;\n                }\n\n                throw new Error('Failed to enable forging due to missing forger info.');\n\n              case 31:\n                if (!(forgerInfo === undefined || overwrite === true && forgerInfo !== undefined && !IsEqualForgingInfo(forgingInput, forgerInfo))) {\n                  _context.next = 36;\n                  break;\n                }\n\n                previouslyForgedMap.set(forgerAddress, {\n                  height: height,\n                  maxHeightPrevoted: maxHeightPrevoted,\n                  maxHeightPreviouslyForged: maxHeightPreviouslyForged\n                });\n                _context.next = 35;\n                return data_access_1.setPreviouslyForgedMap(this._db, previouslyForgedMap);\n\n              case 35:\n                this._logger.info(forgingInput, 'Updated forgerInfo');\n\n              case 36:\n                this._keypairs.set(forgerAddress, keypair);\n\n                this._logger.info(\"Forging enabled on account: \".concat(forgerAddress.toString('hex')));\n\n                return _context.abrupt(\"return\", {\n                  address: forgerAddress,\n                  forging: forging\n                });\n\n              case 39:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 8]]);\n      }));\n\n      function updateForgingStatus(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n        return _updateForgingStatus.apply(this, arguments);\n      }\n\n      return updateForgingStatus;\n    }()\n  }, {\n    key: \"loadDelegates\",\n    value: function () {\n      var _loadDelegates = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this = this;\n\n        var encryptedList, usedHashOnions, registeredHashOnionSeeds, _iterator, _step, _loop, _ret;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                encryptedList = this._config.forging.delegates;\n\n                if (!(!(encryptedList === null || encryptedList === void 0 ? void 0 : encryptedList.length) || !this._config.forging.force || !this._config.forging.defaultPassword)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 3:\n                this._logger.info(\"Loading \".concat(encryptedList.length, \" delegates using encrypted passphrases from config\"));\n\n                _context3.next = 6;\n                return data_access_1.getUsedHashOnions(this._db);\n\n              case 6:\n                usedHashOnions = _context3.sent;\n                _context3.next = 9;\n                return data_access_1.getRegisteredHashOnionSeeds(this._db);\n\n              case 9:\n                registeredHashOnionSeeds = _context3.sent;\n                _iterator = _createForOfIteratorHelper(encryptedList);\n                _context3.prev = 11;\n                _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {\n                  var encryptedItem, passphrase, decryptionError, keypair, delegateAddress, validatorAddress, account, registeredHashOnionSeed, hashOnionConfig, configHashOnionSeed, highestUsedHashOnion, highestCount;\n                  return _regeneratorRuntime.wrap(function _loop$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          encryptedItem = _step.value;\n                          passphrase = void 0;\n                          _context2.prev = 2;\n                          passphrase = lisk_cryptography_1.decryptPassphraseWithPassword(lisk_cryptography_1.parseEncryptedPassphrase(encryptedItem.encryptedPassphrase), _this._config.forging.defaultPassword);\n                          _context2.next = 11;\n                          break;\n\n                        case 6:\n                          _context2.prev = 6;\n                          _context2.t0 = _context2[\"catch\"](2);\n                          decryptionError = \"Invalid encryptedPassphrase for address: \".concat(encryptedItem.address.toString('hex'), \". \").concat(_context2.t0.message);\n\n                          _this._logger.error(decryptionError);\n\n                          throw new Error(decryptionError);\n\n                        case 11:\n                          keypair = lisk_cryptography_1.getPrivateAndPublicKeyFromPassphrase(passphrase);\n                          delegateAddress = lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey);\n\n                          if (delegateAddress.equals(encryptedItem.address)) {\n                            _context2.next = 15;\n                            break;\n                          }\n\n                          throw new Error(\"Invalid encryptedPassphrase for address: \".concat(encryptedItem.address.toString('hex'), \". Address do not match\"));\n\n                        case 15:\n                          validatorAddress = lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey);\n                          _context2.next = 18;\n                          return _this._chainModule.dataAccess.getAccountByAddress(validatorAddress);\n\n                        case 18:\n                          account = _context2.sent;\n\n                          _this._keypairs.set(validatorAddress, keypair);\n\n                          _this._logger.info(\"Forging enabled on account: \".concat(account.address.toString('hex')));\n\n                          registeredHashOnionSeed = registeredHashOnionSeeds.get(account.address);\n                          hashOnionConfig = _this._getHashOnionConfig(account.address);\n                          configHashOnionSeed = hashOnionConfig.hashes[hashOnionConfig.hashes.length - 1];\n\n                          if (registeredHashOnionSeed && !registeredHashOnionSeed.equals(configHashOnionSeed)) {\n                            _this._logger.warn(\"Hash onion for Account \".concat(account.address.toString('hex'), \" is not the same as previous one. Overwriting with new hash onion\"));\n\n                            usedHashOnions = usedHashOnions.filter(function (ho) {\n                              return !ho.address.equals(account.address);\n                            });\n                          }\n\n                          registeredHashOnionSeeds.set(account.address, configHashOnionSeed);\n                          highestUsedHashOnion = usedHashOnions.reduce(function (prev, current) {\n                            if (!current.address.equals(account.address)) {\n                              return prev;\n                            }\n\n                            if (!prev || prev.count < current.count) {\n                              return current;\n                            }\n\n                            return prev;\n                          }, undefined);\n\n                          if (highestUsedHashOnion) {\n                            _context2.next = 29;\n                            break;\n                          }\n\n                          return _context2.abrupt(\"return\", \"continue\");\n\n                        case 29:\n                          highestCount = highestUsedHashOnion.count;\n\n                          if (highestCount > hashOnionConfig.count - hashOnionConfig.distance) {\n                            _this._logger.warn({\n                              hashOnionUsed: highestCount\n                            }, \"Number of hashonion used(\".concat(highestCount, \") is close to end. Please update to the new hash onion\"));\n                          }\n\n                          if (!(highestCount >= hashOnionConfig.count)) {\n                            _context2.next = 33;\n                            break;\n                          }\n\n                          throw new Error(\"All of the hash onion is used for \".concat(account.address.toString('hex')));\n\n                        case 33:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _loop, null, [[2, 6]]);\n                });\n\n                _iterator.s();\n\n              case 14:\n                if ((_step = _iterator.n()).done) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                return _context3.delegateYield(_loop(), \"t0\", 16);\n\n              case 16:\n                _ret = _context3.t0;\n\n                if (!(_ret === \"continue\")) {\n                  _context3.next = 19;\n                  break;\n                }\n\n                return _context3.abrupt(\"continue\", 19);\n\n              case 19:\n                _context3.next = 14;\n                break;\n\n              case 21:\n                _context3.next = 26;\n                break;\n\n              case 23:\n                _context3.prev = 23;\n                _context3.t1 = _context3[\"catch\"](11);\n\n                _iterator.e(_context3.t1);\n\n              case 26:\n                _context3.prev = 26;\n\n                _iterator.f();\n\n                return _context3.finish(26);\n\n              case 29:\n                _context3.next = 31;\n                return data_access_1.setRegisteredHashOnionSeeds(this._db, registeredHashOnionSeeds);\n\n              case 31:\n                _context3.next = 33;\n                return data_access_1.setUsedHashOnions(this._db, usedHashOnions);\n\n              case 33:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee2, this, [[11, 23, 26, 29]]);\n      }));\n\n      function loadDelegates() {\n        return _loadDelegates.apply(this, arguments);\n      }\n\n      return loadDelegates;\n    }()\n  }, {\n    key: \"forge\",\n    value: function () {\n      var _forge = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var MS_IN_A_SEC, currentSlot, currentSlotTime, currentTime, waitThreshold, lastBlock, lastBlockSlot, validator, validatorKeypair, timestamp, previousBlock, transactions, delegateAddress, nextHeight, usedHashOnions, nextHashOnion, index, nextUsedHashOnion, updatedUsedHashOnion, forgedBlock;\n        return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                MS_IN_A_SEC = 1000;\n                currentSlot = this._chainModule.slots.getSlotNumber();\n                currentSlotTime = this._chainModule.slots.getSlotTime(currentSlot);\n                currentTime = Math.floor(new Date().getTime() / MS_IN_A_SEC);\n                waitThreshold = this._config.forging.waitThreshold;\n                lastBlock = this._chainModule.lastBlock;\n                lastBlockSlot = this._chainModule.slots.getSlotNumber(lastBlock.header.timestamp);\n\n                if (!(currentSlot === lastBlockSlot)) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                this._logger.trace({\n                  slot: currentSlot\n                }, 'Block already forged for the current slot');\n\n                return _context4.abrupt(\"return\");\n\n              case 10:\n                _context4.next = 12;\n                return this._chainModule.getValidator(currentTime);\n\n              case 12:\n                validator = _context4.sent;\n\n                if (validator) {\n                  _context4.next = 16;\n                  break;\n                }\n\n                this._logger.debug({\n                  currentSlot: this._chainModule.slots.getSlotNumber()\n                }, 'No validator is set for current time slot');\n\n                return _context4.abrupt(\"return\");\n\n              case 16:\n                validatorKeypair = this._keypairs.get(validator.address);\n\n                if (!(validatorKeypair === undefined)) {\n                  _context4.next = 20;\n                  break;\n                }\n\n                this._logger.debug({\n                  currentSlot: this._chainModule.slots.getSlotNumber()\n                }, 'Waiting for delegate slot');\n\n                return _context4.abrupt(\"return\");\n\n              case 20:\n                if (!(lastBlockSlot < currentSlot - 1 && currentTime <= currentSlotTime + waitThreshold)) {\n                  _context4.next = 24;\n                  break;\n                }\n\n                this._logger.info('Skipping forging to wait for last block');\n\n                this._logger.debug({\n                  currentSlot: currentSlot,\n                  lastBlockSlot: lastBlockSlot,\n                  waitThreshold: waitThreshold\n                }, 'Slot information');\n\n                return _context4.abrupt(\"return\");\n\n              case 24:\n                timestamp = currentSlotTime;\n                previousBlock = this._chainModule.lastBlock;\n                _context4.next = 28;\n                return this._forgingStrategy.getTransactionsForBlock();\n\n              case 28:\n                transactions = _context4.sent;\n                delegateAddress = lisk_cryptography_1.getAddressFromPublicKey(validatorKeypair.publicKey);\n                nextHeight = previousBlock.header.height + 1;\n                _context4.next = 33;\n                return data_access_1.getUsedHashOnions(this._db);\n\n              case 33:\n                usedHashOnions = _context4.sent;\n                nextHashOnion = this._getNextHashOnion(usedHashOnions, delegateAddress, nextHeight);\n                index = usedHashOnions.findIndex(function (ho) {\n                  return ho.address.equals(delegateAddress) && ho.count === nextHashOnion.count;\n                });\n                nextUsedHashOnion = {\n                  count: nextHashOnion.count,\n                  address: delegateAddress,\n                  height: nextHeight\n                };\n\n                if (index > -1) {\n                  usedHashOnions[index] = nextUsedHashOnion;\n                } else {\n                  usedHashOnions.push(nextUsedHashOnion);\n                }\n\n                updatedUsedHashOnion = this._filterUsedHashOnions(usedHashOnions, this._bftModule.finalizedHeight);\n                _context4.next = 41;\n                return this._create({\n                  keypair: validatorKeypair,\n                  timestamp: timestamp,\n                  transactions: transactions,\n                  previousBlock: previousBlock,\n                  seedReveal: nextHashOnion.hash\n                });\n\n              case 41:\n                forgedBlock = _context4.sent;\n                _context4.next = 44;\n                return data_access_1.setUsedHashOnions(this._db, updatedUsedHashOnion);\n\n              case 44:\n                _context4.next = 46;\n                return this._processorModule.process(forgedBlock);\n\n              case 46:\n                this._logger.info({\n                  id: forgedBlock.header.id,\n                  generatorAddress: delegateAddress,\n                  seedReveal: nextHashOnion.hash,\n                  height: forgedBlock.header.height,\n                  slot: this._chainModule.slots.getSlotNumber(forgedBlock.header.timestamp),\n                  reward: forgedBlock.header.reward.toString()\n                }, 'Forged new block');\n\n              case 47:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function forge() {\n        return _forge.apply(this, arguments);\n      }\n\n      return forge;\n    }()\n  }, {\n    key: \"getForgersKeyPairs\",\n    value: function getForgersKeyPairs() {\n      return this._keypairs;\n    }\n  }, {\n    key: \"getForgingStatusOfAllDelegates\",\n    value: function () {\n      var _getForgingStatusOfAllDelegates = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var forgingDelegates, forgersAddress, _iterator2, _step2, keypair, previouslyForgedMap, fullList;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                forgingDelegates = this._config.forging.delegates;\n                forgersAddress = new lisk_utils_1.dataStructures.BufferSet();\n                _iterator2 = _createForOfIteratorHelper(this._keypairs.values());\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    keypair = _step2.value;\n                    forgersAddress.add(lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey));\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                _context5.next = 6;\n                return data_access_1.getPreviouslyForgedMap(this._db);\n\n              case 6:\n                previouslyForgedMap = _context5.sent;\n                fullList = forgingDelegates === null || forgingDelegates === void 0 ? void 0 : forgingDelegates.map(function (forger) {\n                  return _objectSpread({\n                    forging: forgersAddress.has(forger.address),\n                    address: forger.address\n                  }, previouslyForgedMap.has(forger.address) ? previouslyForgedMap.get(forger.address) : {});\n                });\n                return _context5.abrupt(\"return\", fullList);\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getForgingStatusOfAllDelegates() {\n        return _getForgingStatusOfAllDelegates.apply(this, arguments);\n      }\n\n      return getForgingStatusOfAllDelegates;\n    }()\n  }, {\n    key: \"_getNextHashOnion\",\n    value: function _getNextHashOnion(usedHashOnions, address, height) {\n      var usedHashOnion = usedHashOnions.reduce(function (prev, current) {\n        if (!current.address.equals(address)) {\n          return prev;\n        }\n\n        if (current.height < height && (!prev || prev.height < current.height)) {\n          return current;\n        }\n\n        return prev;\n      }, undefined);\n\n      var hashOnionConfig = this._getHashOnionConfig(address);\n\n      if (!usedHashOnion) {\n        return {\n          hash: hashOnionConfig.hashes[0],\n          count: 0\n        };\n      }\n\n      var usedCount = usedHashOnion.count;\n      var nextCount = usedCount + 1;\n\n      if (nextCount > hashOnionConfig.count) {\n        this._logger.warn('All of the hash onion has been used already. Please update to the new hash onion.');\n\n        return {\n          hash: lisk_cryptography_1.generateHashOnionSeed(),\n          count: 0\n        };\n      }\n\n      var nextCheckpointIndex = nextCount % hashOnionConfig.distance === 0 ? Math.ceil(nextCount / hashOnionConfig.distance) + 1 : Math.ceil(nextCount / hashOnionConfig.distance);\n      var nextCheckpoint = hashOnionConfig.hashes[nextCheckpointIndex];\n      var hashes = lisk_cryptography_1.hashOnion(nextCheckpoint, hashOnionConfig.distance, 1);\n      var checkpointIndex = nextCount % hashOnionConfig.distance;\n      return {\n        hash: hashes[checkpointIndex],\n        count: nextCount\n      };\n    }\n  }, {\n    key: \"_getHashOnionConfig\",\n    value: function _getHashOnionConfig(address) {\n      var _a;\n\n      var delegateConfig = (_a = this._config.forging.delegates) === null || _a === void 0 ? void 0 : _a.find(function (d) {\n        return d.address.equals(address);\n      });\n\n      if (!(delegateConfig === null || delegateConfig === void 0 ? void 0 : delegateConfig.hashOnion)) {\n        throw new Error(\"Account \".concat(address.toString('hex'), \" does not have hash onion in the config\"));\n      }\n\n      return delegateConfig.hashOnion;\n    }\n  }, {\n    key: \"_filterUsedHashOnions\",\n    value: function _filterUsedHashOnions(usedHashOnions, finalizedHeight) {\n      var filteredObject = usedHashOnions.reduce(function (_ref2, current) {\n        var others = _ref2.others,\n            highest = _ref2.highest;\n        var prevUsed = highest.get(current.address);\n\n        if (prevUsed === undefined) {\n          highest.set(current.address, current);\n        } else if (prevUsed.height < current.height) {\n          others.push(prevUsed);\n          highest.set(current.address, current);\n        }\n\n        return {\n          highest: highest,\n          others: others\n        };\n      }, {\n        others: [],\n        highest: new lisk_utils_1.dataStructures.BufferMap()\n      });\n      var filtered = filteredObject.others.filter(function (ho) {\n        return ho.height > finalizedHeight;\n      });\n      return filtered.concat(filteredObject.highest.values());\n    }\n  }, {\n    key: \"_create\",\n    value: function () {\n      var _create2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref3) {\n        var transactions, keypair, seedReveal, timestamp, previousBlock, _a, _b, previouslyForgedMap, delegateAddress, height, previousBlockID, forgerInfo, maxHeightPreviouslyForged, maxHeightPrevoted, stateStore, reward, size, blockTransactions, transactionIds, _iterator3, _step3, transaction, transactionBytes, transactionRoot, header, isBFTProtocolCompliant, validSeedReveal, originalReward, headerBytesWithoutSignature, signature, headerBytes, id, block;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                transactions = _ref3.transactions, keypair = _ref3.keypair, seedReveal = _ref3.seedReveal, timestamp = _ref3.timestamp, previousBlock = _ref3.previousBlock;\n                _context6.next = 3;\n                return data_access_1.getPreviouslyForgedMap(this._db);\n\n              case 3:\n                previouslyForgedMap = _context6.sent;\n                delegateAddress = lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey);\n                height = previousBlock.header.height + 1;\n                previousBlockID = previousBlock.header.id;\n                forgerInfo = previouslyForgedMap.get(delegateAddress);\n                maxHeightPreviouslyForged = (_a = forgerInfo === null || forgerInfo === void 0 ? void 0 : forgerInfo.height) !== null && _a !== void 0 ? _a : 0;\n                _context6.next = 11;\n                return this._bftModule.getMaxHeightPrevoted((_b = previousBlock.header.asset) === null || _b === void 0 ? void 0 : _b.maxHeightPrevoted);\n\n              case 11:\n                maxHeightPrevoted = _context6.sent;\n                _context6.next = 14;\n                return this._chainModule.newStateStore();\n\n              case 14:\n                stateStore = _context6.sent;\n                reward = this._chainModule.calculateDefaultReward(height);\n                size = 0;\n                blockTransactions = [];\n                transactionIds = [];\n                _iterator3 = _createForOfIteratorHelper(transactions);\n                _context6.prev = 20;\n\n                _iterator3.s();\n\n              case 22:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context6.next = 32;\n                  break;\n                }\n\n                transaction = _step3.value;\n                transactionBytes = transaction.getBytes();\n\n                if (!(size + transactionBytes.length > this._chainModule.constants.maxPayloadLength)) {\n                  _context6.next = 27;\n                  break;\n                }\n\n                return _context6.abrupt(\"break\", 32);\n\n              case 27:\n                size += transactionBytes.length;\n                blockTransactions.push(transaction);\n                transactionIds.push(transaction.id);\n\n              case 30:\n                _context6.next = 22;\n                break;\n\n              case 32:\n                _context6.next = 37;\n                break;\n\n              case 34:\n                _context6.prev = 34;\n                _context6.t0 = _context6[\"catch\"](20);\n\n                _iterator3.e(_context6.t0);\n\n              case 37:\n                _context6.prev = 37;\n\n                _iterator3.f();\n\n                return _context6.finish(37);\n\n              case 40:\n                transactionRoot = new lisk_tree_1.MerkleTree(transactionIds).root;\n                header = {\n                  version: BLOCK_VERSION,\n                  height: height,\n                  reward: reward,\n                  transactionRoot: transactionRoot,\n                  previousBlockID: previousBlockID,\n                  timestamp: timestamp,\n                  generatorPublicKey: keypair.publicKey,\n                  asset: {\n                    seedReveal: seedReveal,\n                    maxHeightPreviouslyForged: maxHeightPreviouslyForged,\n                    maxHeightPrevoted: maxHeightPrevoted\n                  }\n                };\n                _context6.next = 44;\n                return this._bftModule.isBFTProtocolCompliant(header, stateStore);\n\n              case 44:\n                isBFTProtocolCompliant = _context6.sent;\n\n                if (!isBFTProtocolCompliant) {\n                  header.reward /= BigInt(4);\n\n                  this._logger.warn({\n                    originalReward: reward.toString(),\n                    deductedReward: header.reward.toString()\n                  }, 'Deducting reward due to BFT violation');\n                }\n\n                validSeedReveal = this._chainModule.isValidSeedReveal(header, stateStore);\n\n                if (!validSeedReveal) {\n                  originalReward = header.reward.toString();\n                  header.reward = BigInt(0);\n\n                  this._logger.warn({\n                    originalReward: originalReward,\n                    deductedReward: header.reward.toString()\n                  }, 'Deducting reward due to SeedReveal violation');\n                }\n\n                headerBytesWithoutSignature = this._chainModule.dataAccess.encodeBlockHeader(header, true);\n                signature = lisk_cryptography_1.signDataWithPrivateKey(Buffer.concat([this._chainModule.constants.networkIdentifier, headerBytesWithoutSignature]), keypair.privateKey);\n                headerBytes = this._chainModule.dataAccess.encodeBlockHeader(_objectSpread(_objectSpread({}, header), {}, {\n                  signature: signature\n                }));\n                id = lisk_cryptography_1.hash(headerBytes);\n                block = {\n                  header: _objectSpread(_objectSpread({}, header), {}, {\n                    signature: signature,\n                    id: id\n                  }),\n                  payload: blockTransactions\n                };\n                _context6.next = 55;\n                return data_access_1.saveMaxHeightPreviouslyForged(this._db, block.header, previouslyForgedMap);\n\n              case 55:\n                return _context6.abrupt(\"return\", block);\n\n              case 56:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee5, this, [[20, 34, 37, 40]]);\n      }));\n\n      function _create(_x8) {\n        return _create2.apply(this, arguments);\n      }\n\n      return _create;\n    }()\n  }]);\n\n  return Forger;\n}();\n\nexports.Forger = Forger;","map":{"version":3,"sources":["../../../src/node/forger/forger.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Forger = void 0;\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_tree_1 = require(\"@liskhq/lisk-tree\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst strategies_1 = require(\"./strategies\");\nconst data_access_1 = require(\"./data_access\");\nconst BLOCK_VERSION = 2;\nconst isSyncedWithNetwork = (lastBlockHeader, forgingInput) => {\n    if (lastBlockHeader.version === 0) {\n        return (forgingInput.height <= lastBlockHeader.height &&\n            forgingInput.maxHeightPrevoted <= lastBlockHeader.height);\n    }\n    return (forgingInput.maxHeightPrevoted < lastBlockHeader.asset.maxHeightPrevoted ||\n        (forgingInput.maxHeightPrevoted === lastBlockHeader.asset.maxHeightPrevoted &&\n            forgingInput.height < lastBlockHeader.height));\n};\nconst isZeroForgingInfo = (info) => info.height === 0 && info.maxHeightPrevoted === 0 && info.maxHeightPreviouslyForged === 0;\nconst IsEqualForgingInfo = (info1, info2) => info1.height === info2.height &&\n    info1.maxHeightPreviouslyForged === info2.maxHeightPreviouslyForged &&\n    info1.maxHeightPrevoted === info2.maxHeightPrevoted;\nclass Forger {\n    constructor({ forgingStrategy, logger, db, processorModule, bftModule, transactionPoolModule, chainModule, forgingDelegates, forgingForce, forgingDefaultPassword, forgingWaitThreshold, }) {\n        this._keypairs = new lisk_utils_1.dataStructures.BufferMap();\n        this._logger = logger;\n        this._db = db;\n        this._config = {\n            forging: {\n                delegates: forgingDelegates,\n                force: forgingForce,\n                defaultPassword: forgingDefaultPassword,\n                waitThreshold: forgingWaitThreshold,\n            },\n        };\n        this._processorModule = processorModule;\n        this._bftModule = bftModule;\n        this._transactionPoolModule = transactionPoolModule;\n        this._chainModule = chainModule;\n        this._forgingStrategy =\n            forgingStrategy !== null && forgingStrategy !== void 0 ? forgingStrategy : new strategies_1.HighFeeForgingStrategy({\n                transactionPoolModule: this._transactionPoolModule,\n                chainModule: this._chainModule,\n                maxPayloadLength: this._chainModule.constants.maxPayloadLength,\n                processorModule: this._processorModule,\n            });\n    }\n    delegatesEnabled() {\n        return this._keypairs.values().length > 0;\n    }\n    async updateForgingStatus(forgerAddress, password, forging, height, maxHeightPreviouslyForged, maxHeightPrevoted, overwrite) {\n        const encryptedForgers = this._config.forging.delegates;\n        const encryptedForger = encryptedForgers === null || encryptedForgers === void 0 ? void 0 : encryptedForgers.find(item => item.address.equals(forgerAddress));\n        let passphrase;\n        if (!encryptedForger) {\n            throw new Error(`Delegate with address: ${forgerAddress.toString('hex')} not found`);\n        }\n        try {\n            passphrase = lisk_cryptography_1.decryptPassphraseWithPassword(lisk_cryptography_1.parseEncryptedPassphrase(encryptedForger.encryptedPassphrase), password);\n        }\n        catch (e) {\n            throw new Error('Invalid password and public key combination');\n        }\n        const keypair = lisk_cryptography_1.getPrivateAndPublicKeyFromPassphrase(passphrase);\n        if (!lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey).equals(forgerAddress)) {\n            throw new Error(`Invalid keypair: ${lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey).toString('hex')}  and address: ${forgerAddress.toString('hex')} combination`);\n        }\n        if (!forging) {\n            this._keypairs.delete(forgerAddress);\n            this._logger.info(`Forging disabled on account: ${forgerAddress.toString('hex')}`);\n            return {\n                address: forgerAddress,\n                forging,\n            };\n        }\n        const lastBlockHeader = this._chainModule.lastBlock.header;\n        const previouslyForgedMap = await data_access_1.getPreviouslyForgedMap(this._db);\n        const forgingInput = { height, maxHeightPreviouslyForged, maxHeightPrevoted };\n        if (!isSyncedWithNetwork(lastBlockHeader, forgingInput)) {\n            throw new Error('Failed to enable forging as the node is not synced to the network.');\n        }\n        const forgerInfo = previouslyForgedMap.get(forgerAddress);\n        if (overwrite !== true) {\n            if (forgerInfo !== undefined && !IsEqualForgingInfo(forgerInfo, forgingInput)) {\n                throw new Error(`Failed to enable forging due to contradicting forger info. Current stored: ${JSON.stringify(forgerInfo)}`);\n            }\n            if (forgerInfo === undefined && !isZeroForgingInfo(forgingInput)) {\n                throw new Error('Failed to enable forging due to missing forger info.');\n            }\n        }\n        if (forgerInfo === undefined ||\n            (overwrite === true &&\n                forgerInfo !== undefined &&\n                !IsEqualForgingInfo(forgingInput, forgerInfo))) {\n            previouslyForgedMap.set(forgerAddress, {\n                height,\n                maxHeightPrevoted,\n                maxHeightPreviouslyForged,\n            });\n            await data_access_1.setPreviouslyForgedMap(this._db, previouslyForgedMap);\n            this._logger.info(forgingInput, 'Updated forgerInfo');\n        }\n        this._keypairs.set(forgerAddress, keypair);\n        this._logger.info(`Forging enabled on account: ${forgerAddress.toString('hex')}`);\n        return {\n            address: forgerAddress,\n            forging,\n        };\n    }\n    async loadDelegates() {\n        const encryptedList = this._config.forging.delegates;\n        if (!(encryptedList === null || encryptedList === void 0 ? void 0 : encryptedList.length) ||\n            !this._config.forging.force ||\n            !this._config.forging.defaultPassword) {\n            return;\n        }\n        this._logger.info(`Loading ${encryptedList.length} delegates using encrypted passphrases from config`);\n        let usedHashOnions = await data_access_1.getUsedHashOnions(this._db);\n        const registeredHashOnionSeeds = await data_access_1.getRegisteredHashOnionSeeds(this._db);\n        for (const encryptedItem of encryptedList) {\n            let passphrase;\n            try {\n                passphrase = lisk_cryptography_1.decryptPassphraseWithPassword(lisk_cryptography_1.parseEncryptedPassphrase(encryptedItem.encryptedPassphrase), this._config.forging.defaultPassword);\n            }\n            catch (error) {\n                const decryptionError = `Invalid encryptedPassphrase for address: ${encryptedItem.address.toString('hex')}. ${error.message}`;\n                this._logger.error(decryptionError);\n                throw new Error(decryptionError);\n            }\n            const keypair = lisk_cryptography_1.getPrivateAndPublicKeyFromPassphrase(passphrase);\n            const delegateAddress = lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey);\n            if (!delegateAddress.equals(encryptedItem.address)) {\n                throw new Error(`Invalid encryptedPassphrase for address: ${encryptedItem.address.toString('hex')}. Address do not match`);\n            }\n            const validatorAddress = lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey);\n            const account = await this._chainModule.dataAccess.getAccountByAddress(validatorAddress);\n            this._keypairs.set(validatorAddress, keypair);\n            this._logger.info(`Forging enabled on account: ${account.address.toString('hex')}`);\n            const registeredHashOnionSeed = registeredHashOnionSeeds.get(account.address);\n            const hashOnionConfig = this._getHashOnionConfig(account.address);\n            const configHashOnionSeed = hashOnionConfig.hashes[hashOnionConfig.hashes.length - 1];\n            if (registeredHashOnionSeed && !registeredHashOnionSeed.equals(configHashOnionSeed)) {\n                this._logger.warn(`Hash onion for Account ${account.address.toString('hex')} is not the same as previous one. Overwriting with new hash onion`);\n                usedHashOnions = usedHashOnions.filter(ho => !ho.address.equals(account.address));\n            }\n            registeredHashOnionSeeds.set(account.address, configHashOnionSeed);\n            const highestUsedHashOnion = usedHashOnions.reduce((prev, current) => {\n                if (!current.address.equals(account.address)) {\n                    return prev;\n                }\n                if (!prev || prev.count < current.count) {\n                    return current;\n                }\n                return prev;\n            }, undefined);\n            if (!highestUsedHashOnion) {\n                continue;\n            }\n            const { count: highestCount } = highestUsedHashOnion;\n            if (highestCount > hashOnionConfig.count - hashOnionConfig.distance) {\n                this._logger.warn({\n                    hashOnionUsed: highestCount,\n                }, `Number of hashonion used(${highestCount}) is close to end. Please update to the new hash onion`);\n            }\n            if (highestCount >= hashOnionConfig.count) {\n                throw new Error(`All of the hash onion is used for ${account.address.toString('hex')}`);\n            }\n        }\n        await data_access_1.setRegisteredHashOnionSeeds(this._db, registeredHashOnionSeeds);\n        await data_access_1.setUsedHashOnions(this._db, usedHashOnions);\n    }\n    async forge() {\n        const MS_IN_A_SEC = 1000;\n        const currentSlot = this._chainModule.slots.getSlotNumber();\n        const currentSlotTime = this._chainModule.slots.getSlotTime(currentSlot);\n        const currentTime = Math.floor(new Date().getTime() / MS_IN_A_SEC);\n        const { waitThreshold } = this._config.forging;\n        const { lastBlock } = this._chainModule;\n        const lastBlockSlot = this._chainModule.slots.getSlotNumber(lastBlock.header.timestamp);\n        if (currentSlot === lastBlockSlot) {\n            this._logger.trace({ slot: currentSlot }, 'Block already forged for the current slot');\n            return;\n        }\n        const validator = await this._chainModule.getValidator(currentTime);\n        if (!validator) {\n            this._logger.debug({ currentSlot: this._chainModule.slots.getSlotNumber() }, 'No validator is set for current time slot');\n            return;\n        }\n        const validatorKeypair = this._keypairs.get(validator.address);\n        if (validatorKeypair === undefined) {\n            this._logger.debug({ currentSlot: this._chainModule.slots.getSlotNumber() }, 'Waiting for delegate slot');\n            return;\n        }\n        if (lastBlockSlot < currentSlot - 1 && currentTime <= currentSlotTime + waitThreshold) {\n            this._logger.info('Skipping forging to wait for last block');\n            this._logger.debug({\n                currentSlot,\n                lastBlockSlot,\n                waitThreshold,\n            }, 'Slot information');\n            return;\n        }\n        const timestamp = currentSlotTime;\n        const previousBlock = this._chainModule.lastBlock;\n        const transactions = await this._forgingStrategy.getTransactionsForBlock();\n        const delegateAddress = lisk_cryptography_1.getAddressFromPublicKey(validatorKeypair.publicKey);\n        const nextHeight = previousBlock.header.height + 1;\n        const usedHashOnions = await data_access_1.getUsedHashOnions(this._db);\n        const nextHashOnion = this._getNextHashOnion(usedHashOnions, delegateAddress, nextHeight);\n        const index = usedHashOnions.findIndex(ho => ho.address.equals(delegateAddress) && ho.count === nextHashOnion.count);\n        const nextUsedHashOnion = {\n            count: nextHashOnion.count,\n            address: delegateAddress,\n            height: nextHeight,\n        };\n        if (index > -1) {\n            usedHashOnions[index] = nextUsedHashOnion;\n        }\n        else {\n            usedHashOnions.push(nextUsedHashOnion);\n        }\n        const updatedUsedHashOnion = this._filterUsedHashOnions(usedHashOnions, this._bftModule.finalizedHeight);\n        const forgedBlock = await this._create({\n            keypair: validatorKeypair,\n            timestamp,\n            transactions,\n            previousBlock,\n            seedReveal: nextHashOnion.hash,\n        });\n        await data_access_1.setUsedHashOnions(this._db, updatedUsedHashOnion);\n        await this._processorModule.process(forgedBlock);\n        this._logger.info({\n            id: forgedBlock.header.id,\n            generatorAddress: delegateAddress,\n            seedReveal: nextHashOnion.hash,\n            height: forgedBlock.header.height,\n            slot: this._chainModule.slots.getSlotNumber(forgedBlock.header.timestamp),\n            reward: forgedBlock.header.reward.toString(),\n        }, 'Forged new block');\n    }\n    getForgersKeyPairs() {\n        return this._keypairs;\n    }\n    async getForgingStatusOfAllDelegates() {\n        const forgingDelegates = this._config.forging.delegates;\n        const forgersAddress = new lisk_utils_1.dataStructures.BufferSet();\n        for (const keypair of this._keypairs.values()) {\n            forgersAddress.add(lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey));\n        }\n        const previouslyForgedMap = await data_access_1.getPreviouslyForgedMap(this._db);\n        const fullList = forgingDelegates === null || forgingDelegates === void 0 ? void 0 : forgingDelegates.map(forger => ({\n            forging: forgersAddress.has(forger.address),\n            address: forger.address,\n            ...(previouslyForgedMap.has(forger.address) ? previouslyForgedMap.get(forger.address) : {}),\n        }));\n        return fullList;\n    }\n    _getNextHashOnion(usedHashOnions, address, height) {\n        const usedHashOnion = usedHashOnions.reduce((prev, current) => {\n            if (!current.address.equals(address)) {\n                return prev;\n            }\n            if (current.height < height &&\n                (!prev || prev.height < current.height)) {\n                return current;\n            }\n            return prev;\n        }, undefined);\n        const hashOnionConfig = this._getHashOnionConfig(address);\n        if (!usedHashOnion) {\n            return {\n                hash: hashOnionConfig.hashes[0],\n                count: 0,\n            };\n        }\n        const { count: usedCount } = usedHashOnion;\n        const nextCount = usedCount + 1;\n        if (nextCount > hashOnionConfig.count) {\n            this._logger.warn('All of the hash onion has been used already. Please update to the new hash onion.');\n            return {\n                hash: lisk_cryptography_1.generateHashOnionSeed(),\n                count: 0,\n            };\n        }\n        const nextCheckpointIndex = nextCount % hashOnionConfig.distance === 0\n            ? Math.ceil(nextCount / hashOnionConfig.distance) + 1\n            : Math.ceil(nextCount / hashOnionConfig.distance);\n        const nextCheckpoint = hashOnionConfig.hashes[nextCheckpointIndex];\n        const hashes = lisk_cryptography_1.hashOnion(nextCheckpoint, hashOnionConfig.distance, 1);\n        const checkpointIndex = nextCount % hashOnionConfig.distance;\n        return {\n            hash: hashes[checkpointIndex],\n            count: nextCount,\n        };\n    }\n    _getHashOnionConfig(address) {\n        var _a;\n        const delegateConfig = (_a = this._config.forging.delegates) === null || _a === void 0 ? void 0 : _a.find(d => d.address.equals(address));\n        if (!(delegateConfig === null || delegateConfig === void 0 ? void 0 : delegateConfig.hashOnion)) {\n            throw new Error(`Account ${address.toString('hex')} does not have hash onion in the config`);\n        }\n        return delegateConfig.hashOnion;\n    }\n    _filterUsedHashOnions(usedHashOnions, finalizedHeight) {\n        const filteredObject = usedHashOnions.reduce(({ others, highest }, current) => {\n            const prevUsed = highest.get(current.address);\n            if (prevUsed === undefined) {\n                highest.set(current.address, current);\n            }\n            else if (prevUsed.height < current.height) {\n                others.push(prevUsed);\n                highest.set(current.address, current);\n            }\n            return {\n                highest,\n                others,\n            };\n        }, {\n            others: [],\n            highest: new lisk_utils_1.dataStructures.BufferMap(),\n        });\n        const filtered = filteredObject.others.filter(ho => ho.height > finalizedHeight);\n        return filtered.concat(filteredObject.highest.values());\n    }\n    async _create({ transactions, keypair, seedReveal, timestamp, previousBlock, }) {\n        var _a, _b;\n        const previouslyForgedMap = await data_access_1.getPreviouslyForgedMap(this._db);\n        const delegateAddress = lisk_cryptography_1.getAddressFromPublicKey(keypair.publicKey);\n        const height = previousBlock.header.height + 1;\n        const previousBlockID = previousBlock.header.id;\n        const forgerInfo = previouslyForgedMap.get(delegateAddress);\n        const maxHeightPreviouslyForged = (_a = forgerInfo === null || forgerInfo === void 0 ? void 0 : forgerInfo.height) !== null && _a !== void 0 ? _a : 0;\n        const maxHeightPrevoted = await this._bftModule.getMaxHeightPrevoted((_b = previousBlock.header.asset) === null || _b === void 0 ? void 0 : _b.maxHeightPrevoted);\n        const stateStore = await this._chainModule.newStateStore();\n        const reward = this._chainModule.calculateDefaultReward(height);\n        let size = 0;\n        const blockTransactions = [];\n        const transactionIds = [];\n        for (const transaction of transactions) {\n            const transactionBytes = transaction.getBytes();\n            if (size + transactionBytes.length > this._chainModule.constants.maxPayloadLength) {\n                break;\n            }\n            size += transactionBytes.length;\n            blockTransactions.push(transaction);\n            transactionIds.push(transaction.id);\n        }\n        const transactionRoot = new lisk_tree_1.MerkleTree(transactionIds).root;\n        const header = {\n            version: BLOCK_VERSION,\n            height,\n            reward,\n            transactionRoot,\n            previousBlockID,\n            timestamp,\n            generatorPublicKey: keypair.publicKey,\n            asset: {\n                seedReveal,\n                maxHeightPreviouslyForged,\n                maxHeightPrevoted,\n            },\n        };\n        const isBFTProtocolCompliant = await this._bftModule.isBFTProtocolCompliant(header, stateStore);\n        if (!isBFTProtocolCompliant) {\n            header.reward /= BigInt(4);\n            this._logger.warn({ originalReward: reward.toString(), deductedReward: header.reward.toString() }, 'Deducting reward due to BFT violation');\n        }\n        const validSeedReveal = this._chainModule.isValidSeedReveal(header, stateStore);\n        if (!validSeedReveal) {\n            const originalReward = header.reward.toString();\n            header.reward = BigInt(0);\n            this._logger.warn({ originalReward, deductedReward: header.reward.toString() }, 'Deducting reward due to SeedReveal violation');\n        }\n        const headerBytesWithoutSignature = this._chainModule.dataAccess.encodeBlockHeader(header, true);\n        const signature = lisk_cryptography_1.signDataWithPrivateKey(Buffer.concat([this._chainModule.constants.networkIdentifier, headerBytesWithoutSignature]), keypair.privateKey);\n        const headerBytes = this._chainModule.dataAccess.encodeBlockHeader({\n            ...header,\n            signature,\n        });\n        const id = lisk_cryptography_1.hash(headerBytes);\n        const block = {\n            header: {\n                ...header,\n                signature,\n                id,\n            },\n            payload: blockTransactions,\n        };\n        await data_access_1.saveMaxHeightPreviouslyForged(this._db, block.header, previouslyForgedMap);\n        return block;\n    }\n}\nexports.Forger = Forger;\n//# sourceMappingURL=forger.js.map"]},"metadata":{},"sourceType":"script"}