{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BlockSynchronizationMechanism = void 0;\n\nvar lisk_bft_1 = require(\"@liskhq/lisk-bft\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar base_synchronizer_1 = require(\"./base_synchronizer\");\n\nvar utils_1 = require(\"./utils\");\n\nvar errors_1 = require(\"./errors\");\n\nvar groupByPeer = function groupByPeer(peers) {\n  var groupedPeers = new lisk_utils_1.dataStructures.BufferMap();\n\n  var _iterator = _createForOfIteratorHelper(peers),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var peer = _step.value;\n      var grouped = groupedPeers.get(peer.options.lastBlockID);\n\n      if (grouped === undefined) {\n        grouped = [];\n      }\n\n      grouped.push(peer);\n      groupedPeers.set(peer.options.lastBlockID, grouped);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return groupedPeers;\n};\n\nvar BlockSynchronizationMechanism = /*#__PURE__*/function (_base_synchronizer_1$) {\n  _inherits(BlockSynchronizationMechanism, _base_synchronizer_1$);\n\n  var _super = _createSuper(BlockSynchronizationMechanism);\n\n  function BlockSynchronizationMechanism(_ref) {\n    var _this;\n\n    var logger = _ref.logger,\n        channel = _ref.channel,\n        bft = _ref.bft,\n        chain = _ref.chain,\n        processorModule = _ref.processorModule,\n        networkModule = _ref.networkModule;\n\n    _classCallCheck(this, BlockSynchronizationMechanism);\n\n    _this = _super.call(this, logger, channel, chain, networkModule);\n    _this.bft = bft;\n    _this._chain = chain;\n    _this.processorModule = processorModule;\n    return _this;\n  }\n\n  _createClass(BlockSynchronizationMechanism, [{\n    key: \"run\",\n    value: function () {\n      var _run = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(receivedBlock) {\n        var bestPeer, lastCommonBlock;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                bestPeer = this._computeBestPeer();\n                _context.next = 4;\n                return this._requestAndValidateLastBlock(bestPeer.peerId);\n\n              case 4:\n                _context.next = 6;\n                return this._revertToLastCommonBlock(bestPeer.peerId);\n\n              case 6:\n                lastCommonBlock = _context.sent;\n                _context.next = 9;\n                return this._requestAndApplyBlocksToCurrentChain(receivedBlock, lastCommonBlock, bestPeer.peerId);\n\n              case 9:\n                _context.next = 23;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](0);\n\n                if (!(_context.t0 instanceof errors_1.ApplyPenaltyAndRestartError)) {\n                  _context.next = 16;\n                  break;\n                }\n\n                this._applyPenaltyAndRestartSync(_context.t0.peerId, receivedBlock, _context.t0.reason);\n\n                return _context.abrupt(\"return\");\n\n              case 16:\n                if (!(_context.t0 instanceof errors_1.RestartError)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                this._restartSync(receivedBlock, _context.t0.reason);\n\n                return _context.abrupt(\"return\");\n\n              case 19:\n                if (!(_context.t0 instanceof errors_1.AbortError)) {\n                  _context.next = 22;\n                  break;\n                }\n\n                this._logger.info({\n                  error: _context.t0,\n                  reason: _context.t0.reason\n                }, 'Aborting synchronization mechanism');\n\n                return _context.abrupt(\"return\");\n\n              case 22:\n                throw _context.t0;\n\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 11]]);\n      }));\n\n      function run(_x) {\n        return _run.apply(this, arguments);\n      }\n\n      return run;\n    }()\n  }, {\n    key: \"isValidFor\",\n    value: function () {\n      var _isValidFor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var finalizedBlock, finalizedBlockSlot, currentBlockSlot, threeRounds;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._chain.dataAccess.getBlockHeaderByHeight(this.bft.finalizedHeight);\n\n              case 2:\n                finalizedBlock = _context2.sent;\n                finalizedBlockSlot = this._chain.slots.getSlotNumber(finalizedBlock.timestamp);\n                currentBlockSlot = this._chain.slots.getSlotNumber();\n                threeRounds = this._chain.numberOfValidators * 3;\n                return _context2.abrupt(\"return\", currentBlockSlot - finalizedBlockSlot > threeRounds);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function isValidFor() {\n        return _isValidFor.apply(this, arguments);\n      }\n\n      return isValidFor;\n    }()\n  }, {\n    key: \"_requestAndApplyBlocksWithinIDs\",\n    value: function () {\n      var _requestAndApplyBlocksWithinIDs2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peerId, fromId, toId) {\n        var maxFailedAttempts, failedAttempts, lastFetchedID, finished, blocks, _blocks$slice, _blocks$slice2, index, _iterator2, _step2, block;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                maxFailedAttempts = 10;\n                failedAttempts = 0;\n                lastFetchedID = fromId;\n                finished = false;\n\n              case 4:\n                if (!(!finished && failedAttempts < maxFailedAttempts)) {\n                  _context3.next = 53;\n                  break;\n                }\n\n                blocks = [];\n                _context3.prev = 6;\n                _context3.next = 9;\n                return this._getBlocksFromNetwork(peerId, lastFetchedID);\n\n              case 9:\n                blocks = _context3.sent;\n                _context3.next = 16;\n                break;\n\n              case 12:\n                _context3.prev = 12;\n                _context3.t0 = _context3[\"catch\"](6);\n                failedAttempts += 1;\n                return _context3.abrupt(\"continue\", 4);\n\n              case 16:\n                blocks.sort(function (a, b) {\n                  return a.header.height - b.header.height;\n                });\n                _blocks$slice = blocks.slice(-1);\n                _blocks$slice2 = _slicedToArray(_blocks$slice, 1);\n                lastFetchedID = _blocks$slice2[0].header.id;\n                index = blocks.findIndex(function (block) {\n                  return block.header.id.equals(toId);\n                });\n\n                if (index > -1) {\n                  blocks.splice(index + 1);\n                }\n\n                this._logger.debug({\n                  fromId: blocks[0].header.id,\n                  toId: blocks[blocks.length - 1].header.id\n                }, 'Applying obtained blocks from peer');\n\n                _context3.prev = 23;\n                _iterator2 = _createForOfIteratorHelper(blocks);\n                _context3.prev = 25;\n\n                _iterator2.s();\n\n              case 27:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context3.next = 36;\n                  break;\n                }\n\n                block = _step2.value;\n\n                if (!this._stop) {\n                  _context3.next = 31;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 31:\n                this.processorModule.validate(block);\n                _context3.next = 34;\n                return this.processorModule.processValidated(block);\n\n              case 34:\n                _context3.next = 27;\n                break;\n\n              case 36:\n                _context3.next = 41;\n                break;\n\n              case 38:\n                _context3.prev = 38;\n                _context3.t1 = _context3[\"catch\"](25);\n\n                _iterator2.e(_context3.t1);\n\n              case 41:\n                _context3.prev = 41;\n\n                _iterator2.f();\n\n                return _context3.finish(41);\n\n              case 44:\n                _context3.next = 50;\n                break;\n\n              case 46:\n                _context3.prev = 46;\n                _context3.t2 = _context3[\"catch\"](23);\n\n                this._logger.error({\n                  err: _context3.t2\n                }, 'Block processing failed');\n\n                throw new errors_1.BlockProcessingError();\n\n              case 50:\n                finished = this._chain.lastBlock.header.id.equals(toId);\n                _context3.next = 4;\n                break;\n\n              case 53:\n                if (!(failedAttempts === maxFailedAttempts)) {\n                  _context3.next = 55;\n                  break;\n                }\n\n                throw new errors_1.ApplyPenaltyAndRestartError(peerId, \"Peer didn't return any block after requesting blocks\");\n\n              case 55:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[6, 12], [23, 46], [25, 38, 41, 44]]);\n      }));\n\n      function _requestAndApplyBlocksWithinIDs(_x2, _x3, _x4) {\n        return _requestAndApplyBlocksWithinIDs2.apply(this, arguments);\n      }\n\n      return _requestAndApplyBlocksWithinIDs;\n    }()\n  }, {\n    key: \"_handleBlockProcessingError\",\n    value: function () {\n      var _handleBlockProcessingError2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(lastCommonBlock, peerId) {\n        var tempBlocks, _sort, _sort2, tipBeforeApplying, forkStatus, newTipHasPreference;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._logger.debug('Failed to apply obtained blocks from peer');\n\n                _context4.next = 3;\n                return this._chain.dataAccess.getTempBlocks();\n\n              case 3:\n                tempBlocks = _context4.sent;\n                _sort = _toConsumableArray(tempBlocks).sort(function (a, b) {\n                  return b.header.height - a.header.height;\n                }), _sort2 = _slicedToArray(_sort, 1), tipBeforeApplying = _sort2[0];\n\n                if (tipBeforeApplying) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                this._logger.error('Blocks temp table should not be empty');\n\n                throw new errors_1.RestartError('Blocks temp table should not be empty');\n\n              case 8:\n                forkStatus = this.bft.forkChoice(this._chain.lastBlock.header, tipBeforeApplying.header);\n                newTipHasPreference = forkStatus === lisk_bft_1.ForkStatus.DIFFERENT_CHAIN;\n\n                if (newTipHasPreference) {\n                  _context4.next = 28;\n                  break;\n                }\n\n                this._logger.debug({\n                  currentTip: this._chain.lastBlock.header.id,\n                  previousTip: tipBeforeApplying.header.id\n                }, 'Previous tip of the chain has preference over current tip. Restoring chain from temp table');\n\n                _context4.prev = 12;\n\n                this._logger.debug({\n                  height: lastCommonBlock.height\n                }, 'Deleting blocks after height');\n\n                _context4.next = 16;\n                return utils_1.deleteBlocksAfterHeight(this.processorModule, this._chain, this._logger, lastCommonBlock.height);\n\n              case 16:\n                this._logger.debug('Restoring blocks from temporary table');\n\n                _context4.next = 19;\n                return utils_1.restoreBlocks(this._chain, this.processorModule);\n\n              case 19:\n                this._logger.debug('Cleaning blocks temp table');\n\n                _context4.next = 22;\n                return utils_1.clearBlocksTempTable(this._chain);\n\n              case 22:\n                _context4.next = 27;\n                break;\n\n              case 24:\n                _context4.prev = 24;\n                _context4.t0 = _context4[\"catch\"](12);\n\n                this._logger.error({\n                  err: _context4.t0\n                }, 'Failed to restore blocks from blocks temp table');\n\n              case 27:\n                throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'New tip of the chain has no preference over the previous tip before synchronizing');\n\n              case 28:\n                this._logger.debug({\n                  currentTip: this._chain.lastBlock.header.id,\n                  previousTip: tipBeforeApplying.header.id\n                }, 'Current tip of the chain has preference over previous tip');\n\n                this._logger.debug('Cleaning blocks temporary table');\n\n                _context4.next = 32;\n                return utils_1.clearBlocksTempTable(this._chain);\n\n              case 32:\n                this._logger.info('Restarting block synchronization');\n\n                throw new errors_1.RestartError('The list of blocks has not been fully applied. Trying again');\n\n              case 34:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[12, 24]]);\n      }));\n\n      function _handleBlockProcessingError(_x5, _x6) {\n        return _handleBlockProcessingError2.apply(this, arguments);\n      }\n\n      return _handleBlockProcessingError;\n    }()\n  }, {\n    key: \"_requestAndApplyBlocksToCurrentChain\",\n    value: function () {\n      var _requestAndApplyBlocksToCurrentChain2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(receivedBlock, lastCommonBlock, peerId) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this._logger.debug({\n                  peerId: peerId,\n                  from: {\n                    blockId: lastCommonBlock.id,\n                    height: lastCommonBlock.height\n                  },\n                  to: {\n                    blockId: receivedBlock.header.id,\n                    height: receivedBlock.header.height\n                  }\n                }, 'Requesting blocks within ID range from peer');\n\n                _context5.prev = 1;\n                _context5.next = 4;\n                return this._requestAndApplyBlocksWithinIDs(peerId, lastCommonBlock.id, receivedBlock.header.id);\n\n              case 4:\n                _context5.next = 12;\n                break;\n\n              case 6:\n                _context5.prev = 6;\n                _context5.t0 = _context5[\"catch\"](1);\n\n                if (_context5.t0 instanceof errors_1.BlockProcessingError) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                throw _context5.t0;\n\n              case 10:\n                _context5.next = 12;\n                return this._handleBlockProcessingError(lastCommonBlock, peerId);\n\n              case 12:\n                this._logger.debug('Cleaning up blocks temporary table');\n\n                _context5.next = 15;\n                return utils_1.clearBlocksTempTable(this._chain);\n\n              case 15:\n                this._logger.debug({\n                  peerId: peerId\n                }, 'Successfully requested and applied blocks from peer');\n\n                return _context5.abrupt(\"return\", true);\n\n              case 17:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[1, 6]]);\n      }));\n\n      function _requestAndApplyBlocksToCurrentChain(_x7, _x8, _x9) {\n        return _requestAndApplyBlocksToCurrentChain2.apply(this, arguments);\n      }\n\n      return _requestAndApplyBlocksToCurrentChain;\n    }()\n  }, {\n    key: \"_revertToLastCommonBlock\",\n    value: function () {\n      var _revertToLastCommonBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(peerId) {\n        var lastCommonBlock;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this._logger.debug({\n                  peerId: peerId\n                }, 'Reverting chain to the last common block with peer');\n\n                this._logger.debug({\n                  peerId: peerId\n                }, 'Requesting the last common block from peer');\n\n                _context6.next = 4;\n                return this._requestLastCommonBlock(peerId);\n\n              case 4:\n                lastCommonBlock = _context6.sent;\n\n                if (lastCommonBlock) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'No common block has been found between the chain and the targeted peer');\n\n              case 7:\n                this._logger.debug({\n                  blockId: lastCommonBlock.id,\n                  height: lastCommonBlock.height\n                }, 'Found common block');\n\n                if (!(lastCommonBlock.height < this.bft.finalizedHeight)) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'The last common block height is less than the finalized height of the current chain');\n\n              case 10:\n                this._logger.debug({\n                  blockId: lastCommonBlock.id,\n                  height: lastCommonBlock.height\n                }, 'Deleting blocks after common block');\n\n                _context6.next = 13;\n                return utils_1.deleteBlocksAfterHeight(this.processorModule, this._chain, this._logger, lastCommonBlock.height, true);\n\n              case 13:\n                this._logger.debug({\n                  lastBlockID: this._chain.lastBlock.header.id\n                }, 'Successfully deleted blocks');\n\n                return _context6.abrupt(\"return\", lastCommonBlock);\n\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _revertToLastCommonBlock(_x10) {\n        return _revertToLastCommonBlock2.apply(this, arguments);\n      }\n\n      return _revertToLastCommonBlock;\n    }()\n  }, {\n    key: \"_requestLastCommonBlock\",\n    value: function () {\n      var _requestLastCommonBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(peerId) {\n        var blocksPerRequestLimit, requestLimit, numberOfRequests, highestCommonBlock, currentRound, currentHeight, heightList, blockHeaders, data;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                blocksPerRequestLimit = 10;\n                requestLimit = 3;\n                numberOfRequests = 1;\n                currentRound = Math.ceil(this._chain.lastBlock.header.height / this._chain.numberOfValidators);\n                currentHeight = currentRound * this._chain.numberOfValidators;\n\n              case 5:\n                if (!(!highestCommonBlock && numberOfRequests < requestLimit && currentHeight >= this.bft.finalizedHeight)) {\n                  _context7.next = 26;\n                  break;\n                }\n\n                heightList = utils_1.computeBlockHeightsList(this.bft.finalizedHeight, this._chain.numberOfValidators, blocksPerRequestLimit, currentRound);\n                _context7.next = 9;\n                return this._chain.dataAccess.getBlockHeadersWithHeights(heightList);\n\n              case 9:\n                blockHeaders = _context7.sent;\n                data = void 0;\n                _context7.prev = 11;\n                _context7.next = 14;\n                return this._getHighestCommonBlockFromNetwork(peerId, blockHeaders.map(function (block) {\n                  return block.id;\n                }));\n\n              case 14:\n                data = _context7.sent;\n                _context7.next = 21;\n                break;\n\n              case 17:\n                _context7.prev = 17;\n                _context7.t0 = _context7[\"catch\"](11);\n                numberOfRequests += 1;\n                return _context7.abrupt(\"continue\", 5);\n\n              case 21:\n                highestCommonBlock = data;\n                currentRound -= blocksPerRequestLimit;\n                currentHeight = currentRound * this._chain.numberOfValidators;\n                _context7.next = 5;\n                break;\n\n              case 26:\n                return _context7.abrupt(\"return\", highestCommonBlock);\n\n              case 27:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[11, 17]]);\n      }));\n\n      function _requestLastCommonBlock(_x11) {\n        return _requestLastCommonBlock2.apply(this, arguments);\n      }\n\n      return _requestLastCommonBlock;\n    }()\n  }, {\n    key: \"_requestAndValidateLastBlock\",\n    value: function () {\n      var _requestAndValidateLastBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(peerId) {\n        var networkLastBlock, _this$_blockDetachedS, validBlock, forkStatus, inDifferentChain;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this._logger.debug({\n                  peerId: peerId\n                }, 'Requesting tip of the chain from peer');\n\n                _context8.next = 3;\n                return this._getLastBlockFromNetwork(peerId);\n\n              case 3:\n                networkLastBlock = _context8.sent;\n\n                this._logger.debug({\n                  peerId: peerId,\n                  blockId: networkLastBlock.header.id\n                }, 'Received tip of the chain from peer');\n\n                _this$_blockDetachedS = this._blockDetachedStatus(networkLastBlock), validBlock = _this$_blockDetachedS.valid;\n                forkStatus = this.bft.forkChoice(networkLastBlock.header, this._chain.lastBlock.header);\n                inDifferentChain = forkStatus === lisk_bft_1.ForkStatus.DIFFERENT_CHAIN || networkLastBlock.header.id.equals(this._chain.lastBlock.header.id);\n\n                if (!(!validBlock || !inDifferentChain)) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'The tip of the chain of the peer is not valid or is not in a different chain');\n\n              case 10:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function _requestAndValidateLastBlock(_x12) {\n        return _requestAndValidateLastBlock2.apply(this, arguments);\n      }\n\n      return _requestAndValidateLastBlock;\n    }()\n  }, {\n    key: \"_blockDetachedStatus\",\n    value: function _blockDetachedStatus(networkLastBlock) {\n      try {\n        this.processorModule.validate(networkLastBlock);\n        return {\n          valid: true,\n          err: null\n        };\n      } catch (err) {\n        return {\n          valid: false,\n          err: err\n        };\n      }\n    }\n  }, {\n    key: \"_computeBestPeer\",\n    value: function _computeBestPeer() {\n      var peers = this._networkModule.getConnectedPeers();\n\n      if (!peers.length) {\n        throw new Error('List of connected peers is empty');\n      }\n\n      this._logger.trace({\n        peers: peers.map(function (peer) {\n          return peer.peerId;\n        })\n      }, 'List of connected peers');\n\n      var requiredProps = ['blockVersion', 'maxHeightPrevoted', 'height'];\n      var compatiblePeers = peers.filter(function (p) {\n        return requiredProps.every(function (prop) {\n          return Object.keys(p.options).includes(prop);\n        });\n      });\n\n      if (!compatiblePeers.length) {\n        throw new Error('Connected compatible peers list is empty');\n      }\n\n      this._logger.trace({\n        peers: compatiblePeers.map(function (peer) {\n          return peer.peerId;\n        })\n      }, 'List of compatible peers connected peers');\n\n      this._logger.debug('Computing the best peer to synchronize from');\n\n      var largestSubsetBymaxHeightPrevoted = utils_1.computeLargestSubsetMaxBy(compatiblePeers, function (peer) {\n        return peer.options.maxHeightPrevoted;\n      });\n      var largestSubsetByHeight = utils_1.computeLargestSubsetMaxBy(largestSubsetBymaxHeightPrevoted, function (peer) {\n        return peer.options.height;\n      });\n      var peersGroupedByBlockId = groupByPeer(largestSubsetByHeight);\n      var blockIds = peersGroupedByBlockId.entries();\n      var maxNumberOfPeersInSet = 0;\n      var selectedPeers = [];\n      var selectedBlockId = blockIds[0][0];\n\n      var _iterator3 = _createForOfIteratorHelper(blockIds),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              blockId = _step3$value[0],\n              peersByBlockId = _step3$value[1];\n\n          var numberOfPeersInSet = peersByBlockId.length;\n\n          if (numberOfPeersInSet > maxNumberOfPeersInSet || numberOfPeersInSet === maxNumberOfPeersInSet && selectedBlockId.compare(blockId) > 0) {\n            maxNumberOfPeersInSet = numberOfPeersInSet;\n            selectedPeers = peersByBlockId;\n            selectedBlockId = blockId;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var randomPeerIndex = Math.floor(Math.random() * selectedPeers.length);\n      var peersTip = {\n        id: Buffer.alloc(0),\n        height: selectedPeers[randomPeerIndex].options.height,\n        version: selectedPeers[randomPeerIndex].options.blockVersion,\n        previousBlockID: Buffer.alloc(0),\n        asset: {\n          maxHeightPrevoted: selectedPeers[randomPeerIndex].options.maxHeightPrevoted\n        }\n      };\n      var forkStatus = this.bft.forkChoice(peersTip, this._chain.lastBlock.header);\n      var tipHasPreference = forkStatus === lisk_bft_1.ForkStatus.DIFFERENT_CHAIN;\n\n      if (!tipHasPreference) {\n        throw new errors_1.AbortError(\"Peer tip does not have preference over current tip. Fork status: \".concat(forkStatus));\n      }\n\n      var bestPeer = selectedPeers[Math.floor(Math.random() * selectedPeers.length)];\n\n      this._logger.debug({\n        peer: bestPeer\n      }, 'Successfully computed the best peer');\n\n      return bestPeer;\n    }\n  }]);\n\n  return BlockSynchronizationMechanism;\n}(base_synchronizer_1.BaseSynchronizer);\n\nexports.BlockSynchronizationMechanism = BlockSynchronizationMechanism;","map":{"version":3,"sources":["../../../src/node/synchronizer/block_synchronization_mechanism.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BlockSynchronizationMechanism = void 0;\nconst lisk_bft_1 = require(\"@liskhq/lisk-bft\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst base_synchronizer_1 = require(\"./base_synchronizer\");\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst groupByPeer = (peers) => {\n    const groupedPeers = new lisk_utils_1.dataStructures.BufferMap();\n    for (const peer of peers) {\n        let grouped = groupedPeers.get(peer.options.lastBlockID);\n        if (grouped === undefined) {\n            grouped = [];\n        }\n        grouped.push(peer);\n        groupedPeers.set(peer.options.lastBlockID, grouped);\n    }\n    return groupedPeers;\n};\nclass BlockSynchronizationMechanism extends base_synchronizer_1.BaseSynchronizer {\n    constructor({ logger, channel, bft, chain, processorModule, networkModule, }) {\n        super(logger, channel, chain, networkModule);\n        this.bft = bft;\n        this._chain = chain;\n        this.processorModule = processorModule;\n    }\n    async run(receivedBlock) {\n        try {\n            const bestPeer = this._computeBestPeer();\n            await this._requestAndValidateLastBlock(bestPeer.peerId);\n            const lastCommonBlock = await this._revertToLastCommonBlock(bestPeer.peerId);\n            await this._requestAndApplyBlocksToCurrentChain(receivedBlock, lastCommonBlock, bestPeer.peerId);\n        }\n        catch (error) {\n            if (error instanceof errors_1.ApplyPenaltyAndRestartError) {\n                this._applyPenaltyAndRestartSync(error.peerId, receivedBlock, error.reason);\n                return;\n            }\n            if (error instanceof errors_1.RestartError) {\n                this._restartSync(receivedBlock, error.reason);\n                return;\n            }\n            if (error instanceof errors_1.AbortError) {\n                this._logger.info({ error, reason: error.reason }, 'Aborting synchronization mechanism');\n                return;\n            }\n            throw error;\n        }\n    }\n    async isValidFor() {\n        const finalizedBlock = await this._chain.dataAccess.getBlockHeaderByHeight(this.bft.finalizedHeight);\n        const finalizedBlockSlot = this._chain.slots.getSlotNumber(finalizedBlock.timestamp);\n        const currentBlockSlot = this._chain.slots.getSlotNumber();\n        const threeRounds = this._chain.numberOfValidators * 3;\n        return currentBlockSlot - finalizedBlockSlot > threeRounds;\n    }\n    async _requestAndApplyBlocksWithinIDs(peerId, fromId, toId) {\n        const maxFailedAttempts = 10;\n        let failedAttempts = 0;\n        let lastFetchedID = fromId;\n        let finished = false;\n        while (!finished && failedAttempts < maxFailedAttempts) {\n            let blocks = [];\n            try {\n                blocks = await this._getBlocksFromNetwork(peerId, lastFetchedID);\n            }\n            catch (error) {\n                failedAttempts += 1;\n                continue;\n            }\n            blocks.sort((a, b) => a.header.height - b.header.height);\n            [\n                {\n                    header: { id: lastFetchedID },\n                },\n            ] = blocks.slice(-1);\n            const index = blocks.findIndex(block => block.header.id.equals(toId));\n            if (index > -1) {\n                blocks.splice(index + 1);\n            }\n            this._logger.debug({\n                fromId: blocks[0].header.id,\n                toId: blocks[blocks.length - 1].header.id,\n            }, 'Applying obtained blocks from peer');\n            try {\n                for (const block of blocks) {\n                    if (this._stop) {\n                        return;\n                    }\n                    this.processorModule.validate(block);\n                    await this.processorModule.processValidated(block);\n                }\n            }\n            catch (err) {\n                this._logger.error({ err: err }, 'Block processing failed');\n                throw new errors_1.BlockProcessingError();\n            }\n            finished = this._chain.lastBlock.header.id.equals(toId);\n        }\n        if (failedAttempts === maxFailedAttempts) {\n            throw new errors_1.ApplyPenaltyAndRestartError(peerId, \"Peer didn't return any block after requesting blocks\");\n        }\n    }\n    async _handleBlockProcessingError(lastCommonBlock, peerId) {\n        this._logger.debug('Failed to apply obtained blocks from peer');\n        const tempBlocks = await this._chain.dataAccess.getTempBlocks();\n        const [tipBeforeApplying] = [...tempBlocks].sort((a, b) => b.header.height - a.header.height);\n        if (!tipBeforeApplying) {\n            this._logger.error('Blocks temp table should not be empty');\n            throw new errors_1.RestartError('Blocks temp table should not be empty');\n        }\n        const forkStatus = this.bft.forkChoice(this._chain.lastBlock.header, tipBeforeApplying.header);\n        const newTipHasPreference = forkStatus === lisk_bft_1.ForkStatus.DIFFERENT_CHAIN;\n        if (!newTipHasPreference) {\n            this._logger.debug({\n                currentTip: this._chain.lastBlock.header.id,\n                previousTip: tipBeforeApplying.header.id,\n            }, 'Previous tip of the chain has preference over current tip. Restoring chain from temp table');\n            try {\n                this._logger.debug({ height: lastCommonBlock.height }, 'Deleting blocks after height');\n                await utils_1.deleteBlocksAfterHeight(this.processorModule, this._chain, this._logger, lastCommonBlock.height);\n                this._logger.debug('Restoring blocks from temporary table');\n                await utils_1.restoreBlocks(this._chain, this.processorModule);\n                this._logger.debug('Cleaning blocks temp table');\n                await utils_1.clearBlocksTempTable(this._chain);\n            }\n            catch (error) {\n                this._logger.error({ err: error }, 'Failed to restore blocks from blocks temp table');\n            }\n            throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'New tip of the chain has no preference over the previous tip before synchronizing');\n        }\n        this._logger.debug({\n            currentTip: this._chain.lastBlock.header.id,\n            previousTip: tipBeforeApplying.header.id,\n        }, 'Current tip of the chain has preference over previous tip');\n        this._logger.debug('Cleaning blocks temporary table');\n        await utils_1.clearBlocksTempTable(this._chain);\n        this._logger.info('Restarting block synchronization');\n        throw new errors_1.RestartError('The list of blocks has not been fully applied. Trying again');\n    }\n    async _requestAndApplyBlocksToCurrentChain(receivedBlock, lastCommonBlock, peerId) {\n        this._logger.debug({\n            peerId,\n            from: {\n                blockId: lastCommonBlock.id,\n                height: lastCommonBlock.height,\n            },\n            to: {\n                blockId: receivedBlock.header.id,\n                height: receivedBlock.header.height,\n            },\n        }, 'Requesting blocks within ID range from peer');\n        try {\n            await this._requestAndApplyBlocksWithinIDs(peerId, lastCommonBlock.id, receivedBlock.header.id);\n        }\n        catch (err) {\n            if (!(err instanceof errors_1.BlockProcessingError)) {\n                throw err;\n            }\n            await this._handleBlockProcessingError(lastCommonBlock, peerId);\n        }\n        this._logger.debug('Cleaning up blocks temporary table');\n        await utils_1.clearBlocksTempTable(this._chain);\n        this._logger.debug({ peerId }, 'Successfully requested and applied blocks from peer');\n        return true;\n    }\n    async _revertToLastCommonBlock(peerId) {\n        this._logger.debug({ peerId }, 'Reverting chain to the last common block with peer');\n        this._logger.debug({ peerId }, 'Requesting the last common block from peer');\n        const lastCommonBlock = await this._requestLastCommonBlock(peerId);\n        if (!lastCommonBlock) {\n            throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'No common block has been found between the chain and the targeted peer');\n        }\n        this._logger.debug({\n            blockId: lastCommonBlock.id,\n            height: lastCommonBlock.height,\n        }, 'Found common block');\n        if (lastCommonBlock.height < this.bft.finalizedHeight) {\n            throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'The last common block height is less than the finalized height of the current chain');\n        }\n        this._logger.debug({\n            blockId: lastCommonBlock.id,\n            height: lastCommonBlock.height,\n        }, 'Deleting blocks after common block');\n        await utils_1.deleteBlocksAfterHeight(this.processorModule, this._chain, this._logger, lastCommonBlock.height, true);\n        this._logger.debug({ lastBlockID: this._chain.lastBlock.header.id }, 'Successfully deleted blocks');\n        return lastCommonBlock;\n    }\n    async _requestLastCommonBlock(peerId) {\n        const blocksPerRequestLimit = 10;\n        const requestLimit = 3;\n        let numberOfRequests = 1;\n        let highestCommonBlock;\n        let currentRound = Math.ceil(this._chain.lastBlock.header.height / this._chain.numberOfValidators);\n        let currentHeight = currentRound * this._chain.numberOfValidators;\n        while (!highestCommonBlock &&\n            numberOfRequests < requestLimit &&\n            currentHeight >= this.bft.finalizedHeight) {\n            const heightList = utils_1.computeBlockHeightsList(this.bft.finalizedHeight, this._chain.numberOfValidators, blocksPerRequestLimit, currentRound);\n            const blockHeaders = await this._chain.dataAccess.getBlockHeadersWithHeights(heightList);\n            let data;\n            try {\n                data = await this._getHighestCommonBlockFromNetwork(peerId, blockHeaders.map(block => block.id));\n            }\n            catch (e) {\n                numberOfRequests += 1;\n                continue;\n            }\n            highestCommonBlock = data;\n            currentRound -= blocksPerRequestLimit;\n            currentHeight = currentRound * this._chain.numberOfValidators;\n        }\n        return highestCommonBlock;\n    }\n    async _requestAndValidateLastBlock(peerId) {\n        this._logger.debug({ peerId }, 'Requesting tip of the chain from peer');\n        const networkLastBlock = await this._getLastBlockFromNetwork(peerId);\n        this._logger.debug({ peerId, blockId: networkLastBlock.header.id }, 'Received tip of the chain from peer');\n        const { valid: validBlock } = this._blockDetachedStatus(networkLastBlock);\n        const forkStatus = this.bft.forkChoice(networkLastBlock.header, this._chain.lastBlock.header);\n        const inDifferentChain = forkStatus === lisk_bft_1.ForkStatus.DIFFERENT_CHAIN ||\n            networkLastBlock.header.id.equals(this._chain.lastBlock.header.id);\n        if (!validBlock || !inDifferentChain) {\n            throw new errors_1.ApplyPenaltyAndRestartError(peerId, 'The tip of the chain of the peer is not valid or is not in a different chain');\n        }\n    }\n    _blockDetachedStatus(networkLastBlock) {\n        try {\n            this.processorModule.validate(networkLastBlock);\n            return { valid: true, err: null };\n        }\n        catch (err) {\n            return { valid: false, err: err };\n        }\n    }\n    _computeBestPeer() {\n        const peers = this._networkModule.getConnectedPeers();\n        if (!peers.length) {\n            throw new Error('List of connected peers is empty');\n        }\n        this._logger.trace({ peers: peers.map(peer => peer.peerId) }, 'List of connected peers');\n        const requiredProps = ['blockVersion', 'maxHeightPrevoted', 'height'];\n        const compatiblePeers = peers.filter(p => requiredProps.every(prop => Object.keys(p.options).includes(prop)));\n        if (!compatiblePeers.length) {\n            throw new Error('Connected compatible peers list is empty');\n        }\n        this._logger.trace({ peers: compatiblePeers.map(peer => peer.peerId) }, 'List of compatible peers connected peers');\n        this._logger.debug('Computing the best peer to synchronize from');\n        const largestSubsetBymaxHeightPrevoted = utils_1.computeLargestSubsetMaxBy(compatiblePeers, peer => peer.options.maxHeightPrevoted);\n        const largestSubsetByHeight = utils_1.computeLargestSubsetMaxBy(largestSubsetBymaxHeightPrevoted, peer => peer.options.height);\n        const peersGroupedByBlockId = groupByPeer(largestSubsetByHeight);\n        const blockIds = peersGroupedByBlockId.entries();\n        let maxNumberOfPeersInSet = 0;\n        let selectedPeers = [];\n        let selectedBlockId = blockIds[0][0];\n        for (const [blockId, peersByBlockId] of blockIds) {\n            const numberOfPeersInSet = peersByBlockId.length;\n            if (numberOfPeersInSet > maxNumberOfPeersInSet ||\n                (numberOfPeersInSet === maxNumberOfPeersInSet && selectedBlockId.compare(blockId) > 0)) {\n                maxNumberOfPeersInSet = numberOfPeersInSet;\n                selectedPeers = peersByBlockId;\n                selectedBlockId = blockId;\n            }\n        }\n        const randomPeerIndex = Math.floor(Math.random() * selectedPeers.length);\n        const peersTip = {\n            id: Buffer.alloc(0),\n            height: selectedPeers[randomPeerIndex].options.height,\n            version: selectedPeers[randomPeerIndex].options.blockVersion,\n            previousBlockID: Buffer.alloc(0),\n            asset: {\n                maxHeightPrevoted: selectedPeers[randomPeerIndex].options.maxHeightPrevoted,\n            },\n        };\n        const forkStatus = this.bft.forkChoice(peersTip, this._chain.lastBlock.header);\n        const tipHasPreference = forkStatus === lisk_bft_1.ForkStatus.DIFFERENT_CHAIN;\n        if (!tipHasPreference) {\n            throw new errors_1.AbortError(`Peer tip does not have preference over current tip. Fork status: ${forkStatus}`);\n        }\n        const bestPeer = selectedPeers[Math.floor(Math.random() * selectedPeers.length)];\n        this._logger.debug({ peer: bestPeer }, 'Successfully computed the best peer');\n        return bestPeer;\n    }\n}\nexports.BlockSynchronizationMechanism = BlockSynchronizationMechanism;\n//# sourceMappingURL=block_synchronization_mechanism.js.map"]},"metadata":{},"sourceType":"script"}