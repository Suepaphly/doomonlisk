{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validatePluginSpec = exports.getPluginExportPath = exports.BasePlugin = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar assert = require(\"assert\");\n\nvar path_1 = require(\"path\");\n\nvar lisk_validator_1 = require(\"@liskhq/lisk-validator\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar constants_1 = require(\"../constants\");\n\nvar errors_1 = require(\"../errors\");\n\nvar logger_1 = require(\"../logger\");\n\nvar system_dirs_1 = require(\"../system_dirs\");\n\nvar decodeTransactionToJSON = function decodeTransactionToJSON(transactionBuffer, baseSchema, assetsSchemas) {\n  var baseTransaction = lisk_codec_1.codec.decodeJSON(baseSchema, transactionBuffer);\n  var transactionTypeAsset = assetsSchemas.find(function (s) {\n    return s.assetID === baseTransaction.assetID && s.moduleID === baseTransaction.moduleID;\n  });\n\n  if (!transactionTypeAsset) {\n    throw new Error('Transaction type not found.');\n  }\n\n  var transactionAsset = lisk_codec_1.codec.decodeJSON(transactionTypeAsset.schema, Buffer.from(baseTransaction.asset, 'hex'));\n  return _objectSpread(_objectSpread({}, baseTransaction), {}, {\n    id: lisk_cryptography_1.hash(transactionBuffer).toString('hex'),\n    asset: transactionAsset\n  });\n};\n\nvar encodeTransactionFromJSON = function encodeTransactionFromJSON(transaction, baseSchema, assetsSchemas) {\n  var transactionTypeAsset = assetsSchemas.find(function (s) {\n    return s.assetID === transaction.assetID && s.moduleID === transaction.moduleID;\n  });\n\n  if (!transactionTypeAsset) {\n    throw new Error('Transaction type not found.');\n  }\n\n  var transactionAssetBuffer = lisk_codec_1.codec.encode(transactionTypeAsset.schema, lisk_codec_1.codec.fromJSON(transactionTypeAsset.schema, transaction.asset));\n  var transactionBuffer = lisk_codec_1.codec.encode(baseSchema, lisk_codec_1.codec.fromJSON(baseSchema, _objectSpread(_objectSpread({}, transaction), {}, {\n    asset: transactionAssetBuffer\n  })));\n  return transactionBuffer.toString('hex');\n};\n\nvar decodeAccountToJSON = function decodeAccountToJSON(encodedAccount, accountSchema) {\n  var decodedAccount = lisk_codec_1.codec.decodeJSON(accountSchema, encodedAccount);\n  return _objectSpread({}, decodedAccount);\n};\n\nvar _decodeRawBlock = function decodeRawBlock(blockSchema, encodedBlock) {\n  return lisk_codec_1.codec.decode(blockSchema, encodedBlock);\n};\n\nvar decodeBlockToJSON = function decodeBlockToJSON(registeredSchema, encodedBlock) {\n  var _lisk_codec_1$codec$d = lisk_codec_1.codec.decode(registeredSchema.block, encodedBlock),\n      header = _lisk_codec_1$codec$d.header,\n      payload = _lisk_codec_1$codec$d.payload;\n\n  var baseHeaderJSON = lisk_codec_1.codec.decodeJSON(registeredSchema.blockHeader, header);\n  var blockAssetJSON = lisk_codec_1.codec.decodeJSON(registeredSchema.blockHeadersAssets[baseHeaderJSON.version], Buffer.from(baseHeaderJSON.asset, 'hex'));\n  var payloadJSON = payload.map(function (transactionBuffer) {\n    return decodeTransactionToJSON(transactionBuffer, registeredSchema.transaction, registeredSchema.transactionsAssets);\n  });\n  var blockId = lisk_cryptography_1.hash(header);\n  return {\n    header: _objectSpread(_objectSpread({}, baseHeaderJSON), {}, {\n      asset: _objectSpread({}, blockAssetJSON),\n      id: blockId.toString('hex')\n    }),\n    payload: payloadJSON\n  };\n};\n\nvar BasePlugin = /*#__PURE__*/function () {\n  function BasePlugin(options) {\n    var _this = this;\n\n    _classCallCheck(this, BasePlugin);\n\n    var _a;\n\n    if (this.defaults) {\n      this.options = lisk_utils_1.objects.mergeDeep({}, (_a = this.defaults.default) !== null && _a !== void 0 ? _a : {}, options);\n      var errors = lisk_validator_1.validator.validate(this.defaults, this.options);\n\n      if (errors.length) {\n        throw new lisk_validator_1.LiskValidationError(_toConsumableArray(errors));\n      }\n    } else {\n      this.options = lisk_utils_1.objects.cloneDeep(options);\n    }\n\n    this.codec = {\n      decodeAccount: function decodeAccount(data) {\n        var accountBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n        return decodeAccountToJSON(accountBuffer, _this.schemas.account);\n      },\n      decodeBlock: function decodeBlock(data) {\n        var blockBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n        return decodeBlockToJSON(_this.schemas, blockBuffer);\n      },\n      decodeRawBlock: function decodeRawBlock(data) {\n        var blockBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n        return _decodeRawBlock(_this.schemas.block, blockBuffer);\n      },\n      decodeTransaction: function decodeTransaction(data) {\n        var transactionBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n        return decodeTransactionToJSON(transactionBuffer, _this.schemas.transaction, _this.schemas.transactionsAssets);\n      },\n      encodeTransaction: function encodeTransaction(transaction) {\n        return encodeTransactionFromJSON(transaction, _this.schemas.transaction, _this.schemas.transactionsAssets);\n      }\n    };\n  }\n\n  _createClass(BasePlugin, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(channel) {\n        var _this2 = this;\n\n        var dirs;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                dirs = system_dirs_1.systemDirs(this.options.appConfig.label, this.options.appConfig.rootPath);\n                this._logger = logger_1.createLogger({\n                  consoleLogLevel: this.options.appConfig.logger.consoleLogLevel,\n                  fileLogLevel: this.options.appConfig.logger.fileLogLevel,\n                  logFilePath: path_1.join(dirs.logs, \"plugin-\".concat(this.constructor.alias, \".log\")),\n                  module: \"plugin:\".concat(this.constructor.alias)\n                });\n                channel.once(constants_1.APP_EVENT_READY, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return channel.invoke('app:getSchema');\n\n                        case 2:\n                          _this2.schemas = _context.sent;\n\n                        case 3:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                })));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"defaults\",\n    get: function get() {\n      return undefined;\n    }\n  }], [{\n    key: \"alias\",\n    get: function get() {\n      throw new errors_1.ImplementationMissingError();\n    }\n  }, {\n    key: \"info\",\n    get: function get() {\n      throw new errors_1.ImplementationMissingError();\n    }\n  }]);\n\n  return BasePlugin;\n}();\n\nexports.BasePlugin = BasePlugin;\n\nvar getPluginExportPath = function getPluginExportPath(pluginKlass) {\n  var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var nodeModule;\n  var nodeModulePath;\n\n  try {\n    nodeModule = require(pluginKlass.info.name);\n    nodeModulePath = pluginKlass.info.name;\n  } catch (error) {}\n\n  if (!nodeModule && pluginKlass.info.exportPath) {\n    try {\n      nodeModule = require(pluginKlass.info.exportPath);\n      nodeModulePath = pluginKlass.info.exportPath;\n    } catch (error) {}\n  }\n\n  if (!nodeModule || !nodeModule[pluginKlass.name]) {\n    return;\n  }\n\n  if (strict && nodeModule[pluginKlass.name] !== pluginKlass) {\n    return;\n  }\n\n  return nodeModulePath;\n};\n\nexports.getPluginExportPath = getPluginExportPath;\n\nvar validatePluginSpec = function validatePluginSpec(PluginKlass) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var pluginObject = new PluginKlass(options);\n  assert(PluginKlass.alias, 'Plugin alias is required.');\n  assert(PluginKlass.info.name, 'Plugin name is required.');\n  assert(PluginKlass.info.author, 'Plugin author is required.');\n  assert(PluginKlass.info.version, 'Plugin version is required.');\n  assert(pluginObject.events, 'Plugin events are required.');\n  assert(pluginObject.actions, 'Plugin actions are required.');\n  assert(pluginObject.load, 'Plugin load action is required.');\n  assert(pluginObject.unload, 'Plugin unload actions is required.');\n\n  if (pluginObject.defaults) {\n    var errors = lisk_validator_1.validator.validateSchema(pluginObject.defaults);\n\n    if (errors.length) {\n      throw new lisk_validator_1.LiskValidationError(_toConsumableArray(errors));\n    }\n  }\n};\n\nexports.validatePluginSpec = validatePluginSpec;","map":{"version":3,"sources":["../../src/plugins/base_plugin.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validatePluginSpec = exports.getPluginExportPath = exports.BasePlugin = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst assert = require(\"assert\");\nconst path_1 = require(\"path\");\nconst lisk_validator_1 = require(\"@liskhq/lisk-validator\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst constants_1 = require(\"../constants\");\nconst errors_1 = require(\"../errors\");\nconst logger_1 = require(\"../logger\");\nconst system_dirs_1 = require(\"../system_dirs\");\nconst decodeTransactionToJSON = (transactionBuffer, baseSchema, assetsSchemas) => {\n    const baseTransaction = lisk_codec_1.codec.decodeJSON(baseSchema, transactionBuffer);\n    const transactionTypeAsset = assetsSchemas.find(s => s.assetID === baseTransaction.assetID && s.moduleID === baseTransaction.moduleID);\n    if (!transactionTypeAsset) {\n        throw new Error('Transaction type not found.');\n    }\n    const transactionAsset = lisk_codec_1.codec.decodeJSON(transactionTypeAsset.schema, Buffer.from(baseTransaction.asset, 'hex'));\n    return {\n        ...baseTransaction,\n        id: lisk_cryptography_1.hash(transactionBuffer).toString('hex'),\n        asset: transactionAsset,\n    };\n};\nconst encodeTransactionFromJSON = (transaction, baseSchema, assetsSchemas) => {\n    const transactionTypeAsset = assetsSchemas.find(s => s.assetID === transaction.assetID && s.moduleID === transaction.moduleID);\n    if (!transactionTypeAsset) {\n        throw new Error('Transaction type not found.');\n    }\n    const transactionAssetBuffer = lisk_codec_1.codec.encode(transactionTypeAsset.schema, lisk_codec_1.codec.fromJSON(transactionTypeAsset.schema, transaction.asset));\n    const transactionBuffer = lisk_codec_1.codec.encode(baseSchema, lisk_codec_1.codec.fromJSON(baseSchema, {\n        ...transaction,\n        asset: transactionAssetBuffer,\n    }));\n    return transactionBuffer.toString('hex');\n};\nconst decodeAccountToJSON = (encodedAccount, accountSchema) => {\n    const decodedAccount = lisk_codec_1.codec.decodeJSON(accountSchema, encodedAccount);\n    return {\n        ...decodedAccount,\n    };\n};\nconst decodeRawBlock = (blockSchema, encodedBlock) => lisk_codec_1.codec.decode(blockSchema, encodedBlock);\nconst decodeBlockToJSON = (registeredSchema, encodedBlock) => {\n    const { header, payload } = lisk_codec_1.codec.decode(registeredSchema.block, encodedBlock);\n    const baseHeaderJSON = lisk_codec_1.codec.decodeJSON(registeredSchema.blockHeader, header);\n    const blockAssetJSON = lisk_codec_1.codec.decodeJSON(registeredSchema.blockHeadersAssets[baseHeaderJSON.version], Buffer.from(baseHeaderJSON.asset, 'hex'));\n    const payloadJSON = payload.map(transactionBuffer => decodeTransactionToJSON(transactionBuffer, registeredSchema.transaction, registeredSchema.transactionsAssets));\n    const blockId = lisk_cryptography_1.hash(header);\n    return {\n        header: { ...baseHeaderJSON, asset: { ...blockAssetJSON }, id: blockId.toString('hex') },\n        payload: payloadJSON,\n    };\n};\nclass BasePlugin {\n    constructor(options) {\n        var _a;\n        if (this.defaults) {\n            this.options = lisk_utils_1.objects.mergeDeep({}, (_a = this.defaults.default) !== null && _a !== void 0 ? _a : {}, options);\n            const errors = lisk_validator_1.validator.validate(this.defaults, this.options);\n            if (errors.length) {\n                throw new lisk_validator_1.LiskValidationError([...errors]);\n            }\n        }\n        else {\n            this.options = lisk_utils_1.objects.cloneDeep(options);\n        }\n        this.codec = {\n            decodeAccount: (data) => {\n                const accountBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n                return decodeAccountToJSON(accountBuffer, this.schemas.account);\n            },\n            decodeBlock: (data) => {\n                const blockBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n                return decodeBlockToJSON(this.schemas, blockBuffer);\n            },\n            decodeRawBlock: (data) => {\n                const blockBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n                return decodeRawBlock(this.schemas.block, blockBuffer);\n            },\n            decodeTransaction: (data) => {\n                const transactionBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n                return decodeTransactionToJSON(transactionBuffer, this.schemas.transaction, this.schemas.transactionsAssets);\n            },\n            encodeTransaction: (transaction) => encodeTransactionFromJSON(transaction, this.schemas.transaction, this.schemas.transactionsAssets),\n        };\n    }\n    async init(channel) {\n        const dirs = system_dirs_1.systemDirs(this.options.appConfig.label, this.options.appConfig.rootPath);\n        this._logger = logger_1.createLogger({\n            consoleLogLevel: this.options.appConfig.logger.consoleLogLevel,\n            fileLogLevel: this.options.appConfig.logger.fileLogLevel,\n            logFilePath: path_1.join(dirs.logs, `plugin-${this.constructor.alias}.log`),\n            module: `plugin:${this.constructor.alias}`,\n        });\n        channel.once(constants_1.APP_EVENT_READY, async () => {\n            this.schemas = await channel.invoke('app:getSchema');\n        });\n    }\n    static get alias() {\n        throw new errors_1.ImplementationMissingError();\n    }\n    static get info() {\n        throw new errors_1.ImplementationMissingError();\n    }\n    get defaults() {\n        return undefined;\n    }\n}\nexports.BasePlugin = BasePlugin;\nconst getPluginExportPath = (pluginKlass, strict = true) => {\n    let nodeModule;\n    let nodeModulePath;\n    try {\n        nodeModule = require(pluginKlass.info.name);\n        nodeModulePath = pluginKlass.info.name;\n    }\n    catch (error) {\n    }\n    if (!nodeModule && pluginKlass.info.exportPath) {\n        try {\n            nodeModule = require(pluginKlass.info.exportPath);\n            nodeModulePath = pluginKlass.info.exportPath;\n        }\n        catch (error) {\n        }\n    }\n    if (!nodeModule || !nodeModule[pluginKlass.name]) {\n        return;\n    }\n    if (strict && nodeModule[pluginKlass.name] !== pluginKlass) {\n        return;\n    }\n    return nodeModulePath;\n};\nexports.getPluginExportPath = getPluginExportPath;\nconst validatePluginSpec = (PluginKlass, options = {}) => {\n    const pluginObject = new PluginKlass(options);\n    assert(PluginKlass.alias, 'Plugin alias is required.');\n    assert(PluginKlass.info.name, 'Plugin name is required.');\n    assert(PluginKlass.info.author, 'Plugin author is required.');\n    assert(PluginKlass.info.version, 'Plugin version is required.');\n    assert(pluginObject.events, 'Plugin events are required.');\n    assert(pluginObject.actions, 'Plugin actions are required.');\n    assert(pluginObject.load, 'Plugin load action is required.');\n    assert(pluginObject.unload, 'Plugin unload actions is required.');\n    if (pluginObject.defaults) {\n        const errors = lisk_validator_1.validator.validateSchema(pluginObject.defaults);\n        if (errors.length) {\n            throw new lisk_validator_1.LiskValidationError([...errors]);\n        }\n    }\n};\nexports.validatePluginSpec = validatePluginSpec;\n//# sourceMappingURL=base_plugin.js.map"]},"metadata":{},"sourceType":"script"}