{"ast":null,"code":"\"use strict\";\n\nvar _taggedTemplateLiteral = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _templateObject;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\n\nvar errors_1 = require(\"../errors\");\n\nvar codegen_1 = require(\"../codegen\");\n\nvar names_1 = require(\"../names\");\n\nvar boolError = {\n  message: \"boolean schema is false\"\n};\n\nfunction topBoolOrEmptySchema(it) {\n  var gen = it.gen,\n      schema = it.schema,\n      validateName = it.validateName;\n\n  if (schema === false) {\n    falseSchemaError(it, false);\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(names_1.default.data);\n  } else {\n    gen.assign(codegen_1._(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\", \".errors\"])), validateName), null);\n    gen.return(true);\n  }\n}\n\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\n\nfunction boolOrEmptySchema(it, valid) {\n  var gen = it.gen,\n      schema = it.schema;\n\n  if (schema === false) {\n    gen.var(valid, false); // TODO var\n\n    falseSchemaError(it);\n  } else {\n    gen.var(valid, true); // TODO var\n  }\n}\n\nexports.boolOrEmptySchema = boolOrEmptySchema;\n\nfunction falseSchemaError(it, overrideAllErrors) {\n  var gen = it.gen,\n      data = it.data; // TODO maybe some other interface should be used for non-keyword validation errors...\n\n  var cxt = {\n    gen: gen,\n    keyword: \"false schema\",\n    data: data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it: it\n  };\n  errors_1.reportError(cxt, boolError, undefined, overrideAllErrors);\n}","map":{"version":3,"sources":["../../../lib/compile/validate/boolSchema.ts"],"names":[],"mappings":";;;;;;;;;;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,IAAM,SAAS,GAA2B;AACxC,EAAA,OAAO,EAAE;AAD+B,CAA1C;;AAIA,SAAgB,oBAAhB,CAAqC,EAArC,EAAkD;AAChD,MAAO,GAAP,GAAoC,EAApC,CAAO,GAAP;AAAA,MAAY,MAAZ,GAAoC,EAApC,CAAY,MAAZ;AAAA,MAAoB,YAApB,GAAoC,EAApC,CAAoB,YAApB;;AACA,MAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,IAAA,gBAAgB,CAAC,EAAD,EAAK,KAAL,CAAhB;AACD,GAFD,MAEO,IAAI,OAAO,MAAP,IAAiB,QAAjB,IAA6B,MAAM,CAAC,MAAP,KAAkB,IAAnD,EAAyD;AAC9D,IAAA,GAAG,CAAC,MAAJ,CAAW,OAAA,CAAA,OAAA,CAAE,IAAb;AACD,GAFM,MAEA;AACL,IAAA,GAAG,CAAC,MAAJ,CAAW,SAAA,CAAA,CAAX,iFAAe,YAAf,GAAsC,IAAtC;AACA,IAAA,GAAG,CAAC,MAAJ,CAAW,IAAX;AACD;AACF;;AAVD,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAYA,SAAgB,iBAAhB,CAAkC,EAAlC,EAAiD,KAAjD,EAA4D;AAC1D,MAAO,GAAP,GAAsB,EAAtB,CAAO,GAAP;AAAA,MAAY,MAAZ,GAAsB,EAAtB,CAAY,MAAZ;;AACA,MAAI,MAAM,KAAK,KAAf,EAAsB;AACpB,IAAA,GAAG,CAAC,GAAJ,CAAQ,KAAR,EAAe,KAAf,EADoB,CACE;;AACtB,IAAA,gBAAgB,CAAC,EAAD,CAAhB;AACD,GAHD,MAGO;AACL,IAAA,GAAG,CAAC,GAAJ,CAAQ,KAAR,EAAe,IAAf,EADK,CACgB;AACtB;AACF;;AARD,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAUA,SAAS,gBAAT,CAA0B,EAA1B,EAAyC,iBAAzC,EAAoE;AAClE,MAAO,GAAP,GAAoB,EAApB,CAAO,GAAP;AAAA,MAAY,IAAZ,GAAoB,EAApB,CAAY,IAAZ,CADkE,CAElE;;AACA,MAAM,GAAG,GAAoB;AAC3B,IAAA,GAAG,EAAH,GAD2B;AAE3B,IAAA,OAAO,EAAE,cAFkB;AAG3B,IAAA,IAAI,EAAJ,IAH2B;AAI3B,IAAA,MAAM,EAAE,KAJmB;AAK3B,IAAA,UAAU,EAAE,KALe;AAM3B,IAAA,WAAW,EAAE,KANc;AAO3B,IAAA,MAAM,EAAE,EAPmB;AAQ3B,IAAA,EAAE,EAAF;AAR2B,GAA7B;AAUA,EAAA,QAAA,CAAA,WAAA,CAAY,GAAZ,EAAiB,SAAjB,EAA4B,SAA5B,EAAuC,iBAAvC;AACD","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign(codegen_1._ `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    errors_1.reportError(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map"]},"metadata":{},"sourceType":"script"}