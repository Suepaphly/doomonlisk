{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HighFeeForgingStrategy = void 0;\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar HighFeeForgingStrategy = /*#__PURE__*/function () {\n  function HighFeeForgingStrategy(_ref) {\n    var chainModule = _ref.chainModule,\n        processorModule = _ref.processorModule,\n        transactionPoolModule = _ref.transactionPoolModule,\n        maxPayloadLength = _ref.maxPayloadLength;\n\n    _classCallCheck(this, HighFeeForgingStrategy);\n\n    this._chainModule = chainModule;\n    this._processorModule = processorModule;\n    this._transactionPoolModule = transactionPoolModule;\n    this._constants = {\n      maxPayloadLength: maxPayloadLength\n    };\n  }\n\n  _createClass(HighFeeForgingStrategy, [{\n    key: \"getTransactionsForBlock\",\n    value: function () {\n      var _getTransactionsForBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _a, readyTransactions, stateStore, transactionsBySender, blockPayloadSize, feePriorityHeap, _iterator, _step, transactions, lowestNonceTrx, lowestNonceHighestFeeTrx, senderId, trsByteSize, _transactionsBySender, _transactionsBySender2, choppedArray, remainingTransactions, nextLowestNonceTransactions;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                readyTransactions = [];\n                _context.next = 3;\n                return this._chainModule.newStateStore();\n\n              case 3:\n                stateStore = _context.sent;\n                transactionsBySender = this._transactionPoolModule.getProcessableTransactions();\n                blockPayloadSize = 0;\n                feePriorityHeap = new lisk_utils_1.dataStructures.MaxHeap();\n                _iterator = _createForOfIteratorHelper(transactionsBySender.values());\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    transactions = _step.value;\n                    lowestNonceTrx = transactions[0];\n                    feePriorityHeap.push(lowestNonceTrx.feePriority, lowestNonceTrx);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n              case 9:\n                if (!(transactionsBySender.size > 0)) {\n                  _context.next = 40;\n                  break;\n                }\n\n                lowestNonceHighestFeeTrx = (_a = feePriorityHeap.pop()) === null || _a === void 0 ? void 0 : _a.value;\n\n                if (lowestNonceHighestFeeTrx) {\n                  _context.next = 13;\n                  break;\n                }\n\n                throw new Error('lowest nonce tx must exist');\n\n              case 13:\n                senderId = lisk_cryptography_1.getAddressFromPublicKey(lowestNonceHighestFeeTrx.senderPublicKey);\n                stateStore.createSnapshot();\n                _context.prev = 15;\n                _context.next = 18;\n                return this._processorModule.verifyTransactions([lowestNonceHighestFeeTrx], stateStore);\n\n              case 18:\n                _context.next = 25;\n                break;\n\n              case 20:\n                _context.prev = 20;\n                _context.t0 = _context[\"catch\"](15);\n                stateStore.restoreSnapshot();\n                transactionsBySender.delete(senderId);\n                return _context.abrupt(\"continue\", 9);\n\n              case 25:\n                trsByteSize = lowestNonceHighestFeeTrx.getBytes().length;\n\n                if (!(blockPayloadSize + trsByteSize > this._constants.maxPayloadLength)) {\n                  _context.next = 28;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 40);\n\n              case 28:\n                readyTransactions.push(lowestNonceHighestFeeTrx);\n                blockPayloadSize += trsByteSize;\n                _transactionsBySender = transactionsBySender.get(senderId), _transactionsBySender2 = _toArray(_transactionsBySender), choppedArray = _transactionsBySender2.slice(1);\n                transactionsBySender.set(senderId, choppedArray);\n                remainingTransactions = transactionsBySender.get(senderId);\n\n                if (!(!remainingTransactions || remainingTransactions.length === 0)) {\n                  _context.next = 36;\n                  break;\n                }\n\n                transactionsBySender.delete(senderId);\n                return _context.abrupt(\"continue\", 9);\n\n              case 36:\n                nextLowestNonceTransactions = transactionsBySender.get(senderId);\n                feePriorityHeap.push(nextLowestNonceTransactions[0].feePriority, nextLowestNonceTransactions[0]);\n                _context.next = 9;\n                break;\n\n              case 40:\n                return _context.abrupt(\"return\", readyTransactions);\n\n              case 41:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[15, 20]]);\n      }));\n\n      function getTransactionsForBlock() {\n        return _getTransactionsForBlock.apply(this, arguments);\n      }\n\n      return getTransactionsForBlock;\n    }()\n  }]);\n\n  return HighFeeForgingStrategy;\n}();\n\nexports.HighFeeForgingStrategy = HighFeeForgingStrategy;","map":{"version":3,"sources":["../../../src/node/forger/strategies.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HighFeeForgingStrategy = void 0;\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nclass HighFeeForgingStrategy {\n    constructor({ chainModule, processorModule, transactionPoolModule, maxPayloadLength, }) {\n        this._chainModule = chainModule;\n        this._processorModule = processorModule;\n        this._transactionPoolModule = transactionPoolModule;\n        this._constants = { maxPayloadLength };\n    }\n    async getTransactionsForBlock() {\n        var _a;\n        const readyTransactions = [];\n        const stateStore = await this._chainModule.newStateStore();\n        const transactionsBySender = this._transactionPoolModule.getProcessableTransactions();\n        let blockPayloadSize = 0;\n        const feePriorityHeap = new lisk_utils_1.dataStructures.MaxHeap();\n        for (const transactions of transactionsBySender.values()) {\n            const lowestNonceTrx = transactions[0];\n            feePriorityHeap.push(lowestNonceTrx.feePriority, lowestNonceTrx);\n        }\n        while (transactionsBySender.size > 0) {\n            const lowestNonceHighestFeeTrx = (_a = feePriorityHeap.pop()) === null || _a === void 0 ? void 0 : _a.value;\n            if (!lowestNonceHighestFeeTrx) {\n                throw new Error('lowest nonce tx must exist');\n            }\n            const senderId = lisk_cryptography_1.getAddressFromPublicKey(lowestNonceHighestFeeTrx.senderPublicKey);\n            stateStore.createSnapshot();\n            try {\n                await this._processorModule.verifyTransactions([lowestNonceHighestFeeTrx], stateStore);\n            }\n            catch (error) {\n                stateStore.restoreSnapshot();\n                transactionsBySender.delete(senderId);\n                continue;\n            }\n            const trsByteSize = lowestNonceHighestFeeTrx.getBytes().length;\n            if (blockPayloadSize + trsByteSize > this._constants.maxPayloadLength) {\n                break;\n            }\n            readyTransactions.push(lowestNonceHighestFeeTrx);\n            blockPayloadSize += trsByteSize;\n            const [, ...choppedArray] = transactionsBySender.get(senderId);\n            transactionsBySender.set(senderId, choppedArray);\n            const remainingTransactions = transactionsBySender.get(senderId);\n            if (!remainingTransactions || remainingTransactions.length === 0) {\n                transactionsBySender.delete(senderId);\n                continue;\n            }\n            const nextLowestNonceTransactions = transactionsBySender.get(senderId);\n            feePriorityHeap.push(nextLowestNonceTransactions[0].feePriority, nextLowestNonceTransactions[0]);\n        }\n        return readyTransactions;\n    }\n}\nexports.HighFeeForgingStrategy = HighFeeForgingStrategy;\n//# sourceMappingURL=strategies.js.map"]},"metadata":{},"sourceType":"script"}