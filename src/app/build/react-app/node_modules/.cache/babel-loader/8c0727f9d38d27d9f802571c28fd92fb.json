{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PeerServer = void 0;\n\nvar events_1 = require(\"events\");\n\nvar http = require(\"http\");\n\nvar socketcluster_server_1 = require(\"socketcluster-server\");\n\nvar url = require(\"url\");\n\nvar constants_1 = require(\"../constants\");\n\nvar errors_1 = require(\"../errors\");\n\nvar events_2 = require(\"../events\");\n\nvar utils_1 = require(\"../utils\");\n\nvar BASE_10_RADIX = 10;\n\nvar PeerServer = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(PeerServer, _events_1$EventEmitte);\n\n  var _super = _createSuper(PeerServer);\n\n  function PeerServer(config) {\n    var _this;\n\n    _classCallCheck(this, PeerServer);\n\n    _this = _super.call(this);\n    _this._nodeInfo = config.nodeInfo;\n    _this._hostIp = config.hostIp;\n    _this._port = config.port;\n    _this._secret = config.secret;\n    _this._peerBook = config.peerBook;\n    _this._httpServer = http.createServer();\n    _this._scServer = socketcluster_server_1.attach(_this._httpServer, {\n      path: constants_1.DEFAULT_HTTP_PATH,\n      wsEngineServerOptions: {\n        maxPayload: config.maxPayload\n      }\n    });\n    _this._maxPeerInfoSize = config.maxPeerInfoSize;\n    _this._peerHandshakeCheck = config.peerHandshakeCheck;\n    _this._invalidMessageCounter = new Map();\n    return _this;\n  }\n\n  _createClass(PeerServer, [{\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this._invalidMessageInterval) {\n                  clearTimeout(this._invalidMessageInterval);\n                }\n\n                _context.next = 3;\n                return this._stopWSServer();\n\n              case 3:\n                _context.next = 5;\n                return this._stopHTTPServer();\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._invalidMessageInterval = setInterval(function () {\n                  _this2._invalidMessageCounter = new Map();\n                }, constants_1.DEFAULT_RATE_CALCULATION_INTERVAL);\n\n                this._scServer.addMiddleware(this._scServer.MIDDLEWARE_HANDSHAKE_WS, function (req, next) {\n                  if (_this2._peerBook.bannedIPs.has(req.socket.remoteAddress)) {\n                    next(new errors_1.PeerInboundHandshakeError(constants_1.FORBIDDEN_CONNECTION_REASON, constants_1.FORBIDDEN_CONNECTION, req.socket.remoteAddress));\n                    return;\n                  }\n\n                  next();\n                });\n\n                this._scServer.on('handshake', function (socket) {\n                  if (_this2._peerBook.bannedIPs.has(socket.remoteAddress)) {\n                    if (socket.socket) {\n                      socket.socket.terminate();\n                    }\n                  }\n\n                  _this2._bindInvalidControlFrameEvents(socket);\n                });\n\n                this._scServer.wsServer.on('connection', function (ws, req) {\n                  _this2._handleIncomingPayload(ws, req);\n                });\n\n                this._scServer.on('connection', function (socket) {\n                  _this2._handleIncomingConnection(socket);\n                });\n\n                this._httpServer.listen(this._port, this._hostIp || constants_1.DEFAULT_NODE_HOST_IP);\n\n                if (!this._scServer.isReady) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 8:\n                return _context2.abrupt(\"return\", new Promise(function (resolve) {\n                  _this2._scServer.once('ready', function () {\n                    resolve();\n                  });\n                }));\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }, {\n    key: \"_terminateIncomingSocket\",\n    value: function _terminateIncomingSocket(socket, error, addToBannedPeers) {\n      if (socket.socket) {\n        socket.socket.terminate();\n      }\n\n      this.emit(events_2.EVENT_INBOUND_SOCKET_ERROR, error);\n\n      if (addToBannedPeers) {\n        var peerId = \"\".concat(socket.remoteAddress, \":\").concat(socket.remotePort);\n        this.emit(events_2.EVENT_BAN_PEER, peerId);\n      }\n    }\n  }, {\n    key: \"_disconnectSocketDueToFailedHandshake\",\n    value: function _disconnectSocketDueToFailedHandshake(socket, statusCode, closeReason) {\n      socket.disconnect(statusCode, closeReason);\n      this.emit(events_2.EVENT_FAILED_TO_ADD_INBOUND_PEER, new errors_1.PeerInboundHandshakeError(closeReason, statusCode, socket.remoteAddress, socket.request.url));\n    }\n  }, {\n    key: \"_validateQueryObject\",\n    value: function _validateQueryObject(socket) {\n      if (!socket.request.url) {\n        this._disconnectSocketDueToFailedHandshake(socket, constants_1.INVALID_CONNECTION_URL_CODE, constants_1.INVALID_CONNECTION_URL_REASON);\n\n        return undefined;\n      }\n\n      var _url$parse = url.parse(socket.request.url, true),\n          queryObject = _url$parse.query;\n\n      if (!queryObject) {\n        return undefined;\n      }\n\n      if (queryObject.nonce === this._nodeInfo.nonce) {\n        this._disconnectSocketDueToFailedHandshake(socket, constants_1.INVALID_CONNECTION_SELF_CODE, constants_1.INVALID_CONNECTION_SELF_REASON);\n\n        var selfport = queryObject.port ? +queryObject.port : this._port;\n\n        this._peerBook.removePeer({\n          peerId: utils_1.constructPeerId(socket.remoteAddress, selfport),\n          ipAddress: socket.remoteAddress,\n          port: selfport\n        });\n\n        return undefined;\n      }\n\n      if (typeof queryObject.networkVersion !== 'string' || typeof queryObject.networkIdentifier !== 'string') {\n        this._disconnectSocketDueToFailedHandshake(socket, constants_1.INVALID_CONNECTION_QUERY_CODE, constants_1.INVALID_CONNECTION_QUERY_REASON);\n\n        return undefined;\n      }\n\n      return queryObject;\n    }\n  }, {\n    key: \"_constructPeerInfoForInboundConnection\",\n    value: function _constructPeerInfoForInboundConnection(queryObject, socket) {\n      var _a;\n\n      var remoteport = parseInt(queryObject.port, BASE_10_RADIX);\n      var peerId = utils_1.constructPeerId(socket.remoteAddress, remoteport);\n      var advertiseAddress = queryObject.advertiseAddress,\n          nonce = queryObject.nonce,\n          networkIdentifier = queryObject.networkIdentifier,\n          networkVersion = queryObject.networkVersion;\n\n      var peerInPeerBook = this._peerBook.getPeer({\n        peerId: peerId,\n        ipAddress: socket.remoteAddress,\n        port: remoteport\n      });\n\n      var incomingPeerInfo = peerInPeerBook ? _objectSpread(_objectSpread({}, peerInPeerBook), {}, {\n        sharedState: _objectSpread(_objectSpread({}, peerInPeerBook.sharedState), {}, {\n          nonce: nonce,\n          networkVersion: networkVersion,\n          networkIdentifier: networkIdentifier,\n          options: _objectSpread({}, (_a = peerInPeerBook.sharedState) === null || _a === void 0 ? void 0 : _a.options)\n        }),\n        internalState: _objectSpread(_objectSpread({}, peerInPeerBook.internalState ? peerInPeerBook.internalState : utils_1.assignInternalInfo(peerInPeerBook, this._secret)), {}, {\n          advertiseAddress: advertiseAddress !== 'false',\n          connectionKind: constants_1.ConnectionKind.INBOUND\n        })\n      }) : {\n        sharedState: {\n          networkIdentifier: networkIdentifier,\n          nonce: nonce,\n          networkVersion: networkVersion,\n          options: {}\n        },\n        internalState: _objectSpread(_objectSpread({}, utils_1.assignInternalInfo({\n          peerId: peerId,\n          ipAddress: socket.remoteAddress,\n          port: remoteport\n        }, this._secret)), {}, {\n          advertiseAddress: advertiseAddress !== 'false',\n          connectionKind: constants_1.ConnectionKind.INBOUND\n        }),\n        peerId: peerId,\n        ipAddress: socket.remoteAddress,\n        port: remoteport\n      };\n\n      try {\n        var validPeerInfo = utils_1.validatePeerInfo(incomingPeerInfo, this._maxPeerInfoSize ? this._maxPeerInfoSize : constants_1.DEFAULT_MAX_PEER_INFO_SIZE);\n        return validPeerInfo;\n      } catch (error) {\n        this._disconnectSocketDueToFailedHandshake(socket, constants_1.INCOMPATIBLE_PEER_INFO_CODE, error);\n\n        return undefined;\n      }\n    }\n  }, {\n    key: \"_checkPeerCompatibility\",\n    value: function _checkPeerCompatibility(peerInfo, socket) {\n      var _this$_peerHandshakeC = this._peerHandshakeCheck(peerInfo, this._nodeInfo),\n          success = _this$_peerHandshakeC.success,\n          error = _this$_peerHandshakeC.error;\n\n      if (!success) {\n        var errorReason = error !== null && error !== void 0 ? error : constants_1.INCOMPATIBLE_PEER_UNKNOWN_REASON;\n\n        this._disconnectSocketDueToFailedHandshake(socket, constants_1.INCOMPATIBLE_PEER_CODE, errorReason);\n      }\n\n      return success;\n    }\n  }, {\n    key: \"_handleIncomingConnection\",\n    value: function _handleIncomingConnection(socket) {\n      var queryObject = this._validateQueryObject(socket);\n\n      if (!queryObject) {\n        return;\n      }\n\n      var incomingPeerInfo = this._constructPeerInfoForInboundConnection(queryObject, socket);\n\n      if (!incomingPeerInfo) {\n        return;\n      }\n\n      if (!this._checkPeerCompatibility(incomingPeerInfo, socket)) {\n        return;\n      }\n\n      var incomingPeerConnection = {\n        peerInfo: incomingPeerInfo,\n        socket: socket\n      };\n      this.emit(events_2.EVENT_NEW_INBOUND_PEER_CONNECTION, incomingPeerConnection);\n    }\n  }, {\n    key: \"_bindInvalidControlFrameEvents\",\n    value: function _bindInvalidControlFrameEvents(socket) {\n      var _this3 = this;\n\n      socket.socket.on('ping', function () {\n        _this3._terminateIncomingSocket(socket, \"Terminated connection peer: \".concat(socket.remoteAddress, \", reason: malicious ping control frames\"), true);\n      });\n      socket.socket.on('pong', function () {\n        _this3._terminateIncomingSocket(socket, \"Terminated connection peer: \".concat(socket.remoteAddress, \", reason: malicious pong control frames\"), true);\n      });\n    }\n  }, {\n    key: \"_handleIncomingPayload\",\n    value: function _handleIncomingPayload(ws, _req) {\n      var _this4 = this;\n\n      ws.on('message', function (message) {\n        var _a, _b;\n\n        if (message === '#2') {\n          return;\n        }\n\n        var MAX_EVENT_NAME_LENGTH = 128;\n        var _ws$_socket$_peername = ws._socket._peername,\n            peerIpAddress = _ws$_socket$_peername.address,\n            port = _ws$_socket$_peername.port;\n        var peerId = utils_1.constructPeerId(peerIpAddress, port);\n\n        try {\n          var parsed = JSON.parse(message);\n          utils_1.validatePacket(parsed);\n          var invalidEvents = new Set(['#authenticate', '#removeAuthToken', '#subscribe', '#unsubscribe', '#publish']);\n\n          if (parsed.event && typeof parsed.event !== 'string' || invalidEvents.has(parsed.event) || ((_a = parsed.event) === null || _a === void 0 ? void 0 : _a.length) > MAX_EVENT_NAME_LENGTH) {\n            throw new errors_1.InvalidPayloadError('Received invalid payload', parsed);\n          }\n\n          if (parsed.event === '#disconnect') {\n            var count = ((_b = _this4._invalidMessageCounter.get(peerIpAddress)) !== null && _b !== void 0 ? _b : 0) + 1;\n\n            _this4._invalidMessageCounter.set(peerIpAddress, count);\n\n            if (count > constants_1.DEFAULT_CONTROL_MESSAGE_LIMIT) {\n              throw new errors_1.InvalidDisconnectEventError(\"Exhausted disconnected event: peer disconnected \".concat(count, \" times above the limit of \").concat(constants_1.DEFAULT_CONTROL_MESSAGE_LIMIT));\n            }\n          }\n        } catch (error) {\n          ws.terminate();\n\n          _this4.emit(events_2.EVENT_BAN_PEER, peerId);\n\n          _this4.emit(events_2.EVENT_INBOUND_SOCKET_ERROR, \"Banned peer with Ip: \".concat(peerIpAddress, \", reason: \").concat(error, \", message: \").concat(message));\n        }\n      });\n    }\n  }, {\n    key: \"_stopHTTPServer\",\n    value: function () {\n      var _stopHTTPServer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this5 = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", new Promise(function (resolve) {\n                  _this5._httpServer.close(function () {\n                    resolve();\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function _stopHTTPServer() {\n        return _stopHTTPServer2.apply(this, arguments);\n      }\n\n      return _stopHTTPServer;\n    }()\n  }, {\n    key: \"_stopWSServer\",\n    value: function () {\n      var _stopWSServer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this6 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", new Promise(function (resolve) {\n                  _this6._scServer.close(function () {\n                    resolve();\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function _stopWSServer() {\n        return _stopWSServer2.apply(this, arguments);\n      }\n\n      return _stopWSServer;\n    }()\n  }]);\n\n  return PeerServer;\n}(events_1.EventEmitter);\n\nexports.PeerServer = PeerServer;","map":{"version":3,"sources":["../../src/peer_server/peer_server.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAcA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,IAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AAEA,IAAA,sBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AACA,IAAA,GAAA,GAAA,OAAA,CAAA,KAAA,CAAA;;AAEA,IAAA,WAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAmBA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAKA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAcA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAMA,IAAM,aAAa,GAAG,EAAtB;;IAEa,U;;;;;AAcZ,sBAAmB,MAAnB,EAA2C;AAAA;;AAAA;;AAC1C;AACA,UAAK,SAAL,GAAiB,MAAM,CAAC,QAAxB;AACA,UAAK,OAAL,GAAe,MAAM,CAAC,MAAtB;AACA,UAAK,KAAL,GAAa,MAAM,CAAC,IAApB;AACA,UAAK,OAAL,GAAe,MAAM,CAAC,MAAtB;AACA,UAAK,SAAL,GAAiB,MAAM,CAAC,QAAxB;AACA,UAAK,WAAL,GAAmB,IAAI,CAAC,YAAL,EAAnB;AACA,UAAK,SAAL,GAAiB,sBAAA,CAAA,MAAA,CAAO,MAAK,WAAZ,EAAyB;AACzC,MAAA,IAAI,EAAE,WAAA,CAAA,iBADmC;AAEzC,MAAA,qBAAqB,EAAE;AACtB,QAAA,UAAU,EAAE,MAAM,CAAC;AADG;AAFkB,KAAzB,CAAjB;AAMA,UAAK,gBAAL,GAAwB,MAAM,CAAC,eAA/B;AACA,UAAK,mBAAL,GAA2B,MAAM,CAAC,kBAAlC;AACA,UAAK,sBAAL,GAA8B,IAAI,GAAJ,EAA9B;AAhB0C;AAiB1C;;;;;2EAEM;AAAA;AAAA;AAAA;AAAA;AACN,oBAAI,KAAK,uBAAT,EAAkC;AACjC,kBAAA,YAAY,CAAC,KAAK,uBAAN,CAAZ;AACA;;AAHK;AAAA,uBAKA,KAAK,aAAL,EALA;;AAAA;AAAA;AAAA,uBAMA,KAAK,eAAL,EANA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;4EASA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACN,qBAAK,uBAAL,GAA+B,WAAW,CAAC,YAAK;AAC/C,kBAAA,MAAI,CAAC,sBAAL,GAA8B,IAAI,GAAJ,EAA9B;AACA,iBAFyC,EAEvC,WAAA,CAAA,iCAFuC,CAA1C;;AAIA,qBAAK,SAAL,CAAe,aAAf,CACC,KAAK,SAAL,CAAe,uBADhB,EAEC,UAAC,GAAD,EAA4B,IAA5B,EAA2E;AAE1E,sBAAI,MAAI,CAAC,SAAL,CAAe,SAAf,CAAyB,GAAzB,CAA6B,GAAG,CAAC,MAAJ,CAAW,aAAxC,CAAJ,EAAsE;AACrE,oBAAA,IAAI,CACH,IAAI,QAAA,CAAA,yBAAJ,CACC,WAAA,CAAA,2BADD,EAEC,WAAA,CAAA,oBAFD,EAGC,GAAG,CAAC,MAAJ,CAAW,aAHZ,CADG,CAAJ;AAQA;AACA;;AAED,kBAAA,IAAI;AACJ,iBAjBF;;AAoBA,qBAAK,SAAL,CAAe,EAAf,CAAkB,WAAlB,EAA+B,UAAC,MAAD,EAAiC;AAC/D,sBAAI,MAAI,CAAC,SAAL,CAAe,SAAf,CAAyB,GAAzB,CAA6B,MAAM,CAAC,aAApC,CAAJ,EAAwD;AAEvD,wBAAK,MAAc,CAAC,MAApB,EAA4B;AAE1B,sBAAA,MAAc,CAAC,MAAf,CAAsB,SAAtB;AACD;AACD;;AAED,kBAAA,MAAI,CAAC,8BAAL,CAAoC,MAApC;AACA,iBAVD;;AAcC,qBAAK,SAAL,CAAuB,QAAvB,CAAgC,EAAhC,CAAmC,YAAnC,EAAiD,UAAC,EAAD,EAAU,GAAV,EAAsB;AACvE,kBAAA,MAAI,CAAC,sBAAL,CAA4B,EAA5B,EAAgC,GAAhC;AACA,iBAFA;;AAID,qBAAK,SAAL,CAAe,EAAf,CAAkB,YAAlB,EAAgC,UAAC,MAAD,EAAiC;AAChE,kBAAA,MAAI,CAAC,yBAAL,CAA+B,MAA/B;AACA,iBAFD;;AAIA,qBAAK,WAAL,CAAiB,MAAjB,CACC,KAAK,KADN,EAGC,KAAK,OAAL,IAAgB,WAAA,CAAA,oBAHjB;;AA/CM,qBAqDF,KAAK,SAAL,CAAe,OArDb;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,kDA0DC,IAAI,OAAJ,CAAkB,UAAA,OAAO,EAAG;AAClC,kBAAA,MAAI,CAAC,SAAL,CAAe,IAAf,CAAoB,OAApB,EAA6B,YAAK;AACjC,oBAAA,OAAO;AACP,mBAFD;AAGA,iBAJM,CA1DD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WAiEC,kCACP,MADO,EAEP,KAFO,EAGP,gBAHO,EAGmB;AAG1B,UAAK,MAAc,CAAC,MAApB,EAA4B;AAE1B,QAAA,MAAc,CAAC,MAAf,CAAsB,SAAtB;AACD;;AAED,WAAK,IAAL,CAAU,QAAA,CAAA,0BAAV,EAAsC,KAAtC;;AAGA,UAAI,gBAAJ,EAAsB;AACrB,YAAM,MAAM,aAAM,MAAM,CAAC,aAAb,cAA8B,MAAM,CAAC,UAArC,CAAZ;AAEA,aAAK,IAAL,CAAU,QAAA,CAAA,cAAV,EAA0B,MAA1B;AACA;AACD;;;WAEO,+CACP,MADO,EAEP,UAFO,EAGP,WAHO,EAGY;AAEnB,MAAA,MAAM,CAAC,UAAP,CAAkB,UAAlB,EAA8B,WAA9B;AAEA,WAAK,IAAL,CACC,QAAA,CAAA,gCADD,EAEC,IAAI,QAAA,CAAA,yBAAJ,CACC,WADD,EAEC,UAFD,EAGC,MAAM,CAAC,aAHR,EAIC,MAAM,CAAC,OAAP,CAAe,GAJhB,CAFD;AASA;;;WAEO,8BAAqB,MAArB,EAA2C;AAClD,UAAI,CAAC,MAAM,CAAC,OAAP,CAAe,GAApB,EAAyB;AACxB,aAAK,qCAAL,CACC,MADD,EAEC,WAAA,CAAA,2BAFD,EAGC,WAAA,CAAA,6BAHD;;AAMA,eAAO,SAAP;AACA;;AACD,uBAA+B,GAAG,CAAC,KAAJ,CAAU,MAAM,CAAC,OAAP,CAAe,GAAzB,EAA8B,IAA9B,CAA/B;AAAA,UAAe,WAAf,cAAQ,KAAR;;AAGA,UAAI,CAAC,WAAL,EAAkB;AACjB,eAAO,SAAP;AACA;;AAED,UAAI,WAAW,CAAC,KAAZ,KAAsB,KAAK,SAAL,CAAe,KAAzC,EAAgD;AAC/C,aAAK,qCAAL,CACC,MADD,EAEC,WAAA,CAAA,4BAFD,EAGC,WAAA,CAAA,8BAHD;;AAMA,YAAM,QAAQ,GAAG,WAAW,CAAC,IAAZ,GAAmB,CAAC,WAAW,CAAC,IAAhC,GAAuC,KAAK,KAA7D;;AAGA,aAAK,SAAL,CAAe,UAAf,CAA0B;AACzB,UAAA,MAAM,EAAE,OAAA,CAAA,eAAA,CAAgB,MAAM,CAAC,aAAvB,EAAsC,QAAtC,CADiB;AAEzB,UAAA,SAAS,EAAE,MAAM,CAAC,aAFO;AAGzB,UAAA,IAAI,EAAE;AAHmB,SAA1B;;AAMA,eAAO,SAAP;AACA;;AAED,UACC,OAAO,WAAW,CAAC,cAAnB,KAAsC,QAAtC,IACA,OAAO,WAAW,CAAC,iBAAnB,KAAyC,QAF1C,EAGE;AACD,aAAK,qCAAL,CACC,MADD,EAEC,WAAA,CAAA,6BAFD,EAGC,WAAA,CAAA,+BAHD;;AAMA,eAAO,SAAP;AACA;;AAED,aAAO,WAAP;AACA;;;WAEO,gDACP,WADO,EAEP,MAFO,EAEe;;;AAEtB,UAAM,UAAU,GAAW,QAAQ,CAAC,WAAW,CAAC,IAAb,EAA6B,aAA7B,CAAnC;AACA,UAAM,MAAM,GAAG,OAAA,CAAA,eAAA,CAAgB,MAAM,CAAC,aAAvB,EAAsC,UAAtC,CAAf;AAGA,UAAQ,gBAAR,GAAuE,WAAvE,CAAQ,gBAAR;AAAA,UAA0B,KAA1B,GAAuE,WAAvE,CAA0B,KAA1B;AAAA,UAAiC,iBAAjC,GAAuE,WAAvE,CAAiC,iBAAjC;AAAA,UAAoD,cAApD,GAAuE,WAAvE,CAAoD,cAApD;;AAEA,UAAM,cAAc,GAAG,KAAK,SAAL,CAAe,OAAf,CAAuB;AAC7C,QAAA,MAAM,EAAN,MAD6C;AAE7C,QAAA,SAAS,EAAE,MAAM,CAAC,aAF2B;AAG7C,QAAA,IAAI,EAAE;AAHuC,OAAvB,CAAvB;;AAMA,UAAM,gBAAgB,GAAgB,cAAc,mCAE9C,cAF8C;AAGjD,QAAA,WAAW,kCACP,cAAc,CAAC,WADR;AAEV,UAAA,KAAK,EAAE,KAFG;AAGV,UAAA,cAAc,EAAE,cAHN;AAIV,UAAA,iBAAiB,EAAE,iBAJT;AAKV,UAAA,OAAO,oBAAO,CAAA,EAAA,GAAA,cAAc,CAAC,WAAf,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,KAAA,CAA1B,GAA0B,EAAA,CAAE,OAAnC;AALG,UAHsC;AAUjD,QAAA,aAAa,kCACR,cAAc,CAAC,aAAf,GACD,cAAc,CAAC,aADd,GAED,OAAA,CAAA,kBAAA,CAAmB,cAAnB,EAAmC,KAAK,OAAxC,CAHS;AAIZ,UAAA,gBAAgB,EAAE,gBAAgB,KAAK,OAJ3B;AAKZ,UAAA,cAAc,EAAE,WAAA,CAAA,cAAA,CAAe;AALnB;AAVoC,WAkBjD;AACA,QAAA,WAAW,EAAE;AACZ,UAAA,iBAAiB,EAAE,iBADP;AAEZ,UAAA,KAAK,EAAE,KAFK;AAGZ,UAAA,cAAc,EAAE,cAHJ;AAIZ,UAAA,OAAO,EAAE;AAJG,SADb;AAOA,QAAA,aAAa,kCACT,OAAA,CAAA,kBAAA,CACF;AACC,UAAA,MAAM,EAAN,MADD;AAEC,UAAA,SAAS,EAAE,MAAM,CAAC,aAFnB;AAGC,UAAA,IAAI,EAAE;AAHP,SADE,EAMF,KAAK,OANH,CADS;AASZ,UAAA,gBAAgB,EAAE,gBAAgB,KAAK,OAT3B;AAUZ,UAAA,cAAc,EAAE,WAAA,CAAA,cAAA,CAAe;AAVnB,UAPb;AAmBA,QAAA,MAAM,EAAN,MAnBA;AAoBA,QAAA,SAAS,EAAE,MAAM,CAAC,aApBlB;AAqBA,QAAA,IAAI,EAAE;AArBN,OAlBH;;AA0CA,UAAI;AACH,YAAM,aAAa,GAAG,OAAA,CAAA,gBAAA,CACrB,gBADqB,EAErB,KAAK,gBAAL,GAAwB,KAAK,gBAA7B,GAAgD,WAAA,CAAA,0BAF3B,CAAtB;AAKA,eAAO,aAAP;AACA,OAPD,CAOE,OAAO,KAAP,EAAc;AACf,aAAK,qCAAL,CAA2C,MAA3C,EAAmD,WAAA,CAAA,2BAAnD,EAAgF,KAAhF;;AAEA,eAAO,SAAP;AACA;AACD;;;WAEO,iCAAwB,QAAxB,EAA+C,MAA/C,EAAqE;AAC5E,kCAA2B,KAAK,mBAAL,CAAyB,QAAzB,EAAmC,KAAK,SAAxC,CAA3B;AAAA,UAAQ,OAAR,yBAAQ,OAAR;AAAA,UAAiB,KAAjB,yBAAiB,KAAjB;;AAEA,UAAI,CAAC,OAAL,EAAc;AACb,YAAM,WAAW,GAAG,KAAK,KAAA,IAAL,IAAA,KAAK,KAAA,KAAA,CAAL,GAAA,KAAA,GAAS,WAAA,CAAA,gCAA7B;;AAEA,aAAK,qCAAL,CAA2C,MAA3C,EAAmD,WAAA,CAAA,sBAAnD,EAA2E,WAA3E;AACA;;AAED,aAAO,OAAP;AACA;;;WAEO,mCAA0B,MAA1B,EAAgD;AAEvD,UAAM,WAAW,GAAG,KAAK,oBAAL,CAA0B,MAA1B,CAApB;;AACA,UAAI,CAAC,WAAL,EAAkB;AACjB;AACA;;AAED,UAAM,gBAAgB,GAAG,KAAK,sCAAL,CAA4C,WAA5C,EAAyD,MAAzD,CAAzB;;AAEA,UAAI,CAAC,gBAAL,EAAuB;AACtB;AACA;;AAED,UAAI,CAAC,KAAK,uBAAL,CAA6B,gBAA7B,EAA+C,MAA/C,CAAL,EAA6D;AAC5D;AACA;;AAED,UAAM,sBAAsB,GAA2B;AACtD,QAAA,QAAQ,EAAE,gBAD4C;AAEtD,QAAA,MAAM,EAAN;AAFsD,OAAvD;AAKA,WAAK,IAAL,CAAU,QAAA,CAAA,iCAAV,EAA6C,sBAA7C;AACA;;;WAEO,wCAA+B,MAA/B,EAAqD;AAAA;;AAG3D,MAAA,MAAc,CAAC,MAAf,CAAsB,EAAtB,CAAyB,MAAzB,EAAiC,YAAK;AACtC,QAAA,MAAI,CAAC,wBAAL,CACC,MADD,wCAEgC,MAAM,CAAC,aAFvC,8CAGC,IAHD;AAKA,OANA;AASA,MAAA,MAAc,CAAC,MAAf,CAAsB,EAAtB,CAAyB,MAAzB,EAAiC,YAAK;AACtC,QAAA,MAAI,CAAC,wBAAL,CACC,MADD,wCAEgC,MAAM,CAAC,aAFvC,8CAGC,IAHD;AAKA,OANA;AAOD;;;WAGO,gCAAuB,EAAvB,EAAgC,IAAhC,EAAyC;AAAA;;AAEhD,MAAA,EAAE,CAAC,EAAH,CAAM,SAAN,EAAiB,UAAC,OAAD,EAAiB;;;AAEjC,YAAI,OAAO,KAAK,IAAhB,EAAsB;AACrB;AACA;;AAED,YAAM,qBAAqB,GAAG,GAA9B;AAGA,oCAII,EAAE,CAAC,OAAH,CAAW,SAJf;AAAA,YACU,aADV,yBACC,OADD;AAAA,YAEC,IAFD,yBAEC,IAFD;AAMA,YAAM,MAAM,GAAG,OAAA,CAAA,eAAA,CAAgB,aAAhB,EAA+B,IAA/B,CAAf;;AAEA,YAAI;AAEH,cAAM,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,OAAX,CAAf;AACA,UAAA,OAAA,CAAA,cAAA,CAAe,MAAf;AAEA,cAAM,aAAa,GAAgB,IAAI,GAAJ,CAAQ,CAC1C,eAD0C,EAE1C,kBAF0C,EAG1C,YAH0C,EAI1C,cAJ0C,EAK1C,UAL0C,CAAR,CAAnC;;AAQA,cAEE,MAAM,CAAC,KAAP,IAAgB,OAAO,MAAM,CAAC,KAAd,KAAwB,QAAzC,IAEA,aAAa,CAAC,GAAd,CAAkB,MAAM,CAAC,KAAzB,CAFA,IAIA,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,KAAP,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAY,EAAA,CAAE,MAAd,IAAuB,qBANxB,EAOE;AACD,kBAAM,IAAI,QAAA,CAAA,mBAAJ,CAAwB,0BAAxB,EAAoD,MAApD,CAAN;AACA;;AAGD,cAAI,MAAM,CAAC,KAAP,KAAiB,aAArB,EAAoC;AACnC,gBAAM,KAAK,GAAG,CAAC,CAAA,EAAA,GAAA,MAAI,CAAC,sBAAL,CAA4B,GAA5B,CAAgC,aAAhC,CAAA,MAA8C,IAA9C,IAA8C,EAAA,KAAA,KAAA,CAA9C,GAA8C,EAA9C,GAAkD,CAAnD,IAAwD,CAAtE;;AACA,YAAA,MAAI,CAAC,sBAAL,CAA4B,GAA5B,CAAgC,aAAhC,EAA+C,KAA/C;;AAEA,gBAAI,KAAK,GAAG,WAAA,CAAA,6BAAZ,EAA2C;AAC1C,oBAAM,IAAI,QAAA,CAAA,2BAAJ,2DAC8C,KAD9C,uCACgF,WAAA,CAAA,6BADhF,EAAN;AAGA;AACD;AACD,SAnCD,CAmCE,OAAO,KAAP,EAAc;AAEf,UAAA,EAAE,CAAC,SAAH;;AAEA,UAAA,MAAI,CAAC,IAAL,CAAU,QAAA,CAAA,cAAV,EAA0B,MAA1B;;AACA,UAAA,MAAI,CAAC,IAAL,CACC,QAAA,CAAA,0BADD,iCAGyB,aAHzB,uBAGmD,KAHnD,wBAGsE,OAHtE;AAKA;AACD,OA/DD;AAgEA;;;;sFAEO;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,kDACA,IAAI,OAAJ,CAAkB,UAAA,OAAO,EAAG;AAClC,kBAAA,MAAI,CAAC,WAAL,CAAiB,KAAjB,CAAuB,YAAK;AAC3B,oBAAA,OAAO;AACP,mBAFD;AAGA,iBAJM,CADA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;oFAQA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,kDACA,IAAI,OAAJ,CAAkB,UAAA,OAAO,EAAG;AAClC,kBAAA,MAAI,CAAC,SAAL,CAAe,KAAf,CAAqB,YAAK;AACzB,oBAAA,OAAO;AACP,mBAFD;AAGA,iBAJM,CADA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;EArZuB,QAAA,CAAA,Y;;AAAhC,OAAA,CAAA,UAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PeerServer = void 0;\nconst events_1 = require(\"events\");\nconst http = require(\"http\");\nconst socketcluster_server_1 = require(\"socketcluster-server\");\nconst url = require(\"url\");\nconst constants_1 = require(\"../constants\");\nconst errors_1 = require(\"../errors\");\nconst events_2 = require(\"../events\");\nconst utils_1 = require(\"../utils\");\nconst BASE_10_RADIX = 10;\nclass PeerServer extends events_1.EventEmitter {\n    constructor(config) {\n        super();\n        this._nodeInfo = config.nodeInfo;\n        this._hostIp = config.hostIp;\n        this._port = config.port;\n        this._secret = config.secret;\n        this._peerBook = config.peerBook;\n        this._httpServer = http.createServer();\n        this._scServer = socketcluster_server_1.attach(this._httpServer, {\n            path: constants_1.DEFAULT_HTTP_PATH,\n            wsEngineServerOptions: {\n                maxPayload: config.maxPayload,\n            },\n        });\n        this._maxPeerInfoSize = config.maxPeerInfoSize;\n        this._peerHandshakeCheck = config.peerHandshakeCheck;\n        this._invalidMessageCounter = new Map();\n    }\n    async stop() {\n        if (this._invalidMessageInterval) {\n            clearTimeout(this._invalidMessageInterval);\n        }\n        await this._stopWSServer();\n        await this._stopHTTPServer();\n    }\n    async start() {\n        this._invalidMessageInterval = setInterval(() => {\n            this._invalidMessageCounter = new Map();\n        }, constants_1.DEFAULT_RATE_CALCULATION_INTERVAL);\n        this._scServer.addMiddleware(this._scServer.MIDDLEWARE_HANDSHAKE_WS, (req, next) => {\n            if (this._peerBook.bannedIPs.has(req.socket.remoteAddress)) {\n                next(new errors_1.PeerInboundHandshakeError(constants_1.FORBIDDEN_CONNECTION_REASON, constants_1.FORBIDDEN_CONNECTION, req.socket.remoteAddress));\n                return;\n            }\n            next();\n        });\n        this._scServer.on('handshake', (socket) => {\n            if (this._peerBook.bannedIPs.has(socket.remoteAddress)) {\n                if (socket.socket) {\n                    socket.socket.terminate();\n                }\n            }\n            this._bindInvalidControlFrameEvents(socket);\n        });\n        this._scServer.wsServer.on('connection', (ws, req) => {\n            this._handleIncomingPayload(ws, req);\n        });\n        this._scServer.on('connection', (socket) => {\n            this._handleIncomingConnection(socket);\n        });\n        this._httpServer.listen(this._port, this._hostIp || constants_1.DEFAULT_NODE_HOST_IP);\n        if (this._scServer.isReady) {\n            return;\n        }\n        return new Promise(resolve => {\n            this._scServer.once('ready', () => {\n                resolve();\n            });\n        });\n    }\n    _terminateIncomingSocket(socket, error, addToBannedPeers) {\n        if (socket.socket) {\n            socket.socket.terminate();\n        }\n        this.emit(events_2.EVENT_INBOUND_SOCKET_ERROR, error);\n        if (addToBannedPeers) {\n            const peerId = `${socket.remoteAddress}:${socket.remotePort}`;\n            this.emit(events_2.EVENT_BAN_PEER, peerId);\n        }\n    }\n    _disconnectSocketDueToFailedHandshake(socket, statusCode, closeReason) {\n        socket.disconnect(statusCode, closeReason);\n        this.emit(events_2.EVENT_FAILED_TO_ADD_INBOUND_PEER, new errors_1.PeerInboundHandshakeError(closeReason, statusCode, socket.remoteAddress, socket.request.url));\n    }\n    _validateQueryObject(socket) {\n        if (!socket.request.url) {\n            this._disconnectSocketDueToFailedHandshake(socket, constants_1.INVALID_CONNECTION_URL_CODE, constants_1.INVALID_CONNECTION_URL_REASON);\n            return undefined;\n        }\n        const { query: queryObject } = url.parse(socket.request.url, true);\n        if (!queryObject) {\n            return undefined;\n        }\n        if (queryObject.nonce === this._nodeInfo.nonce) {\n            this._disconnectSocketDueToFailedHandshake(socket, constants_1.INVALID_CONNECTION_SELF_CODE, constants_1.INVALID_CONNECTION_SELF_REASON);\n            const selfport = queryObject.port ? +queryObject.port : this._port;\n            this._peerBook.removePeer({\n                peerId: utils_1.constructPeerId(socket.remoteAddress, selfport),\n                ipAddress: socket.remoteAddress,\n                port: selfport,\n            });\n            return undefined;\n        }\n        if (typeof queryObject.networkVersion !== 'string' ||\n            typeof queryObject.networkIdentifier !== 'string') {\n            this._disconnectSocketDueToFailedHandshake(socket, constants_1.INVALID_CONNECTION_QUERY_CODE, constants_1.INVALID_CONNECTION_QUERY_REASON);\n            return undefined;\n        }\n        return queryObject;\n    }\n    _constructPeerInfoForInboundConnection(queryObject, socket) {\n        var _a;\n        const remoteport = parseInt(queryObject.port, BASE_10_RADIX);\n        const peerId = utils_1.constructPeerId(socket.remoteAddress, remoteport);\n        const { advertiseAddress, nonce, networkIdentifier, networkVersion } = queryObject;\n        const peerInPeerBook = this._peerBook.getPeer({\n            peerId,\n            ipAddress: socket.remoteAddress,\n            port: remoteport,\n        });\n        const incomingPeerInfo = peerInPeerBook\n            ? {\n                ...peerInPeerBook,\n                sharedState: {\n                    ...peerInPeerBook.sharedState,\n                    nonce: nonce,\n                    networkVersion: networkVersion,\n                    networkIdentifier: networkIdentifier,\n                    options: { ...(_a = peerInPeerBook.sharedState) === null || _a === void 0 ? void 0 : _a.options },\n                },\n                internalState: {\n                    ...(peerInPeerBook.internalState\n                        ? peerInPeerBook.internalState\n                        : utils_1.assignInternalInfo(peerInPeerBook, this._secret)),\n                    advertiseAddress: advertiseAddress !== 'false',\n                    connectionKind: constants_1.ConnectionKind.INBOUND,\n                },\n            }\n            : {\n                sharedState: {\n                    networkIdentifier: networkIdentifier,\n                    nonce: nonce,\n                    networkVersion: networkVersion,\n                    options: {},\n                },\n                internalState: {\n                    ...utils_1.assignInternalInfo({\n                        peerId,\n                        ipAddress: socket.remoteAddress,\n                        port: remoteport,\n                    }, this._secret),\n                    advertiseAddress: advertiseAddress !== 'false',\n                    connectionKind: constants_1.ConnectionKind.INBOUND,\n                },\n                peerId,\n                ipAddress: socket.remoteAddress,\n                port: remoteport,\n            };\n        try {\n            const validPeerInfo = utils_1.validatePeerInfo(incomingPeerInfo, this._maxPeerInfoSize ? this._maxPeerInfoSize : constants_1.DEFAULT_MAX_PEER_INFO_SIZE);\n            return validPeerInfo;\n        }\n        catch (error) {\n            this._disconnectSocketDueToFailedHandshake(socket, constants_1.INCOMPATIBLE_PEER_INFO_CODE, error);\n            return undefined;\n        }\n    }\n    _checkPeerCompatibility(peerInfo, socket) {\n        const { success, error } = this._peerHandshakeCheck(peerInfo, this._nodeInfo);\n        if (!success) {\n            const errorReason = error !== null && error !== void 0 ? error : constants_1.INCOMPATIBLE_PEER_UNKNOWN_REASON;\n            this._disconnectSocketDueToFailedHandshake(socket, constants_1.INCOMPATIBLE_PEER_CODE, errorReason);\n        }\n        return success;\n    }\n    _handleIncomingConnection(socket) {\n        const queryObject = this._validateQueryObject(socket);\n        if (!queryObject) {\n            return;\n        }\n        const incomingPeerInfo = this._constructPeerInfoForInboundConnection(queryObject, socket);\n        if (!incomingPeerInfo) {\n            return;\n        }\n        if (!this._checkPeerCompatibility(incomingPeerInfo, socket)) {\n            return;\n        }\n        const incomingPeerConnection = {\n            peerInfo: incomingPeerInfo,\n            socket,\n        };\n        this.emit(events_2.EVENT_NEW_INBOUND_PEER_CONNECTION, incomingPeerConnection);\n    }\n    _bindInvalidControlFrameEvents(socket) {\n        socket.socket.on('ping', () => {\n            this._terminateIncomingSocket(socket, `Terminated connection peer: ${socket.remoteAddress}, reason: malicious ping control frames`, true);\n        });\n        socket.socket.on('pong', () => {\n            this._terminateIncomingSocket(socket, `Terminated connection peer: ${socket.remoteAddress}, reason: malicious pong control frames`, true);\n        });\n    }\n    _handleIncomingPayload(ws, _req) {\n        ws.on('message', (message) => {\n            var _a, _b;\n            if (message === '#2') {\n                return;\n            }\n            const MAX_EVENT_NAME_LENGTH = 128;\n            const { address: peerIpAddress, port, } = ws._socket._peername;\n            const peerId = utils_1.constructPeerId(peerIpAddress, port);\n            try {\n                const parsed = JSON.parse(message);\n                utils_1.validatePacket(parsed);\n                const invalidEvents = new Set([\n                    '#authenticate',\n                    '#removeAuthToken',\n                    '#subscribe',\n                    '#unsubscribe',\n                    '#publish',\n                ]);\n                if ((parsed.event && typeof parsed.event !== 'string') ||\n                    invalidEvents.has(parsed.event) ||\n                    ((_a = parsed.event) === null || _a === void 0 ? void 0 : _a.length) > MAX_EVENT_NAME_LENGTH) {\n                    throw new errors_1.InvalidPayloadError('Received invalid payload', parsed);\n                }\n                if (parsed.event === '#disconnect') {\n                    const count = ((_b = this._invalidMessageCounter.get(peerIpAddress)) !== null && _b !== void 0 ? _b : 0) + 1;\n                    this._invalidMessageCounter.set(peerIpAddress, count);\n                    if (count > constants_1.DEFAULT_CONTROL_MESSAGE_LIMIT) {\n                        throw new errors_1.InvalidDisconnectEventError(`Exhausted disconnected event: peer disconnected ${count} times above the limit of ${constants_1.DEFAULT_CONTROL_MESSAGE_LIMIT}`);\n                    }\n                }\n            }\n            catch (error) {\n                ws.terminate();\n                this.emit(events_2.EVENT_BAN_PEER, peerId);\n                this.emit(events_2.EVENT_INBOUND_SOCKET_ERROR, `Banned peer with Ip: ${peerIpAddress}, reason: ${error}, message: ${message}`);\n            }\n        });\n    }\n    async _stopHTTPServer() {\n        return new Promise(resolve => {\n            this._httpServer.close(() => {\n                resolve();\n            });\n        });\n    }\n    async _stopWSServer() {\n        return new Promise(resolve => {\n            this._scServer.close(() => {\n                resolve();\n            });\n        });\n    }\n}\nexports.PeerServer = PeerServer;\n//# sourceMappingURL=peer_server.js.map"]},"metadata":{},"sourceType":"script"}