{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.verifyMultiSignatureTransaction = exports.validateKeysSignatures = exports.validateSignature = exports.isMultisignatureAccount = void 0;\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar isMultisignatureAccount = function isMultisignatureAccount(account) {\n  return !!((account.keys.mandatoryKeys.length > 0 || account.keys.optionalKeys.length > 0) && account.keys.numberOfSignatures);\n};\n\nexports.isMultisignatureAccount = isMultisignatureAccount;\n\nvar validateSignature = function validateSignature(publicKey, signature, transactionBytes, id) {\n  var valid = lisk_cryptography_1.verifyData(transactionBytes, signature, publicKey);\n\n  if (!valid) {\n    throw new Error(\"Failed to validate signature '\".concat(signature.toString('hex'), \"' for transaction with id '\").concat(id.toString('hex'), \"'\"));\n  }\n};\n\nexports.validateSignature = validateSignature;\n\nvar validateKeysSignatures = function validateKeysSignatures(keys, signatures, transactionBytes, id) {\n  for (var i = 0; i < keys.length; i += 1) {\n    if (signatures[i].length === 0) {\n      throw new Error('Invalid signature. Empty buffer is not a valid signature.');\n    }\n\n    exports.validateSignature(keys[i], signatures[i], transactionBytes, id);\n  }\n};\n\nexports.validateKeysSignatures = validateKeysSignatures;\n\nvar verifyMultiSignatureTransaction = function verifyMultiSignatureTransaction(id, sender, signatures, transactionBytes) {\n  var _sender$keys = sender.keys,\n      mandatoryKeys = _sender$keys.mandatoryKeys,\n      optionalKeys = _sender$keys.optionalKeys,\n      numberOfSignatures = _sender$keys.numberOfSignatures;\n  var numMandatoryKeys = mandatoryKeys.length;\n  var numOptionalKeys = optionalKeys.length;\n  var nonEmptySignaturesCount = signatures.filter(function (k) {\n    return k.length !== 0;\n  }).length;\n\n  if (nonEmptySignaturesCount !== numberOfSignatures || signatures.length !== numMandatoryKeys + numOptionalKeys) {\n    throw new Error(\"Transaction signatures does not match required number of signatures: '\".concat(numberOfSignatures.toString(), \"' for transaction with id '\").concat(id.toString('hex'), \"'\"));\n  }\n\n  exports.validateKeysSignatures(mandatoryKeys, signatures, transactionBytes, id);\n\n  for (var k = 0; k < numOptionalKeys; k += 1) {\n    var signature = signatures[numMandatoryKeys + k];\n\n    if (signature.length !== 0) {\n      exports.validateSignature(optionalKeys[k], signature, transactionBytes, id);\n    }\n  }\n};\n\nexports.verifyMultiSignatureTransaction = verifyMultiSignatureTransaction;","map":{"version":3,"sources":["../../../../src/modules/keys/utils/verify.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.verifyMultiSignatureTransaction = exports.validateKeysSignatures = exports.validateSignature = exports.isMultisignatureAccount = void 0;\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst isMultisignatureAccount = (account) => !!((account.keys.mandatoryKeys.length > 0 || account.keys.optionalKeys.length > 0) &&\n    account.keys.numberOfSignatures);\nexports.isMultisignatureAccount = isMultisignatureAccount;\nconst validateSignature = (publicKey, signature, transactionBytes, id) => {\n    const valid = lisk_cryptography_1.verifyData(transactionBytes, signature, publicKey);\n    if (!valid) {\n        throw new Error(`Failed to validate signature '${signature.toString('hex')}' for transaction with id '${id.toString('hex')}'`);\n    }\n};\nexports.validateSignature = validateSignature;\nconst validateKeysSignatures = (keys, signatures, transactionBytes, id) => {\n    for (let i = 0; i < keys.length; i += 1) {\n        if (signatures[i].length === 0) {\n            throw new Error('Invalid signature. Empty buffer is not a valid signature.');\n        }\n        exports.validateSignature(keys[i], signatures[i], transactionBytes, id);\n    }\n};\nexports.validateKeysSignatures = validateKeysSignatures;\nconst verifyMultiSignatureTransaction = (id, sender, signatures, transactionBytes) => {\n    const { mandatoryKeys, optionalKeys, numberOfSignatures } = sender.keys;\n    const numMandatoryKeys = mandatoryKeys.length;\n    const numOptionalKeys = optionalKeys.length;\n    const nonEmptySignaturesCount = signatures.filter(k => k.length !== 0).length;\n    if (nonEmptySignaturesCount !== numberOfSignatures ||\n        signatures.length !== numMandatoryKeys + numOptionalKeys) {\n        throw new Error(`Transaction signatures does not match required number of signatures: '${numberOfSignatures.toString()}' for transaction with id '${id.toString('hex')}'`);\n    }\n    exports.validateKeysSignatures(mandatoryKeys, signatures, transactionBytes, id);\n    for (let k = 0; k < numOptionalKeys; k += 1) {\n        const signature = signatures[numMandatoryKeys + k];\n        if (signature.length !== 0) {\n            exports.validateSignature(optionalKeys[k], signature, transactionBytes, id);\n        }\n    }\n};\nexports.verifyMultiSignatureTransaction = verifyMultiSignatureTransaction;\n//# sourceMappingURL=verify.js.map"]},"metadata":{},"sourceType":"script"}