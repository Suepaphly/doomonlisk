{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DataAccessMock = void 0;\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar DataAccessMock = /*#__PURE__*/function () {\n  function DataAccessMock(opts) {\n    _classCallCheck(this, DataAccessMock);\n\n    var _a, _b, _c;\n\n    this._blockHeaders = (_a = opts === null || opts === void 0 ? void 0 : opts.blockHeaders) !== null && _a !== void 0 ? _a : [];\n    this._chainState = (_b = opts === null || opts === void 0 ? void 0 : opts.chainState) !== null && _b !== void 0 ? _b : {};\n    this._accounts = new lisk_utils_1.dataStructures.BufferMap();\n\n    var _iterator = _createForOfIteratorHelper((_c = opts === null || opts === void 0 ? void 0 : opts.accounts) !== null && _c !== void 0 ? _c : []),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var account = _step.value;\n\n        this._accounts.set(account.address, account);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  _createClass(DataAccessMock, [{\n    key: \"getChainState\",\n    value: function () {\n      var _getChainState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", Promise.resolve(this._chainState[key]));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getChainState(_x) {\n        return _getChainState.apply(this, arguments);\n      }\n\n      return getChainState;\n    }()\n  }, {\n    key: \"getAccountByAddress\",\n    value: function () {\n      var _getAccountByAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this._accounts.has(address)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Account with address \".concat(address.toString('hex'), \" does not exists\"));\n\n              case 2:\n                return _context2.abrupt(\"return\", Promise.resolve(this._accounts.get(address)));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getAccountByAddress(_x2) {\n        return _getAccountByAddress.apply(this, arguments);\n      }\n\n      return getAccountByAddress;\n    }()\n  }, {\n    key: \"getLastBlockHeader\",\n    value: function () {\n      var _getLastBlockHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", Promise.resolve(this._blockHeaders[this._blockHeaders.length - 1]));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getLastBlockHeader() {\n        return _getLastBlockHeader.apply(this, arguments);\n      }\n\n      return getLastBlockHeader;\n    }()\n  }]);\n\n  return DataAccessMock;\n}();\n\nexports.DataAccessMock = DataAccessMock;","map":{"version":3,"sources":["../../../src/testing/mocks/data_access_mock.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAeA,IAAA,YAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;IAGa,c;AAKZ,0BAAmB,IAAnB,EAIC;AAAA;;;;AACA,SAAK,aAAL,GAAqB,CAAA,EAAA,GAAA,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,YAAN,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,EAAlB,GAAsB,EAA3C;AACA,SAAK,WAAL,GAAmB,CAAA,EAAA,GAAA,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,UAAN,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,EAAhB,GAAoB,EAAvC;AACA,SAAK,SAAL,GAAiB,IAAI,YAAA,CAAA,cAAA,CAAe,SAAnB,EAAjB;;AAHA,+CAKsB,CAAA,EAAA,GAAA,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,QAAN,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,EAAd,GAAkB,EALxC;AAAA;;AAAA;AAKA,0DAA4C;AAAA,YAAjC,OAAiC;;AAC3C,aAAK,SAAL,CAAe,GAAf,CAAmB,OAAO,CAAC,OAA3B,EAAoC,OAApC;AACA;AAPD;AAAA;AAAA;AAAA;AAAA;AAQA;;;;;oFAEM,iBAAoB,GAApB;AAAA;AAAA;AAAA;AAAA;AAAA,iDACC,OAAO,CAAC,OAAR,CAAgB,KAAK,WAAL,CAAiB,GAAjB,CAAhB,CADD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;0FAIA,kBAAmC,OAAnC;AAAA;AAAA;AAAA;AAAA;AAAA,oBACD,KAAK,SAAL,CAAe,GAAf,CAAmB,OAAnB,CADC;AAAA;AAAA;AAAA;;AAAA,sBAEC,IAAI,KAAJ,gCAAkC,OAAO,CAAC,QAAR,CAAiB,KAAjB,CAAlC,sBAFD;;AAAA;AAAA,kDAKC,OAAO,CAAC,OAAR,CAAiB,KAAK,SAAL,CAAe,GAAf,CAAmB,OAAnB,CAAjB,CALD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;yFAQA;AAAA;AAAA;AAAA;AAAA;AAAA,kDACC,OAAO,CAAC,OAAR,CAAgB,KAAK,aAAL,CAAmB,KAAK,aAAL,CAAmB,MAAnB,GAA4B,CAA/C,CAAhB,CADD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;;;AA/BR,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataAccessMock = void 0;\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nclass DataAccessMock {\n    constructor(opts) {\n        var _a, _b, _c;\n        this._blockHeaders = (_a = opts === null || opts === void 0 ? void 0 : opts.blockHeaders) !== null && _a !== void 0 ? _a : [];\n        this._chainState = (_b = opts === null || opts === void 0 ? void 0 : opts.chainState) !== null && _b !== void 0 ? _b : {};\n        this._accounts = new lisk_utils_1.dataStructures.BufferMap();\n        for (const account of (_c = opts === null || opts === void 0 ? void 0 : opts.accounts) !== null && _c !== void 0 ? _c : []) {\n            this._accounts.set(account.address, account);\n        }\n    }\n    async getChainState(key) {\n        return Promise.resolve(this._chainState[key]);\n    }\n    async getAccountByAddress(address) {\n        if (!this._accounts.has(address)) {\n            throw new Error(`Account with address ${address.toString('hex')} does not exists`);\n        }\n        return Promise.resolve(this._accounts.get(address));\n    }\n    async getLastBlockHeader() {\n        return Promise.resolve(this._blockHeaders[this._blockHeaders.length - 1]);\n    }\n}\nexports.DataAccessMock = DataAccessMock;\n//# sourceMappingURL=data_access_mock.js.map"]},"metadata":{},"sourceType":"script"}