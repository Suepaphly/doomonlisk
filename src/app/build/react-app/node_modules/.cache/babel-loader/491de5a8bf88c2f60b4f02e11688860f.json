{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _objectWithoutProperties = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _slicedToArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _excluded = [\"generatorAddress\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.saveMaxHeightPreviouslyForged = exports.setPreviouslyForgedMap = exports.getPreviouslyForgedMap = exports.setUsedHashOnions = exports.getUsedHashOnions = exports.setRegisteredHashOnionSeeds = exports.getRegisteredHashOnionSeeds = exports.previouslyForgedInfoSchema = exports.usedHashOnionsStoreSchema = exports.registeredHashOnionsStoreSchema = void 0;\n\nvar lisk_codec_1 = require(\"@liskhq/lisk-codec\");\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar lisk_db_1 = require(\"@liskhq/lisk-db\");\n\nvar lisk_utils_1 = require(\"@liskhq/lisk-utils\");\n\nvar constant_1 = require(\"./constant\");\n\nexports.registeredHashOnionsStoreSchema = {\n  title: 'Used hash onion',\n  $id: '/node/forger/registered_hash_onion',\n  type: 'object',\n  required: ['registeredHashOnions'],\n  properties: {\n    registeredHashOnions: {\n      type: 'array',\n      fieldNumber: 1,\n      items: {\n        type: 'object',\n        required: ['address', 'seedHash'],\n        properties: {\n          address: {\n            dataType: 'bytes',\n            fieldNumber: 1\n          },\n          seedHash: {\n            dataType: 'bytes',\n            fieldNumber: 2\n          }\n        }\n      }\n    }\n  }\n};\nexports.usedHashOnionsStoreSchema = {\n  title: 'Used hash onion',\n  $id: '/node/forger/used_hash_onion',\n  type: 'object',\n  required: ['usedHashOnions'],\n  properties: {\n    usedHashOnions: {\n      type: 'array',\n      fieldNumber: 1,\n      items: {\n        type: 'object',\n        required: ['address', 'count', 'height'],\n        properties: {\n          address: {\n            dataType: 'bytes',\n            fieldNumber: 1\n          },\n          count: {\n            dataType: 'uint32',\n            fieldNumber: 2\n          },\n          height: {\n            dataType: 'uint32',\n            fieldNumber: 3\n          }\n        }\n      }\n    }\n  }\n};\nexports.previouslyForgedInfoSchema = {\n  title: 'Previously Forged Info',\n  $id: '/node/forger/previously_forged_info',\n  type: 'object',\n  required: ['previouslyForgedInfo'],\n  properties: {\n    previouslyForgedInfo: {\n      type: 'array',\n      fieldNumber: 1,\n      items: {\n        type: 'object',\n        required: ['generatorAddress', 'height', 'maxHeightPrevoted', 'maxHeightPreviouslyForged'],\n        properties: {\n          generatorAddress: {\n            dataType: 'bytes',\n            fieldNumber: 1\n          },\n          height: {\n            dataType: 'uint32',\n            fieldNumber: 2\n          },\n          maxHeightPrevoted: {\n            dataType: 'uint32',\n            fieldNumber: 3\n          },\n          maxHeightPreviouslyForged: {\n            dataType: 'uint32',\n            fieldNumber: 4\n          }\n        }\n      }\n    }\n  }\n};\nlisk_codec_1.codec.addSchema(exports.registeredHashOnionsStoreSchema);\nlisk_codec_1.codec.addSchema(exports.usedHashOnionsStoreSchema);\nlisk_codec_1.codec.addSchema(exports.previouslyForgedInfoSchema);\n\nvar getRegisteredHashOnionSeeds = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(db) {\n    var registeredHashes, result, _iterator, _step, registeredHash;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.t0 = lisk_codec_1.codec;\n            _context.t1 = exports.registeredHashOnionsStoreSchema;\n            _context.next = 5;\n            return db.get(constant_1.DB_KEY_FORGER_REGISTERED_HASH_ONION_SEEDS);\n\n          case 5:\n            _context.t2 = _context.sent;\n            registeredHashes = _context.t0.decode.call(_context.t0, _context.t1, _context.t2);\n            result = new lisk_utils_1.dataStructures.BufferMap();\n            _iterator = _createForOfIteratorHelper(registeredHashes.registeredHashOnions);\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                registeredHash = _step.value;\n                result.set(registeredHash.address, registeredHash.seedHash);\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            return _context.abrupt(\"return\", result);\n\n          case 13:\n            _context.prev = 13;\n            _context.t3 = _context[\"catch\"](0);\n            return _context.abrupt(\"return\", new lisk_utils_1.dataStructures.BufferMap());\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 13]]);\n  }));\n\n  return function getRegisteredHashOnionSeeds(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.getRegisteredHashOnionSeeds = getRegisteredHashOnionSeeds;\n\nvar setRegisteredHashOnionSeeds = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(db, registeredHashOnionSeeds) {\n    var savingData, _iterator2, _step2, _step2$value, address, seedHash, registeredHashOnionSeedsBuffer;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            savingData = {\n              registeredHashOnions: []\n            };\n            _iterator2 = _createForOfIteratorHelper(registeredHashOnionSeeds.entries());\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                _step2$value = _slicedToArray(_step2.value, 2), address = _step2$value[0], seedHash = _step2$value[1];\n                savingData.registeredHashOnions.push({\n                  address: address,\n                  seedHash: seedHash\n                });\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            registeredHashOnionSeedsBuffer = lisk_codec_1.codec.encode(exports.registeredHashOnionsStoreSchema, savingData);\n            _context2.next = 6;\n            return db.put(constant_1.DB_KEY_FORGER_REGISTERED_HASH_ONION_SEEDS, registeredHashOnionSeedsBuffer);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function setRegisteredHashOnionSeeds(_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.setRegisteredHashOnionSeeds = setRegisteredHashOnionSeeds;\n\nvar getUsedHashOnions = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(db) {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.t0 = lisk_codec_1.codec;\n            _context3.t1 = exports.usedHashOnionsStoreSchema;\n            _context3.next = 5;\n            return db.get(constant_1.DB_KEY_FORGER_USED_HASH_ONION);\n\n          case 5:\n            _context3.t2 = _context3.sent;\n            return _context3.abrupt(\"return\", _context3.t0.decode.call(_context3.t0, _context3.t1, _context3.t2).usedHashOnions);\n\n          case 9:\n            _context3.prev = 9;\n            _context3.t3 = _context3[\"catch\"](0);\n            return _context3.abrupt(\"return\", []);\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 9]]);\n  }));\n\n  return function getUsedHashOnions(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.getUsedHashOnions = getUsedHashOnions;\n\nvar setUsedHashOnions = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(db, usedHashOnions) {\n    var usedHashOnionObject;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            usedHashOnionObject = {\n              usedHashOnions: usedHashOnions\n            };\n            _context4.next = 3;\n            return db.put(constant_1.DB_KEY_FORGER_USED_HASH_ONION, lisk_codec_1.codec.encode(exports.usedHashOnionsStoreSchema, usedHashOnionObject));\n\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function setUsedHashOnions(_x5, _x6) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.setUsedHashOnions = setUsedHashOnions;\n\nvar getPreviouslyForgedMap = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(db) {\n    var previouslyForgedBuffer, parsedMap, result, _iterator3, _step3, object, generatorAddress, forgedInfo;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.prev = 0;\n            _context5.next = 3;\n            return db.get(constant_1.DB_KEY_FORGER_PREVIOUSLY_FORGED);\n\n          case 3:\n            previouslyForgedBuffer = _context5.sent;\n            parsedMap = lisk_codec_1.codec.decode(exports.previouslyForgedInfoSchema, previouslyForgedBuffer);\n            result = new lisk_utils_1.dataStructures.BufferMap();\n            _iterator3 = _createForOfIteratorHelper(parsedMap.previouslyForgedInfo);\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                object = _step3.value;\n                generatorAddress = object.generatorAddress, forgedInfo = _objectWithoutProperties(object, _excluded);\n                result.set(generatorAddress, forgedInfo);\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            return _context5.abrupt(\"return\", result);\n\n          case 11:\n            _context5.prev = 11;\n            _context5.t0 = _context5[\"catch\"](0);\n\n            if (_context5.t0 instanceof lisk_db_1.NotFoundError) {\n              _context5.next = 15;\n              break;\n            }\n\n            throw _context5.t0;\n\n          case 15:\n            return _context5.abrupt(\"return\", new lisk_utils_1.dataStructures.BufferMap());\n\n          case 16:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[0, 11]]);\n  }));\n\n  return function getPreviouslyForgedMap(_x7) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexports.getPreviouslyForgedMap = getPreviouslyForgedMap;\n\nvar setPreviouslyForgedMap = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(db, previouslyForgedMap) {\n    var previouslyForgedStoreObject, _iterator4, _step4, _step4$value, key, value;\n\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            previouslyForgedStoreObject = {\n              previouslyForgedInfo: []\n            };\n            _iterator4 = _createForOfIteratorHelper(previouslyForgedMap.entries());\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                _step4$value = _slicedToArray(_step4.value, 2), key = _step4$value[0], value = _step4$value[1];\n                previouslyForgedStoreObject.previouslyForgedInfo.push(_objectSpread({\n                  generatorAddress: key\n                }, value));\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            previouslyForgedStoreObject.previouslyForgedInfo.sort(function (a, b) {\n              return a.generatorAddress.compare(b.generatorAddress);\n            });\n            _context6.next = 6;\n            return db.put(constant_1.DB_KEY_FORGER_PREVIOUSLY_FORGED, lisk_codec_1.codec.encode(exports.previouslyForgedInfoSchema, previouslyForgedStoreObject));\n\n          case 6:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function setPreviouslyForgedMap(_x8, _x9) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nexports.setPreviouslyForgedMap = setPreviouslyForgedMap;\n\nvar saveMaxHeightPreviouslyForged = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(db, header, previouslyForgedMap) {\n    var _a, generatorAddress, previouslyForged, previouslyForgedHeightByDelegate;\n\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            generatorAddress = lisk_cryptography_1.getAddressFromPublicKey(header.generatorPublicKey);\n            previouslyForged = previouslyForgedMap.get(generatorAddress);\n            previouslyForgedHeightByDelegate = (_a = previouslyForged === null || previouslyForged === void 0 ? void 0 : previouslyForged.height) !== null && _a !== void 0 ? _a : 0;\n\n            if (!(header.height <= previouslyForgedHeightByDelegate)) {\n              _context7.next = 5;\n              break;\n            }\n\n            return _context7.abrupt(\"return\");\n\n          case 5:\n            previouslyForgedMap.set(generatorAddress, {\n              height: header.height,\n              maxHeightPrevoted: header.asset.maxHeightPrevoted,\n              maxHeightPreviouslyForged: header.asset.maxHeightPreviouslyForged\n            });\n            _context7.next = 8;\n            return exports.setPreviouslyForgedMap(db, previouslyForgedMap);\n\n          case 8:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n\n  return function saveMaxHeightPreviouslyForged(_x10, _x11, _x12) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nexports.saveMaxHeightPreviouslyForged = saveMaxHeightPreviouslyForged;","map":{"version":3,"sources":["../../../src/node/forger/data_access.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.saveMaxHeightPreviouslyForged = exports.setPreviouslyForgedMap = exports.getPreviouslyForgedMap = exports.setUsedHashOnions = exports.getUsedHashOnions = exports.setRegisteredHashOnionSeeds = exports.getRegisteredHashOnionSeeds = exports.previouslyForgedInfoSchema = exports.usedHashOnionsStoreSchema = exports.registeredHashOnionsStoreSchema = void 0;\nconst lisk_codec_1 = require(\"@liskhq/lisk-codec\");\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst lisk_db_1 = require(\"@liskhq/lisk-db\");\nconst lisk_utils_1 = require(\"@liskhq/lisk-utils\");\nconst constant_1 = require(\"./constant\");\nexports.registeredHashOnionsStoreSchema = {\n    title: 'Used hash onion',\n    $id: '/node/forger/registered_hash_onion',\n    type: 'object',\n    required: ['registeredHashOnions'],\n    properties: {\n        registeredHashOnions: {\n            type: 'array',\n            fieldNumber: 1,\n            items: {\n                type: 'object',\n                required: ['address', 'seedHash'],\n                properties: {\n                    address: {\n                        dataType: 'bytes',\n                        fieldNumber: 1,\n                    },\n                    seedHash: {\n                        dataType: 'bytes',\n                        fieldNumber: 2,\n                    },\n                },\n            },\n        },\n    },\n};\nexports.usedHashOnionsStoreSchema = {\n    title: 'Used hash onion',\n    $id: '/node/forger/used_hash_onion',\n    type: 'object',\n    required: ['usedHashOnions'],\n    properties: {\n        usedHashOnions: {\n            type: 'array',\n            fieldNumber: 1,\n            items: {\n                type: 'object',\n                required: ['address', 'count', 'height'],\n                properties: {\n                    address: {\n                        dataType: 'bytes',\n                        fieldNumber: 1,\n                    },\n                    count: {\n                        dataType: 'uint32',\n                        fieldNumber: 2,\n                    },\n                    height: {\n                        dataType: 'uint32',\n                        fieldNumber: 3,\n                    },\n                },\n            },\n        },\n    },\n};\nexports.previouslyForgedInfoSchema = {\n    title: 'Previously Forged Info',\n    $id: '/node/forger/previously_forged_info',\n    type: 'object',\n    required: ['previouslyForgedInfo'],\n    properties: {\n        previouslyForgedInfo: {\n            type: 'array',\n            fieldNumber: 1,\n            items: {\n                type: 'object',\n                required: ['generatorAddress', 'height', 'maxHeightPrevoted', 'maxHeightPreviouslyForged'],\n                properties: {\n                    generatorAddress: {\n                        dataType: 'bytes',\n                        fieldNumber: 1,\n                    },\n                    height: {\n                        dataType: 'uint32',\n                        fieldNumber: 2,\n                    },\n                    maxHeightPrevoted: {\n                        dataType: 'uint32',\n                        fieldNumber: 3,\n                    },\n                    maxHeightPreviouslyForged: {\n                        dataType: 'uint32',\n                        fieldNumber: 4,\n                    },\n                },\n            },\n        },\n    },\n};\nlisk_codec_1.codec.addSchema(exports.registeredHashOnionsStoreSchema);\nlisk_codec_1.codec.addSchema(exports.usedHashOnionsStoreSchema);\nlisk_codec_1.codec.addSchema(exports.previouslyForgedInfoSchema);\nconst getRegisteredHashOnionSeeds = async (db) => {\n    try {\n        const registeredHashes = lisk_codec_1.codec.decode(exports.registeredHashOnionsStoreSchema, await db.get(constant_1.DB_KEY_FORGER_REGISTERED_HASH_ONION_SEEDS));\n        const result = new lisk_utils_1.dataStructures.BufferMap();\n        for (const registeredHash of registeredHashes.registeredHashOnions) {\n            result.set(registeredHash.address, registeredHash.seedHash);\n        }\n        return result;\n    }\n    catch (error) {\n        return new lisk_utils_1.dataStructures.BufferMap();\n    }\n};\nexports.getRegisteredHashOnionSeeds = getRegisteredHashOnionSeeds;\nconst setRegisteredHashOnionSeeds = async (db, registeredHashOnionSeeds) => {\n    const savingData = {\n        registeredHashOnions: [],\n    };\n    for (const [address, seedHash] of registeredHashOnionSeeds.entries()) {\n        savingData.registeredHashOnions.push({\n            address,\n            seedHash,\n        });\n    }\n    const registeredHashOnionSeedsBuffer = lisk_codec_1.codec.encode(exports.registeredHashOnionsStoreSchema, savingData);\n    await db.put(constant_1.DB_KEY_FORGER_REGISTERED_HASH_ONION_SEEDS, registeredHashOnionSeedsBuffer);\n};\nexports.setRegisteredHashOnionSeeds = setRegisteredHashOnionSeeds;\nconst getUsedHashOnions = async (db) => {\n    try {\n        return lisk_codec_1.codec.decode(exports.usedHashOnionsStoreSchema, await db.get(constant_1.DB_KEY_FORGER_USED_HASH_ONION)).usedHashOnions;\n    }\n    catch (error) {\n        return [];\n    }\n};\nexports.getUsedHashOnions = getUsedHashOnions;\nconst setUsedHashOnions = async (db, usedHashOnions) => {\n    const usedHashOnionObject = { usedHashOnions };\n    await db.put(constant_1.DB_KEY_FORGER_USED_HASH_ONION, lisk_codec_1.codec.encode(exports.usedHashOnionsStoreSchema, usedHashOnionObject));\n};\nexports.setUsedHashOnions = setUsedHashOnions;\nconst getPreviouslyForgedMap = async (db) => {\n    try {\n        const previouslyForgedBuffer = await db.get(constant_1.DB_KEY_FORGER_PREVIOUSLY_FORGED);\n        const parsedMap = lisk_codec_1.codec.decode(exports.previouslyForgedInfoSchema, previouslyForgedBuffer);\n        const result = new lisk_utils_1.dataStructures.BufferMap();\n        for (const object of parsedMap.previouslyForgedInfo) {\n            const { generatorAddress, ...forgedInfo } = object;\n            result.set(generatorAddress, forgedInfo);\n        }\n        return result;\n    }\n    catch (error) {\n        if (!(error instanceof lisk_db_1.NotFoundError)) {\n            throw error;\n        }\n        return new lisk_utils_1.dataStructures.BufferMap();\n    }\n};\nexports.getPreviouslyForgedMap = getPreviouslyForgedMap;\nconst setPreviouslyForgedMap = async (db, previouslyForgedMap) => {\n    const previouslyForgedStoreObject = { previouslyForgedInfo: [] };\n    for (const [key, value] of previouslyForgedMap.entries()) {\n        previouslyForgedStoreObject.previouslyForgedInfo.push({ generatorAddress: key, ...value });\n    }\n    previouslyForgedStoreObject.previouslyForgedInfo.sort((a, b) => a.generatorAddress.compare(b.generatorAddress));\n    await db.put(constant_1.DB_KEY_FORGER_PREVIOUSLY_FORGED, lisk_codec_1.codec.encode(exports.previouslyForgedInfoSchema, previouslyForgedStoreObject));\n};\nexports.setPreviouslyForgedMap = setPreviouslyForgedMap;\nconst saveMaxHeightPreviouslyForged = async (db, header, previouslyForgedMap) => {\n    var _a;\n    const generatorAddress = lisk_cryptography_1.getAddressFromPublicKey(header.generatorPublicKey);\n    const previouslyForged = previouslyForgedMap.get(generatorAddress);\n    const previouslyForgedHeightByDelegate = (_a = previouslyForged === null || previouslyForged === void 0 ? void 0 : previouslyForged.height) !== null && _a !== void 0 ? _a : 0;\n    if (header.height <= previouslyForgedHeightByDelegate) {\n        return;\n    }\n    previouslyForgedMap.set(generatorAddress, {\n        height: header.height,\n        maxHeightPrevoted: header.asset.maxHeightPrevoted,\n        maxHeightPreviouslyForged: header.asset.maxHeightPreviouslyForged,\n    });\n    await exports.setPreviouslyForgedMap(db, previouslyForgedMap);\n};\nexports.saveMaxHeightPreviouslyForged = saveMaxHeightPreviouslyForged;\n//# sourceMappingURL=data_access.js.map"]},"metadata":{},"sourceType":"script"}