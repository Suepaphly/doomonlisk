{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutProperties = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _objectSpread = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _toConsumableArray = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _excluded = [\"fee\"];\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeMinFee = void 0;\n\nvar sign_1 = require(\"./sign\");\n\nvar DEFAULT_MIN_FEE_PER_BYTE = 1000;\nvar DEFAULT_NUMBER_OF_SIGNATURES = 1;\nvar DEFAULT_BASE_FEE = '0';\nvar DEFAULT_SIGNATURE_BYTE_SIZE = 64;\n\nvar computeTransactionMinFee = function computeTransactionMinFee(assetSchema, trx, options) {\n  var _a, _b, _c, _d, _e;\n\n  var mockSignatures = new Array((_a = options === null || options === void 0 ? void 0 : options.numberOfSignatures) !== null && _a !== void 0 ? _a : DEFAULT_NUMBER_OF_SIGNATURES).fill(Buffer.alloc(DEFAULT_SIGNATURE_BYTE_SIZE));\n\n  if (options === null || options === void 0 ? void 0 : options.numberOfEmptySignatures) {\n    mockSignatures.push.apply(mockSignatures, _toConsumableArray(new Array(options.numberOfEmptySignatures).fill(Buffer.alloc(0))));\n  }\n\n  var size = sign_1.getBytes(assetSchema, _objectSpread(_objectSpread({}, trx), {}, {\n    signatures: mockSignatures\n  })).length;\n  var baseFee = (_d = (_c = (_b = options === null || options === void 0 ? void 0 : options.baseFees) === null || _b === void 0 ? void 0 : _b.find(function (bf) {\n    return bf.moduleID === trx.moduleID && bf.assetID === trx.assetID;\n  })) === null || _c === void 0 ? void 0 : _c.baseFee) !== null && _d !== void 0 ? _d : DEFAULT_BASE_FEE;\n  return BigInt(size * ((_e = options === null || options === void 0 ? void 0 : options.minFeePerByte) !== null && _e !== void 0 ? _e : DEFAULT_MIN_FEE_PER_BYTE)) + BigInt(baseFee);\n};\n\nvar computeMinFee = function computeMinFee(assetSchema, trx, options) {\n  var fee = trx.fee,\n      trxWithoutFee = _objectWithoutProperties(trx, _excluded);\n\n  trxWithoutFee.fee = BigInt(0);\n  var minFee = computeTransactionMinFee(assetSchema, trxWithoutFee, options);\n\n  while (minFee > BigInt(trxWithoutFee.fee)) {\n    trxWithoutFee.fee = minFee;\n    minFee = computeTransactionMinFee(assetSchema, trxWithoutFee, options);\n  }\n\n  return minFee;\n};\n\nexports.computeMinFee = computeMinFee;","map":{"version":3,"sources":["../src/fee.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeMinFee = void 0;\nconst sign_1 = require(\"./sign\");\nconst DEFAULT_MIN_FEE_PER_BYTE = 1000;\nconst DEFAULT_NUMBER_OF_SIGNATURES = 1;\nconst DEFAULT_BASE_FEE = '0';\nconst DEFAULT_SIGNATURE_BYTE_SIZE = 64;\nconst computeTransactionMinFee = (assetSchema, trx, options) => {\n    var _a, _b, _c, _d, _e;\n    const mockSignatures = new Array((_a = options === null || options === void 0 ? void 0 : options.numberOfSignatures) !== null && _a !== void 0 ? _a : DEFAULT_NUMBER_OF_SIGNATURES).fill(Buffer.alloc(DEFAULT_SIGNATURE_BYTE_SIZE));\n    if (options === null || options === void 0 ? void 0 : options.numberOfEmptySignatures) {\n        mockSignatures.push(...new Array(options.numberOfEmptySignatures).fill(Buffer.alloc(0)));\n    }\n    const size = sign_1.getBytes(assetSchema, {\n        ...trx,\n        signatures: mockSignatures,\n    }).length;\n    const baseFee = (_d = (_c = (_b = options === null || options === void 0 ? void 0 : options.baseFees) === null || _b === void 0 ? void 0 : _b.find(bf => bf.moduleID === trx.moduleID && bf.assetID === trx.assetID)) === null || _c === void 0 ? void 0 : _c.baseFee) !== null && _d !== void 0 ? _d : DEFAULT_BASE_FEE;\n    return BigInt(size * ((_e = options === null || options === void 0 ? void 0 : options.minFeePerByte) !== null && _e !== void 0 ? _e : DEFAULT_MIN_FEE_PER_BYTE)) + BigInt(baseFee);\n};\nconst computeMinFee = (assetSchema, trx, options) => {\n    const { fee, ...trxWithoutFee } = trx;\n    trxWithoutFee.fee = BigInt(0);\n    let minFee = computeTransactionMinFee(assetSchema, trxWithoutFee, options);\n    while (minFee > BigInt(trxWithoutFee.fee)) {\n        trxWithoutFee.fee = minFee;\n        minFee = computeTransactionMinFee(assetSchema, trxWithoutFee, options);\n    }\n    return minFee;\n};\nexports.computeMinFee = computeMinFee;\n//# sourceMappingURL=fee.js.map"]},"metadata":{},"sourceType":"script"}