{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bus = void 0;\n\nvar eventemitter2_1 = require(\"eventemitter2\");\n\nvar axon = require(\"pm2-axon\");\n\nvar pm2_axon_rpc_1 = require(\"pm2-axon-rpc\");\n\nvar action_1 = require(\"./action\");\n\nvar event_1 = require(\"./event\");\n\nvar ipc_server_1 = require(\"./ipc/ipc_server\");\n\nvar JSONRPC = require(\"./jsonrpc\");\n\nvar ws_server_1 = require(\"./ws/ws_server\");\n\nvar ChannelType;\n\n(function (ChannelType) {\n  ChannelType[ChannelType[\"InMemory\"] = 0] = \"InMemory\";\n  ChannelType[ChannelType[\"ChildProcess\"] = 1] = \"ChildProcess\";\n})(ChannelType || (ChannelType = {}));\n\nvar parseError = function parseError(id, err) {\n  if (err instanceof JSONRPC.JSONRPCError) {\n    return err;\n  }\n\n  return new JSONRPC.JSONRPCError(err.message, JSONRPC.errorResponse(id, JSONRPC.internalError(err.message)));\n};\n\nvar Bus = /*#__PURE__*/function () {\n  function Bus(logger, config) {\n    _classCallCheck(this, Bus);\n\n    this.logger = logger;\n    this.config = config;\n    this._emitter = new eventemitter2_1.EventEmitter2({\n      wildcard: true,\n      delimiter: ':',\n      maxListeners: 1000\n    });\n    this.actions = {};\n    this.events = {};\n    this.channels = {};\n    this.rpcClients = {};\n\n    if (this.config.rpc.enable) {\n      this._ipcServer = new ipc_server_1.IPCServer({\n        socketsDir: this.config.socketsPath.root,\n        name: 'bus'\n      });\n    }\n\n    if (this.config.rpc.enable && this.config.rpc.mode === 'ws') {\n      this._wsServer = new ws_server_1.WSServer({\n        path: '/ws',\n        port: config.rpc.port,\n        host: config.rpc.host,\n        logger: this.logger\n      });\n    }\n  }\n\n  _createClass(Bus, [{\n    key: \"setup\",\n    value: function () {\n      var _setup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.config.rpc.enable) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _context.next = 3;\n                return this._setupIPCServer();\n\n              case 3:\n                if (!(this.config.rpc.enable && this.config.rpc.mode === 'ws')) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 6;\n                return this._setupWSServer();\n\n              case 6:\n                return _context.abrupt(\"return\", true);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function setup() {\n        return _setup.apply(this, arguments);\n      }\n\n      return setup;\n    }()\n  }, {\n    key: \"registerChannel\",\n    value: function () {\n      var _registerChannel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(moduleAlias, events, actions, options) {\n        var _this = this;\n\n        var rpcSocket, rpcClient;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                events.forEach(function (eventName) {\n                  if (_this.events[\"\".concat(moduleAlias, \":\").concat(eventName)] !== undefined) {\n                    throw new Error(\"Event \\\"\".concat(eventName, \"\\\" already registered with bus.\"));\n                  }\n\n                  _this.events[\"\".concat(moduleAlias, \":\").concat(eventName)] = true;\n                });\n                Object.keys(actions).forEach(function (actionName) {\n                  if (_this.actions[\"\".concat(moduleAlias, \":\").concat(actionName)] !== undefined) {\n                    throw new Error(\"Action \\\"\".concat(actionName, \"\\\" already registered with bus.\"));\n                  }\n\n                  _this.actions[\"\".concat(moduleAlias, \":\").concat(actionName)] = actions[actionName];\n                });\n\n                if (options.rpcSocketPath) {\n                  rpcSocket = axon.socket('req');\n                  rpcSocket.connect(options.rpcSocketPath);\n                  rpcClient = new pm2_axon_rpc_1.Client(rpcSocket);\n                  this.rpcClients[moduleAlias] = rpcSocket;\n                  this.channels[moduleAlias] = {\n                    rpcClient: rpcClient,\n                    events: events,\n                    actions: actions,\n                    type: ChannelType.ChildProcess\n                  };\n                } else {\n                  this.channels[moduleAlias] = {\n                    channel: options.channel,\n                    events: events,\n                    actions: actions,\n                    type: ChannelType.InMemory\n                  };\n                }\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function registerChannel(_x, _x2, _x3, _x4) {\n        return _registerChannel.apply(this, arguments);\n      }\n\n      return registerChannel;\n    }()\n  }, {\n    key: \"invoke\",\n    value: function () {\n      var _invoke = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(rawRequest) {\n        var request, action, actionFullName, actionParams, channelInfo, result;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (rawRequest) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                this.logger.error('Empty invoke request.');\n                throw new JSONRPC.JSONRPCError('Invalid invoke request.', JSONRPC.errorResponse(null, JSONRPC.invalidRequest()));\n\n              case 3:\n                _context3.prev = 3;\n                request = typeof rawRequest === 'string' ? JSON.parse(rawRequest) : rawRequest;\n                _context3.next = 10;\n                break;\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](3);\n                throw new JSONRPC.JSONRPCError('Invalid invoke request.', JSONRPC.errorResponse(null, JSONRPC.invalidRequest()));\n\n              case 10:\n                _context3.prev = 10;\n                JSONRPC.validateJSONRPCRequest(request);\n                _context3.next = 18;\n                break;\n\n              case 14:\n                _context3.prev = 14;\n                _context3.t1 = _context3[\"catch\"](10);\n                this.logger.error({\n                  err: _context3.t1\n                }, 'Invalid invoke request.');\n                throw new JSONRPC.JSONRPCError('Invalid invoke request.', JSONRPC.errorResponse(request.id, JSONRPC.invalidRequest()));\n\n              case 18:\n                action = action_1.Action.fromJSONRPCRequest(request);\n                actionFullName = action.key();\n\n                if (!(this.actions[actionFullName] === undefined)) {\n                  _context3.next = 22;\n                  break;\n                }\n\n                throw new JSONRPC.JSONRPCError(\"Action '\".concat(actionFullName, \"' is not registered to bus.\"), JSONRPC.errorResponse(action.id, JSONRPC.internalError(\"Action '\".concat(actionFullName, \"' is not registered to bus.\"))));\n\n              case 22:\n                actionParams = action.params;\n                channelInfo = this.channels[action.module];\n\n                if (!(channelInfo.type === ChannelType.InMemory)) {\n                  _context3.next = 35;\n                  break;\n                }\n\n                _context3.prev = 25;\n                _context3.next = 28;\n                return channelInfo.channel.invoke(actionFullName, actionParams);\n\n              case 28:\n                result = _context3.sent;\n                return _context3.abrupt(\"return\", action.buildJSONRPCResponse({\n                  result: result\n                }));\n\n              case 32:\n                _context3.prev = 32;\n                _context3.t2 = _context3[\"catch\"](25);\n                throw parseError(action.id, _context3.t2);\n\n              case 35:\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  channelInfo.rpcClient.call('invoke', action.toJSONRPCRequest(), function (err, data) {\n                    if (err) {\n                      return reject(parseError(action.id, err));\n                    }\n\n                    return resolve(data);\n                  });\n                }));\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 7], [10, 14], [25, 32]]);\n      }));\n\n      function invoke(_x5) {\n        return _invoke.apply(this, arguments);\n      }\n\n      return invoke;\n    }()\n  }, {\n    key: \"publish\",\n    value: function publish(rawRequest) {\n      var request;\n\n      if (!rawRequest) {\n        this.logger.error('Empty publish request.');\n        throw new JSONRPC.JSONRPCError('Invalid publish request.', JSONRPC.errorResponse(null, JSONRPC.invalidRequest()));\n      }\n\n      try {\n        request = typeof rawRequest === 'string' ? JSON.parse(rawRequest) : rawRequest;\n      } catch (error) {\n        throw new JSONRPC.JSONRPCError('Invalid publish request.', JSONRPC.errorResponse(null, JSONRPC.invalidRequest()));\n      }\n\n      try {\n        JSONRPC.validateJSONRPCNotification(request);\n      } catch (error) {\n        this.logger.error({\n          err: error\n        }, 'Invalid publish request.');\n        throw new JSONRPC.JSONRPCError('Invalid publish request.', JSONRPC.errorResponse(null, JSONRPC.invalidRequest()));\n      }\n\n      var event = event_1.Event.fromJSONRPCNotification(rawRequest);\n      var eventName = event.key();\n      var notification = event.toJSONRPCNotification();\n\n      if (!this.getEvents().includes(eventName)) {\n        throw new JSONRPC.JSONRPCError(\"Event \".concat(eventName, \" is not registered to bus.\"), JSONRPC.errorResponse(null, JSONRPC.internalError(\"Event \".concat(eventName, \" is not registered to bus.\"))));\n      }\n\n      this._emitter.emit(eventName, notification);\n\n      if (this.config.rpc.enable) {\n        try {\n          this._ipcServer.pubSocket.send(notification);\n        } catch (error) {\n          this.logger.debug({\n            err: error\n          }, \"Failed to publish event: \".concat(eventName, \" to ipc server.\"));\n        }\n      }\n\n      if (this.config.rpc.enable && this.config.rpc.mode === 'ws') {\n        try {\n          this._wsServer.broadcast(JSON.stringify(notification));\n        } catch (error) {\n          this.logger.debug({\n            err: error\n          }, \"Failed to publish event: \".concat(eventName, \" to ws server.\"));\n        }\n      }\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(eventName, cb) {\n      if (!this.getEvents().includes(eventName)) {\n        this.logger.info(\"Event \".concat(eventName, \" was subscribed but not registered to the bus yet.\"));\n      }\n\n      this._emitter.on(eventName, cb);\n    }\n  }, {\n    key: \"once\",\n    value: function once(eventName, cb) {\n      if (!this.getEvents().includes(eventName)) {\n        this.logger.info(\"Event \".concat(eventName, \" was subscribed but not registered to the bus yet.\"));\n      }\n\n      this._emitter.once(eventName, cb);\n\n      return this;\n    }\n  }, {\n    key: \"getActions\",\n    value: function getActions() {\n      return Object.keys(this.actions);\n    }\n  }, {\n    key: \"getEvents\",\n    value: function getEvents() {\n      return Object.keys(this.events);\n    }\n  }, {\n    key: \"cleanup\",\n    value: function () {\n      var _cleanup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._emitter.removeAllListeners();\n\n                if (this._ipcServer) {\n                  this._ipcServer.stop();\n                }\n\n                if (this._wsServer) {\n                  this._wsServer.stop();\n                }\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function cleanup() {\n        return _cleanup.apply(this, arguments);\n      }\n\n      return cleanup;\n    }()\n  }, {\n    key: \"_setupIPCServer\",\n    value: function () {\n      var _setupIPCServer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._ipcServer.start();\n\n              case 2:\n                this._ipcServer.rpcServer.expose('registerChannel', function (moduleAlias, events, actions, options, cb) {\n                  _this2.registerChannel(moduleAlias, events, actions, options).then(function () {\n                    return cb(null);\n                  }).catch(function (error) {\n                    return cb(error);\n                  });\n                });\n\n                this._ipcServer.rpcServer.expose('invoke', function (message, cb) {\n                  _this2.invoke(message).then(function (data) {\n                    cb(null, data);\n                  }).catch(function (error) {\n                    cb(error, error.response);\n                  });\n                });\n\n                this._ipcServer.subSocket.on('message', function (eventValue) {\n                  _this2.publish(eventValue);\n                });\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _setupIPCServer() {\n        return _setupIPCServer2.apply(this, arguments);\n      }\n\n      return _setupIPCServer;\n    }()\n  }, {\n    key: \"_setupWSServer\",\n    value: function () {\n      var _setupWSServer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this._wsServer.start(function (socket, message) {\n                  _this3.invoke(message).then(function (data) {\n                    socket.send(JSON.stringify(data));\n                  }).catch(function (error) {\n                    socket.send(JSON.stringify(error.response));\n                  });\n                });\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _setupWSServer() {\n        return _setupWSServer2.apply(this, arguments);\n      }\n\n      return _setupWSServer;\n    }()\n  }]);\n\n  return Bus;\n}();\n\nexports.Bus = Bus;","map":{"version":3,"sources":["../../src/controller/bus.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Bus = void 0;\nconst eventemitter2_1 = require(\"eventemitter2\");\nconst axon = require(\"pm2-axon\");\nconst pm2_axon_rpc_1 = require(\"pm2-axon-rpc\");\nconst action_1 = require(\"./action\");\nconst event_1 = require(\"./event\");\nconst ipc_server_1 = require(\"./ipc/ipc_server\");\nconst JSONRPC = require(\"./jsonrpc\");\nconst ws_server_1 = require(\"./ws/ws_server\");\nvar ChannelType;\n(function (ChannelType) {\n    ChannelType[ChannelType[\"InMemory\"] = 0] = \"InMemory\";\n    ChannelType[ChannelType[\"ChildProcess\"] = 1] = \"ChildProcess\";\n})(ChannelType || (ChannelType = {}));\nconst parseError = (id, err) => {\n    if (err instanceof JSONRPC.JSONRPCError) {\n        return err;\n    }\n    return new JSONRPC.JSONRPCError(err.message, JSONRPC.errorResponse(id, JSONRPC.internalError(err.message)));\n};\nclass Bus {\n    constructor(logger, config) {\n        this.logger = logger;\n        this.config = config;\n        this._emitter = new eventemitter2_1.EventEmitter2({\n            wildcard: true,\n            delimiter: ':',\n            maxListeners: 1000,\n        });\n        this.actions = {};\n        this.events = {};\n        this.channels = {};\n        this.rpcClients = {};\n        if (this.config.rpc.enable) {\n            this._ipcServer = new ipc_server_1.IPCServer({\n                socketsDir: this.config.socketsPath.root,\n                name: 'bus',\n            });\n        }\n        if (this.config.rpc.enable && this.config.rpc.mode === 'ws') {\n            this._wsServer = new ws_server_1.WSServer({\n                path: '/ws',\n                port: config.rpc.port,\n                host: config.rpc.host,\n                logger: this.logger,\n            });\n        }\n    }\n    async setup() {\n        if (this.config.rpc.enable) {\n            await this._setupIPCServer();\n        }\n        if (this.config.rpc.enable && this.config.rpc.mode === 'ws') {\n            await this._setupWSServer();\n        }\n        return true;\n    }\n    async registerChannel(moduleAlias, events, actions, options) {\n        events.forEach(eventName => {\n            if (this.events[`${moduleAlias}:${eventName}`] !== undefined) {\n                throw new Error(`Event \"${eventName}\" already registered with bus.`);\n            }\n            this.events[`${moduleAlias}:${eventName}`] = true;\n        });\n        Object.keys(actions).forEach(actionName => {\n            if (this.actions[`${moduleAlias}:${actionName}`] !== undefined) {\n                throw new Error(`Action \"${actionName}\" already registered with bus.`);\n            }\n            this.actions[`${moduleAlias}:${actionName}`] = actions[actionName];\n        });\n        if (options.rpcSocketPath) {\n            const rpcSocket = axon.socket('req');\n            rpcSocket.connect(options.rpcSocketPath);\n            const rpcClient = new pm2_axon_rpc_1.Client(rpcSocket);\n            this.rpcClients[moduleAlias] = rpcSocket;\n            this.channels[moduleAlias] = {\n                rpcClient,\n                events,\n                actions,\n                type: ChannelType.ChildProcess,\n            };\n        }\n        else {\n            this.channels[moduleAlias] = {\n                channel: options.channel,\n                events,\n                actions,\n                type: ChannelType.InMemory,\n            };\n        }\n    }\n    async invoke(rawRequest) {\n        let request;\n        if (!rawRequest) {\n            this.logger.error('Empty invoke request.');\n            throw new JSONRPC.JSONRPCError('Invalid invoke request.', JSONRPC.errorResponse(null, JSONRPC.invalidRequest()));\n        }\n        try {\n            request =\n                typeof rawRequest === 'string'\n                    ? JSON.parse(rawRequest)\n                    : rawRequest;\n        }\n        catch (error) {\n            throw new JSONRPC.JSONRPCError('Invalid invoke request.', JSONRPC.errorResponse(null, JSONRPC.invalidRequest()));\n        }\n        try {\n            JSONRPC.validateJSONRPCRequest(request);\n        }\n        catch (error) {\n            this.logger.error({ err: error }, 'Invalid invoke request.');\n            throw new JSONRPC.JSONRPCError('Invalid invoke request.', JSONRPC.errorResponse(request.id, JSONRPC.invalidRequest()));\n        }\n        const action = action_1.Action.fromJSONRPCRequest(request);\n        const actionFullName = action.key();\n        if (this.actions[actionFullName] === undefined) {\n            throw new JSONRPC.JSONRPCError(`Action '${actionFullName}' is not registered to bus.`, JSONRPC.errorResponse(action.id, JSONRPC.internalError(`Action '${actionFullName}' is not registered to bus.`)));\n        }\n        const actionParams = action.params;\n        const channelInfo = this.channels[action.module];\n        if (channelInfo.type === ChannelType.InMemory) {\n            try {\n                const result = await channelInfo.channel.invoke(actionFullName, actionParams);\n                return action.buildJSONRPCResponse({\n                    result,\n                });\n            }\n            catch (error) {\n                throw parseError(action.id, error);\n            }\n        }\n        return new Promise((resolve, reject) => {\n            channelInfo.rpcClient.call('invoke', action.toJSONRPCRequest(), (err, data) => {\n                if (err) {\n                    return reject(parseError(action.id, err));\n                }\n                return resolve(data);\n            });\n        });\n    }\n    publish(rawRequest) {\n        let request;\n        if (!rawRequest) {\n            this.logger.error('Empty publish request.');\n            throw new JSONRPC.JSONRPCError('Invalid publish request.', JSONRPC.errorResponse(null, JSONRPC.invalidRequest()));\n        }\n        try {\n            request =\n                typeof rawRequest === 'string'\n                    ? JSON.parse(rawRequest)\n                    : rawRequest;\n        }\n        catch (error) {\n            throw new JSONRPC.JSONRPCError('Invalid publish request.', JSONRPC.errorResponse(null, JSONRPC.invalidRequest()));\n        }\n        try {\n            JSONRPC.validateJSONRPCNotification(request);\n        }\n        catch (error) {\n            this.logger.error({ err: error }, 'Invalid publish request.');\n            throw new JSONRPC.JSONRPCError('Invalid publish request.', JSONRPC.errorResponse(null, JSONRPC.invalidRequest()));\n        }\n        const event = event_1.Event.fromJSONRPCNotification(rawRequest);\n        const eventName = event.key();\n        const notification = event.toJSONRPCNotification();\n        if (!this.getEvents().includes(eventName)) {\n            throw new JSONRPC.JSONRPCError(`Event ${eventName} is not registered to bus.`, JSONRPC.errorResponse(null, JSONRPC.internalError(`Event ${eventName} is not registered to bus.`)));\n        }\n        this._emitter.emit(eventName, notification);\n        if (this.config.rpc.enable) {\n            try {\n                this._ipcServer.pubSocket.send(notification);\n            }\n            catch (error) {\n                this.logger.debug({ err: error }, `Failed to publish event: ${eventName} to ipc server.`);\n            }\n        }\n        if (this.config.rpc.enable && this.config.rpc.mode === 'ws') {\n            try {\n                this._wsServer.broadcast(JSON.stringify(notification));\n            }\n            catch (error) {\n                this.logger.debug({ err: error }, `Failed to publish event: ${eventName} to ws server.`);\n            }\n        }\n    }\n    subscribe(eventName, cb) {\n        if (!this.getEvents().includes(eventName)) {\n            this.logger.info(`Event ${eventName} was subscribed but not registered to the bus yet.`);\n        }\n        this._emitter.on(eventName, cb);\n    }\n    once(eventName, cb) {\n        if (!this.getEvents().includes(eventName)) {\n            this.logger.info(`Event ${eventName} was subscribed but not registered to the bus yet.`);\n        }\n        this._emitter.once(eventName, cb);\n        return this;\n    }\n    getActions() {\n        return Object.keys(this.actions);\n    }\n    getEvents() {\n        return Object.keys(this.events);\n    }\n    async cleanup() {\n        this._emitter.removeAllListeners();\n        if (this._ipcServer) {\n            this._ipcServer.stop();\n        }\n        if (this._wsServer) {\n            this._wsServer.stop();\n        }\n    }\n    async _setupIPCServer() {\n        await this._ipcServer.start();\n        this._ipcServer.rpcServer.expose('registerChannel', (moduleAlias, events, actions, options, cb) => {\n            this.registerChannel(moduleAlias, events, actions, options)\n                .then(() => cb(null))\n                .catch(error => cb(error));\n        });\n        this._ipcServer.rpcServer.expose('invoke', (message, cb) => {\n            this.invoke(message)\n                .then(data => {\n                cb(null, data);\n            })\n                .catch((error) => {\n                cb(error, error.response);\n            });\n        });\n        this._ipcServer.subSocket.on('message', (eventValue) => {\n            this.publish(eventValue);\n        });\n    }\n    async _setupWSServer() {\n        this._wsServer.start((socket, message) => {\n            this.invoke(message)\n                .then(data => {\n                socket.send(JSON.stringify(data));\n            })\n                .catch((error) => {\n                socket.send(JSON.stringify(error.response));\n            });\n        });\n    }\n}\nexports.Bus = Bus;\n//# sourceMappingURL=bus.js.map"]},"metadata":{},"sourceType":"script"}