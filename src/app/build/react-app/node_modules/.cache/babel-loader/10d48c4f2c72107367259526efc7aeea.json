{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenModule = void 0;\n\nvar lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nvar constants_1 = require(\"./constants\");\n\nvar transfer_asset_1 = require(\"./transfer_asset\");\n\nvar utils_1 = require(\"./utils\");\n\nvar base_module_1 = require(\"../base_module\");\n\nvar DEFAULT_MIN_REMAINING_BALANCE = '5000000';\n\nvar TokenModule = /*#__PURE__*/function (_base_module_1$BaseMo) {\n  _inherits(TokenModule, _base_module_1$BaseMo);\n\n  var _super = _createSuper(TokenModule);\n\n  function TokenModule(genesisConfig) {\n    var _this;\n\n    _classCallCheck(this, TokenModule);\n\n    _this = _super.call(this, genesisConfig);\n    _this.name = 'token';\n    _this.id = 2;\n    _this.accountSchema = {\n      type: 'object',\n      properties: {\n        balance: {\n          fieldNumber: 1,\n          dataType: 'uint64'\n        }\n      },\n      default: {\n        balance: BigInt(0)\n      }\n    };\n    _this.reducers = {\n      credit: function () {\n        var _credit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(params, stateStore) {\n          var address, amount, account;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  address = params.address, amount = params.amount;\n\n                  if (Buffer.isBuffer(address)) {\n                    _context.next = 3;\n                    break;\n                  }\n\n                  throw new Error('Address must be a buffer');\n\n                case 3:\n                  if (!(typeof amount !== 'bigint')) {\n                    _context.next = 5;\n                    break;\n                  }\n\n                  throw new Error('Amount must be a bigint');\n\n                case 5:\n                  if (!(amount <= BigInt(0))) {\n                    _context.next = 7;\n                    break;\n                  }\n\n                  throw new Error('Amount must be a positive bigint.');\n\n                case 7:\n                  _context.next = 9;\n                  return stateStore.account.getOrDefault(address);\n\n                case 9:\n                  account = _context.sent;\n                  account.token.balance += amount;\n\n                  if (!(account.token.balance < _this._minRemainingBalance)) {\n                    _context.next = 13;\n                    break;\n                  }\n\n                  throw new Error(\"Remaining balance must be greater than \".concat(_this._minRemainingBalance.toString()));\n\n                case 13:\n                  _context.next = 15;\n                  return stateStore.account.set(address, account);\n\n                case 15:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        function credit(_x, _x2) {\n          return _credit.apply(this, arguments);\n        }\n\n        return credit;\n      }(),\n      debit: function () {\n        var _debit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(params, stateStore) {\n          var address, amount, account;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  address = params.address, amount = params.amount;\n\n                  if (Buffer.isBuffer(address)) {\n                    _context2.next = 3;\n                    break;\n                  }\n\n                  throw new Error('Address must be a buffer');\n\n                case 3:\n                  if (!(typeof amount !== 'bigint')) {\n                    _context2.next = 5;\n                    break;\n                  }\n\n                  throw new Error('Amount must be a bigint');\n\n                case 5:\n                  if (!(amount <= BigInt(0))) {\n                    _context2.next = 7;\n                    break;\n                  }\n\n                  throw new Error('Amount must be a positive bigint.');\n\n                case 7:\n                  _context2.next = 9;\n                  return stateStore.account.getOrDefault(address);\n\n                case 9:\n                  account = _context2.sent;\n                  account.token.balance -= amount;\n\n                  if (!(account.token.balance < _this._minRemainingBalance)) {\n                    _context2.next = 13;\n                    break;\n                  }\n\n                  throw new Error(\"Remaining balance must be greater than \".concat(_this._minRemainingBalance.toString()));\n\n                case 13:\n                  _context2.next = 15;\n                  return stateStore.account.set(address, account);\n\n                case 15:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        function debit(_x3, _x4) {\n          return _debit.apply(this, arguments);\n        }\n\n        return debit;\n      }(),\n      getBalance: function () {\n        var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(params, stateStore) {\n          var address, account;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  address = params.address;\n\n                  if (Buffer.isBuffer(address)) {\n                    _context3.next = 3;\n                    break;\n                  }\n\n                  throw new Error('Address must be a buffer');\n\n                case 3:\n                  _context3.next = 5;\n                  return stateStore.account.getOrDefault(address);\n\n                case 5:\n                  account = _context3.sent;\n                  return _context3.abrupt(\"return\", account.token.balance);\n\n                case 7:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        function getBalance(_x5, _x6) {\n          return _getBalance.apply(this, arguments);\n        }\n\n        return getBalance;\n      }(),\n      getMinRemainingBalance: function () {\n        var _getMinRemainingBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  return _context4.abrupt(\"return\", _this._minRemainingBalance);\n\n                case 1:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }));\n\n        function getMinRemainingBalance() {\n          return _getMinRemainingBalance.apply(this, arguments);\n        }\n\n        return getMinRemainingBalance;\n      }()\n    };\n    var minRemainingBalance = _this.config.minRemainingBalance ? _this.config.minRemainingBalance : DEFAULT_MIN_REMAINING_BALANCE;\n\n    if (typeof minRemainingBalance !== 'string') {\n      throw new Error('minRemainingBalance in genesisConfig must be a string.');\n    }\n\n    _this._minRemainingBalance = BigInt(minRemainingBalance);\n    _this.transactionAssets = [new transfer_asset_1.TransferAsset(_this._minRemainingBalance)];\n    return _this;\n  }\n\n  _createClass(TokenModule, [{\n    key: \"beforeTransactionApply\",\n    value: function () {\n      var _beforeTransactionApply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref) {\n        var transaction, stateStore, sender;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                transaction = _ref.transaction, stateStore = _ref.stateStore;\n                _context5.next = 3;\n                return stateStore.account.get(transaction.senderAddress);\n\n              case 3:\n                sender = _context5.sent;\n                sender.token.balance -= transaction.fee;\n                _context5.next = 7;\n                return stateStore.account.set(transaction.senderAddress, sender);\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function beforeTransactionApply(_x7) {\n        return _beforeTransactionApply.apply(this, arguments);\n      }\n\n      return beforeTransactionApply;\n    }()\n  }, {\n    key: \"afterTransactionApply\",\n    value: function () {\n      var _afterTransactionApply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref2) {\n        var transaction, stateStore, sender;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                transaction = _ref2.transaction, stateStore = _ref2.stateStore;\n                _context6.next = 3;\n                return stateStore.account.getOrDefault(transaction.senderAddress);\n\n              case 3:\n                sender = _context6.sent;\n\n                if (!(sender.token.balance < this._minRemainingBalance)) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Account \".concat(sender.address.toString('hex'), \" does not meet the minimum remaining balance requirement: \").concat(this._minRemainingBalance.toString(), \".\"));\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function afterTransactionApply(_x8) {\n        return _afterTransactionApply.apply(this, arguments);\n      }\n\n      return afterTransactionApply;\n    }()\n  }, {\n    key: \"afterBlockApply\",\n    value: function () {\n      var _afterBlockApply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(_ref3) {\n        var block, stateStore, generatorAddress, generator, _utils_1$getTotalFees, totalFee, totalMinFee, givenFee, totalFeeBurntBuffer, totalFeeBurnt, updatedTotalBurntBuffer;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                block = _ref3.block, stateStore = _ref3.stateStore;\n                generatorAddress = lisk_cryptography_1.getAddressFromPublicKey(block.header.generatorPublicKey);\n                _context7.next = 4;\n                return stateStore.account.get(generatorAddress);\n\n              case 4:\n                generator = _context7.sent;\n                generator.token.balance += block.header.reward;\n\n                if (block.payload.length) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                _context7.next = 9;\n                return stateStore.account.set(generatorAddress, generator);\n\n              case 9:\n                return _context7.abrupt(\"return\");\n\n              case 10:\n                _utils_1$getTotalFees = utils_1.getTotalFees(block, BigInt(this.config.minFeePerByte), this.config.baseFees), totalFee = _utils_1$getTotalFees.totalFee, totalMinFee = _utils_1$getTotalFees.totalMinFee;\n                givenFee = totalFee - totalMinFee;\n                generator.token.balance += givenFee;\n                _context7.next = 15;\n                return stateStore.chain.get(constants_1.CHAIN_STATE_BURNT_FEE);\n\n              case 15:\n                totalFeeBurntBuffer = _context7.sent;\n                totalFeeBurnt = totalFeeBurntBuffer ? totalFeeBurntBuffer.readBigInt64BE() : BigInt(0);\n                totalFeeBurnt += givenFee > 0 ? totalMinFee : BigInt(0);\n                updatedTotalBurntBuffer = Buffer.alloc(8);\n                updatedTotalBurntBuffer.writeBigInt64BE(totalFeeBurnt);\n                _context7.next = 22;\n                return stateStore.account.set(generatorAddress, generator);\n\n              case 22:\n                _context7.next = 24;\n                return stateStore.chain.set(constants_1.CHAIN_STATE_BURNT_FEE, updatedTotalBurntBuffer);\n\n              case 24:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function afterBlockApply(_x9) {\n        return _afterBlockApply.apply(this, arguments);\n      }\n\n      return afterBlockApply;\n    }()\n  }, {\n    key: \"afterGenesisBlockApply\",\n    value: function () {\n      var _afterGenesisBlockApply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(_ref4) {\n        var genesisBlock, totalBalance, _iterator, _step, account;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                genesisBlock = _ref4.genesisBlock;\n                totalBalance = BigInt(0);\n                _iterator = _createForOfIteratorHelper(genesisBlock.header.asset.accounts);\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    account = _step.value;\n                    totalBalance += BigInt(account.token.balance);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                if (!(totalBalance > constants_1.GENESIS_BLOCK_MAX_BALANCE)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                throw new Error('Total balance exceeds the limit (2^63)-1');\n\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function afterGenesisBlockApply(_x10) {\n        return _afterGenesisBlockApply.apply(this, arguments);\n      }\n\n      return afterGenesisBlockApply;\n    }()\n  }]);\n\n  return TokenModule;\n}(base_module_1.BaseModule);\n\nexports.TokenModule = TokenModule;","map":{"version":3,"sources":["../../../src/modules/token/token_module.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAaA,IAAA,mBAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,gBAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AAEA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AASA,IAAM,6BAA6B,GAAG,SAAtC;;IAEa,W;;;;;AAyEZ,uBAAmB,aAAnB,EAA+C;AAAA;;AAAA;;AAC9C,8BAAM,aAAN;AAzEM,UAAA,IAAA,GAAO,OAAP;AACA,UAAA,EAAA,GAAK,CAAL;AACA,UAAA,aAAA,GAAgB;AACtB,MAAA,IAAI,EAAE,QADgB;AAEtB,MAAA,UAAU,EAAE;AACX,QAAA,OAAO,EAAE;AACR,UAAA,WAAW,EAAE,CADL;AAER,UAAA,QAAQ,EAAE;AAFF;AADE,OAFU;AAQtB,MAAA,OAAO,EAAE;AACR,QAAA,OAAO,EAAE,MAAM,CAAC,CAAD;AADP;AARa,KAAhB;AAYA,UAAA,QAAA,GAAW;AACjB,MAAA,MAAM;AAAA,+EAAE,iBAAO,MAAP,EAAwC,UAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AACC,kBAAA,OADD,GACqB,MADrB,CACC,OADD,EACU,MADV,GACqB,MADrB,CACU,MADV;;AAAA,sBAEF,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAFE;AAAA;AAAA;AAAA;;AAAA,wBAGA,IAAI,KAAJ,CAAU,0BAAV,CAHA;;AAAA;AAAA,wBAKH,OAAO,MAAP,KAAkB,QALf;AAAA;AAAA;AAAA;;AAAA,wBAMA,IAAI,KAAJ,CAAU,yBAAV,CANA;;AAAA;AAAA,wBAQH,MAAM,IAAI,MAAM,CAAC,CAAD,CARb;AAAA;AAAA;AAAA;;AAAA,wBASA,IAAI,KAAJ,CAAU,mCAAV,CATA;;AAAA;AAAA;AAAA,yBAWe,UAAU,CAAC,OAAX,CAAmB,YAAnB,CAA8C,OAA9C,CAXf;;AAAA;AAWD,kBAAA,OAXC;AAYP,kBAAA,OAAO,CAAC,KAAR,CAAc,OAAd,IAAyB,MAAzB;;AAZO,wBAaH,OAAO,CAAC,KAAR,CAAc,OAAd,GAAwB,MAAK,oBAb1B;AAAA;AAAA;AAAA;;AAAA,wBAcA,IAAI,KAAJ,kDACqC,MAAK,oBAAL,CAA0B,QAA1B,EADrC,EAdA;;AAAA;AAAA;AAAA,yBAkBD,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAuB,OAAvB,EAAgC,OAAhC,CAlBC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SADW;AAqBjB,MAAA,KAAK;AAAA,8EAAE,kBAAO,MAAP,EAAwC,UAAxC;AAAA;AAAA;AAAA;AAAA;AAAA;AACE,kBAAA,OADF,GACsB,MADtB,CACE,OADF,EACW,MADX,GACsB,MADtB,CACW,MADX;;AAAA,sBAED,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAFC;AAAA;AAAA;AAAA;;AAAA,wBAGC,IAAI,KAAJ,CAAU,0BAAV,CAHD;;AAAA;AAAA,wBAKF,OAAO,MAAP,KAAkB,QALhB;AAAA;AAAA;AAAA;;AAAA,wBAMC,IAAI,KAAJ,CAAU,yBAAV,CAND;;AAAA;AAAA,wBAQF,MAAM,IAAI,MAAM,CAAC,CAAD,CARd;AAAA;AAAA;AAAA;;AAAA,wBASC,IAAI,KAAJ,CAAU,mCAAV,CATD;;AAAA;AAAA;AAAA,yBAWgB,UAAU,CAAC,OAAX,CAAmB,YAAnB,CAA8C,OAA9C,CAXhB;;AAAA;AAWA,kBAAA,OAXA;AAYN,kBAAA,OAAO,CAAC,KAAR,CAAc,OAAd,IAAyB,MAAzB;;AAZM,wBAaF,OAAO,CAAC,KAAR,CAAc,OAAd,GAAwB,MAAK,oBAb3B;AAAA;AAAA;AAAA;;AAAA,wBAcC,IAAI,KAAJ,kDACqC,MAAK,oBAAL,CAA0B,QAA1B,EADrC,EAdD;;AAAA;AAAA;AAAA,yBAkBA,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAuB,OAAvB,EAAgC,OAAhC,CAlBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SArBY;AAyCjB,MAAA,UAAU;AAAA,mFAAE,kBACX,MADW,EAEX,UAFW;AAAA;AAAA;AAAA;AAAA;AAAA;AAIH,kBAAA,OAJG,GAIS,MAJT,CAIH,OAJG;;AAAA,sBAKN,MAAM,CAAC,QAAP,CAAgB,OAAhB,CALM;AAAA;AAAA;AAAA;;AAAA,wBAMJ,IAAI,KAAJ,CAAU,0BAAV,CANI;;AAAA;AAAA;AAAA,yBAQW,UAAU,CAAC,OAAX,CAAmB,YAAnB,CAA8C,OAA9C,CARX;;AAAA;AAQL,kBAAA,OARK;AAAA,oDASJ,OAAO,CAAC,KAAR,CAAc,OATV;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA,SAzCO;AAqDjB,MAAA,sBAAsB;AAAA,+FAAE;AAAA;AAAA;AAAA;AAAA;AAAA,oDAA6B,MAAK,oBAAlC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AArDL,KAAX;AA4DN,QAAM,mBAAmB,GAAG,MAAK,MAAL,CAAY,mBAAZ,GACzB,MAAK,MAAL,CAAY,mBADa,GAEzB,6BAFH;;AAGA,QAAI,OAAO,mBAAP,KAA+B,QAAnC,EAA6C;AAC5C,YAAM,IAAI,KAAJ,CAAU,wDAAV,CAAN;AACA;;AACD,UAAK,oBAAL,GAA4B,MAAM,CAAC,mBAAD,CAAlC;AACA,UAAK,iBAAL,GAAyB,CAAC,IAAI,gBAAA,CAAA,aAAJ,CAAkB,MAAK,oBAAvB,CAAD,CAAzB;AAT8C;AAU9C;;;;;6FAEM;AAAA;AAAA;AAAA;AAAA;AAAA;AACN,gBAAA,WADM,QACN,WADM,EAEN,UAFM,QAEN,UAFM;AAAA;AAAA,uBAKe,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAqC,WAAW,CAAC,aAAjD,CALf;;AAAA;AAKA,gBAAA,MALA;AAMN,gBAAA,MAAM,CAAC,KAAP,CAAa,OAAb,IAAwB,WAAW,CAAC,GAApC;AANM;AAAA,uBAOA,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAuB,WAAW,CAAC,aAAnC,EAAkD,MAAlD,CAPA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;4FAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AACN,gBAAA,WADM,SACN,WADM,EAEN,UAFM,SAEN,UAFM;AAAA;AAAA,uBAKe,UAAU,CAAC,OAAX,CAAmB,YAAnB,CAA8C,WAAW,CAAC,aAA1D,CALf;;AAAA;AAKA,gBAAA,MALA;;AAAA,sBAMF,MAAM,CAAC,KAAP,CAAa,OAAb,GAAuB,KAAK,oBAN1B;AAAA;AAAA;AAAA;;AAAA,sBAOC,IAAI,KAAJ,mBACM,MAAM,CAAC,OAAP,CAAe,QAAf,CACV,KADU,CADN,uEAGyD,KAAK,oBAAL,CAA0B,QAA1B,EAHzD,OAPD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;sFAeA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAwB,gBAAA,KAAxB,SAAwB,KAAxB,EAA+B,UAA/B,SAA+B,UAA/B;AAEA,gBAAA,gBAFA,GAEmB,mBAAA,CAAA,uBAAA,CAAwB,KAAK,CAAC,MAAN,CAAa,kBAArC,CAFnB;AAAA;AAAA,uBAGkB,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAqC,gBAArC,CAHlB;;AAAA;AAGA,gBAAA,SAHA;AAIN,gBAAA,SAAS,CAAC,KAAV,CAAgB,OAAhB,IAA2B,KAAK,CAAC,MAAN,CAAa,MAAxC;;AAJM,oBAMD,KAAK,CAAC,OAAN,CAAc,MANb;AAAA;AAAA;AAAA;;AAAA;AAAA,uBAOC,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAuB,gBAAvB,EAAyC,SAAzC,CAPD;;AAAA;AAAA;;AAAA;AAAA,wCAW4B,OAAA,CAAA,YAAA,CACjC,KADiC,EAEjC,MAAM,CAAC,KAAK,MAAL,CAAY,aAAb,CAF2B,EAGjC,KAAK,MAAL,CAAY,QAHqB,CAX5B,EAWE,QAXF,yBAWE,QAXF,EAWY,WAXZ,yBAWY,WAXZ;AAiBA,gBAAA,QAjBA,GAiBW,QAAQ,GAAG,WAjBtB;AAkBN,gBAAA,SAAS,CAAC,KAAV,CAAgB,OAAhB,IAA2B,QAA3B;AAlBM;AAAA,uBAmB4B,UAAU,CAAC,KAAX,CAAiB,GAAjB,CAAqB,WAAA,CAAA,qBAArB,CAnB5B;;AAAA;AAmBA,gBAAA,mBAnBA;AAoBF,gBAAA,aApBE,GAoBc,mBAAmB,GAAG,mBAAmB,CAAC,cAApB,EAAH,GAA0C,MAAM,CAAC,CAAD,CApBjF;AAqBN,gBAAA,aAAa,IAAI,QAAQ,GAAG,CAAX,GAAe,WAAf,GAA6B,MAAM,CAAC,CAAD,CAApD;AAEM,gBAAA,uBAvBA,GAuB0B,MAAM,CAAC,KAAP,CAAa,CAAb,CAvB1B;AAwBN,gBAAA,uBAAuB,CAAC,eAAxB,CAAwC,aAAxC;AAxBM;AAAA,uBAyBA,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAuB,gBAAvB,EAAyC,SAAzC,CAzBA;;AAAA;AAAA;AAAA,uBA0BA,UAAU,CAAC,KAAX,CAAiB,GAAjB,CAAqB,WAAA,CAAA,qBAArB,EAA4C,uBAA5C,CA1BA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;6FA8BA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACN,gBAAA,YADM,SACN,YADM;AAIF,gBAAA,YAJE,GAIa,MAAM,CAAC,CAAD,CAJnB;AAAA,uDAKgB,YAAY,CAAC,MAAb,CAAoB,KAApB,CAA0B,QAL1C;;AAAA;AAKN,sEAA0D;AAA/C,oBAAA,OAA+C;AACzD,oBAAA,YAAY,IAAI,MAAM,CAAC,OAAO,CAAC,KAAR,CAAc,OAAf,CAAtB;AACA;AAPK;AAAA;AAAA;AAAA;AAAA;;AAAA,sBASF,YAAY,GAAG,WAAA,CAAA,yBATb;AAAA;AAAA;AAAA;;AAAA,sBAUC,IAAI,KAAJ,CAAU,0CAAV,CAVD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;EA5IyB,aAAA,CAAA,U;;AAAjC,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TokenModule = void 0;\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\nconst constants_1 = require(\"./constants\");\nconst transfer_asset_1 = require(\"./transfer_asset\");\nconst utils_1 = require(\"./utils\");\nconst base_module_1 = require(\"../base_module\");\nconst DEFAULT_MIN_REMAINING_BALANCE = '5000000';\nclass TokenModule extends base_module_1.BaseModule {\n    constructor(genesisConfig) {\n        super(genesisConfig);\n        this.name = 'token';\n        this.id = 2;\n        this.accountSchema = {\n            type: 'object',\n            properties: {\n                balance: {\n                    fieldNumber: 1,\n                    dataType: 'uint64',\n                },\n            },\n            default: {\n                balance: BigInt(0),\n            },\n        };\n        this.reducers = {\n            credit: async (params, stateStore) => {\n                const { address, amount } = params;\n                if (!Buffer.isBuffer(address)) {\n                    throw new Error('Address must be a buffer');\n                }\n                if (typeof amount !== 'bigint') {\n                    throw new Error('Amount must be a bigint');\n                }\n                if (amount <= BigInt(0)) {\n                    throw new Error('Amount must be a positive bigint.');\n                }\n                const account = await stateStore.account.getOrDefault(address);\n                account.token.balance += amount;\n                if (account.token.balance < this._minRemainingBalance) {\n                    throw new Error(`Remaining balance must be greater than ${this._minRemainingBalance.toString()}`);\n                }\n                await stateStore.account.set(address, account);\n            },\n            debit: async (params, stateStore) => {\n                const { address, amount } = params;\n                if (!Buffer.isBuffer(address)) {\n                    throw new Error('Address must be a buffer');\n                }\n                if (typeof amount !== 'bigint') {\n                    throw new Error('Amount must be a bigint');\n                }\n                if (amount <= BigInt(0)) {\n                    throw new Error('Amount must be a positive bigint.');\n                }\n                const account = await stateStore.account.getOrDefault(address);\n                account.token.balance -= amount;\n                if (account.token.balance < this._minRemainingBalance) {\n                    throw new Error(`Remaining balance must be greater than ${this._minRemainingBalance.toString()}`);\n                }\n                await stateStore.account.set(address, account);\n            },\n            getBalance: async (params, stateStore) => {\n                const { address } = params;\n                if (!Buffer.isBuffer(address)) {\n                    throw new Error('Address must be a buffer');\n                }\n                const account = await stateStore.account.getOrDefault(address);\n                return account.token.balance;\n            },\n            getMinRemainingBalance: async () => this._minRemainingBalance,\n        };\n        const minRemainingBalance = this.config.minRemainingBalance\n            ? this.config.minRemainingBalance\n            : DEFAULT_MIN_REMAINING_BALANCE;\n        if (typeof minRemainingBalance !== 'string') {\n            throw new Error('minRemainingBalance in genesisConfig must be a string.');\n        }\n        this._minRemainingBalance = BigInt(minRemainingBalance);\n        this.transactionAssets = [new transfer_asset_1.TransferAsset(this._minRemainingBalance)];\n    }\n    async beforeTransactionApply({ transaction, stateStore, }) {\n        const sender = await stateStore.account.get(transaction.senderAddress);\n        sender.token.balance -= transaction.fee;\n        await stateStore.account.set(transaction.senderAddress, sender);\n    }\n    async afterTransactionApply({ transaction, stateStore, }) {\n        const sender = await stateStore.account.getOrDefault(transaction.senderAddress);\n        if (sender.token.balance < this._minRemainingBalance) {\n            throw new Error(`Account ${sender.address.toString('hex')} does not meet the minimum remaining balance requirement: ${this._minRemainingBalance.toString()}.`);\n        }\n    }\n    async afterBlockApply({ block, stateStore }) {\n        const generatorAddress = lisk_cryptography_1.getAddressFromPublicKey(block.header.generatorPublicKey);\n        const generator = await stateStore.account.get(generatorAddress);\n        generator.token.balance += block.header.reward;\n        if (!block.payload.length) {\n            await stateStore.account.set(generatorAddress, generator);\n            return;\n        }\n        const { totalFee, totalMinFee } = utils_1.getTotalFees(block, BigInt(this.config.minFeePerByte), this.config.baseFees);\n        const givenFee = totalFee - totalMinFee;\n        generator.token.balance += givenFee;\n        const totalFeeBurntBuffer = await stateStore.chain.get(constants_1.CHAIN_STATE_BURNT_FEE);\n        let totalFeeBurnt = totalFeeBurntBuffer ? totalFeeBurntBuffer.readBigInt64BE() : BigInt(0);\n        totalFeeBurnt += givenFee > 0 ? totalMinFee : BigInt(0);\n        const updatedTotalBurntBuffer = Buffer.alloc(8);\n        updatedTotalBurntBuffer.writeBigInt64BE(totalFeeBurnt);\n        await stateStore.account.set(generatorAddress, generator);\n        await stateStore.chain.set(constants_1.CHAIN_STATE_BURNT_FEE, updatedTotalBurntBuffer);\n    }\n    async afterGenesisBlockApply({ genesisBlock, }) {\n        let totalBalance = BigInt(0);\n        for (const account of genesisBlock.header.asset.accounts) {\n            totalBalance += BigInt(account.token.balance);\n        }\n        if (totalBalance > constants_1.GENESIS_BLOCK_MAX_BALANCE) {\n            throw new Error('Total balance exceeds the limit (2^63)-1');\n        }\n    }\n}\nexports.TokenModule = TokenModule;\n//# sourceMappingURL=token_module.js.map"]},"metadata":{},"sourceType":"script"}