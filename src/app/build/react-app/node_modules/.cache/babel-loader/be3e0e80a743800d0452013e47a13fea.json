{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Mutex = void 0;\n\nvar Mutex = /*#__PURE__*/function () {\n  function Mutex() {\n    _classCallCheck(this, Mutex);\n\n    this._queue = [];\n    this._locked = false;\n  }\n\n  _createClass(Mutex, [{\n    key: \"acquire\",\n    value: function () {\n      var _acquire = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var isLocked, releaseFunc;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                isLocked = this.isLocked();\n                releaseFunc = new Promise(function (resolve) {\n                  return _this._queue.push(resolve);\n                });\n\n                if (!isLocked) {\n                  this._tick();\n                }\n\n                return _context.abrupt(\"return\", releaseFunc);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function acquire() {\n        return _acquire.apply(this, arguments);\n      }\n\n      return acquire;\n    }()\n  }, {\n    key: \"isLocked\",\n    value: function isLocked() {\n      return this._locked;\n    }\n  }, {\n    key: \"runExclusive\",\n    value: function () {\n      var _runExclusive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(worker) {\n        var release;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.acquire();\n\n              case 2:\n                release = _context2.sent;\n                _context2.prev = 3;\n                _context2.next = 6;\n                return worker();\n\n              case 6:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 7:\n                _context2.prev = 7;\n                release();\n                return _context2.finish(7);\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[3,, 7, 10]]);\n      }));\n\n      function runExclusive(_x) {\n        return _runExclusive.apply(this, arguments);\n      }\n\n      return runExclusive;\n    }()\n  }, {\n    key: \"_tick\",\n    value: function _tick() {\n      var _this2 = this;\n\n      var releaseFunc = this._queue.shift();\n\n      if (!releaseFunc) {\n        return;\n      }\n\n      var nextReleaseFunc = function nextReleaseFunc() {\n        _this2._locked = false;\n\n        _this2._tick();\n      };\n\n      this._locked = true;\n      releaseFunc(nextReleaseFunc);\n    }\n  }]);\n\n  return Mutex;\n}();\n\nexports.Mutex = Mutex;","map":{"version":3,"sources":["../../src/job_handlers/mutex.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;IAgBa,K;AAAb,mBAAA;AAAA;;AACkB,SAAA,MAAA,GAAmD,EAAnD;AACT,SAAA,OAAA,GAAU,KAAV;AAoCR;;;;;8EAlCO;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,gBAAA,QADA,GACW,KAAK,QAAL,EADX;AAEA,gBAAA,WAFA,GAEc,IAAI,OAAJ,CAAyB,UAAA,OAAO;AAAA,yBAAI,KAAI,CAAC,MAAL,CAAY,IAAZ,CAAiB,OAAjB,CAAJ;AAAA,iBAAhC,CAFd;;AAGN,oBAAI,CAAC,QAAL,EAAe;AACd,uBAAK,KAAL;AACA;;AALK,iDAMC,WAND;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WASA,oBAAQ;AACd,aAAO,KAAK,OAAZ;AACA;;;;mFAEM,kBAAsB,MAAtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBACgB,KAAK,OAAL,EADhB;;AAAA;AACA,gBAAA,OADA;AAAA;AAAA;AAAA,uBAGQ,MAAM,EAHd;;AAAA;AAAA;;AAAA;AAAA;AAKL,gBAAA,OAAO;AALF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WASC,iBAAK;AAAA;;AACZ,UAAM,WAAW,GAAG,KAAK,MAAL,CAAY,KAAZ,EAApB;;AACA,UAAI,CAAC,WAAL,EAAkB;AACjB;AACA;;AACD,UAAM,eAAe,GAAG,SAAlB,eAAkB,GAAK;AAC5B,QAAA,MAAI,CAAC,OAAL,GAAe,KAAf;;AACA,QAAA,MAAI,CAAC,KAAL;AACA,OAHD;;AAIA,WAAK,OAAL,GAAe,IAAf;AACA,MAAA,WAAW,CAAC,eAAD,CAAX;AACA;;;;;;AArCF,OAAA,CAAA,KAAA,GAAA,KAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Mutex = void 0;\nclass Mutex {\n    constructor() {\n        this._queue = [];\n        this._locked = false;\n    }\n    async acquire() {\n        const isLocked = this.isLocked();\n        const releaseFunc = new Promise(resolve => this._queue.push(resolve));\n        if (!isLocked) {\n            this._tick();\n        }\n        return releaseFunc;\n    }\n    isLocked() {\n        return this._locked;\n    }\n    async runExclusive(worker) {\n        const release = await this.acquire();\n        try {\n            return await worker();\n        }\n        finally {\n            release();\n        }\n    }\n    _tick() {\n        const releaseFunc = this._queue.shift();\n        if (!releaseFunc) {\n            return;\n        }\n        const nextReleaseFunc = () => {\n            this._locked = false;\n            this._tick();\n        };\n        this._locked = true;\n        releaseFunc(nextReleaseFunc);\n    }\n}\nexports.Mutex = Mutex;\n//# sourceMappingURL=mutex.js.map"]},"metadata":{},"sourceType":"script"}