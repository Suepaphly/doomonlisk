{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decryptPassphraseWithPassword = exports.encryptPassphraseWithPassword = exports.decryptMessageWithPassphrase = exports.encryptMessageWithPassphrase = void 0;\n\nvar crypto = require(\"crypto\");\n\nvar buffer_1 = require(\"./buffer\");\n\nvar convert_1 = require(\"./convert\");\n\nvar keys_1 = require(\"./keys\");\n\nvar nacl_1 = require(\"./nacl\");\n\nvar PBKDF2_ITERATIONS = 1e6;\nvar PBKDF2_KEYLEN = 32;\nvar PBKDF2_HASH_FUNCTION = 'sha256';\nvar ENCRYPTION_VERSION = '1';\n\nvar encryptMessageWithPassphrase = function encryptMessageWithPassphrase(message, passphrase, recipientPublicKey) {\n  var _keys_1$getPrivateAnd = keys_1.getPrivateAndPublicKeyFromPassphrase(passphrase),\n      senderPrivateKeyBytes = _keys_1$getPrivateAnd.privateKey;\n\n  var convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(senderPrivateKeyBytes));\n  var messageInBytes = Buffer.from(message, 'utf8');\n  var nonceSize = 24;\n  var nonce = nacl_1.getRandomBytes(nonceSize);\n  var publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(recipientPublicKey);\n\n  if (publicKeyUint8Array === null) {\n    throw new Error('given public key is not a valid Ed25519 public key');\n  }\n\n  var convertedPublicKey = Buffer.from(publicKeyUint8Array);\n  var cipherBytes = nacl_1.box(messageInBytes, nonce, convertedPublicKey, convertedPrivateKey);\n  var nonceHex = buffer_1.bufferToHex(nonce);\n  var encryptedMessage = buffer_1.bufferToHex(cipherBytes);\n  return {\n    nonce: nonceHex,\n    encryptedMessage: encryptedMessage\n  };\n};\n\nexports.encryptMessageWithPassphrase = encryptMessageWithPassphrase;\n\nvar decryptMessageWithPassphrase = function decryptMessageWithPassphrase(cipherHex, nonce, passphrase, senderPublicKey) {\n  var _keys_1$getPrivateAnd2 = keys_1.getPrivateAndPublicKeyFromPassphrase(passphrase),\n      recipientPrivateKeyBytes = _keys_1$getPrivateAnd2.privateKey;\n\n  var convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(recipientPrivateKeyBytes));\n  var cipherBytes = buffer_1.hexToBuffer(cipherHex);\n  var nonceBytes = buffer_1.hexToBuffer(nonce);\n  var publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(senderPublicKey);\n\n  if (publicKeyUint8Array === null) {\n    throw new Error('given public key is not a valid Ed25519 public key');\n  }\n\n  var convertedPublicKey = Buffer.from(publicKeyUint8Array);\n\n  try {\n    var decoded = nacl_1.openBox(cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey);\n    return Buffer.from(decoded).toString();\n  } catch (error) {\n    if (error.message.match(/bad nonce size|\"n\" must be crypto_box_NONCEBYTES bytes long/)) {\n      throw new Error('Expected nonce to be 24 bytes.');\n    }\n\n    throw new Error('Something went wrong during decryption. Is this the full encrypted message?');\n  }\n};\n\nexports.decryptMessageWithPassphrase = decryptMessageWithPassphrase;\n\nvar getKeyFromPassword = function getKeyFromPassword(password, salt, iterations) {\n  return crypto.pbkdf2Sync(password, salt, iterations, PBKDF2_KEYLEN, PBKDF2_HASH_FUNCTION);\n};\n\nvar encryptAES256GCMWithPassword = function encryptAES256GCMWithPassword(plainText, password) {\n  var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PBKDF2_ITERATIONS;\n  var IV_BUFFER_SIZE = 12;\n  var SALT_BUFFER_SIZE = 16;\n  var iv = crypto.randomBytes(IV_BUFFER_SIZE);\n  var salt = crypto.randomBytes(SALT_BUFFER_SIZE);\n  var key = getKeyFromPassword(password, salt, iterations);\n  var cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\n  var firstBlock = cipher.update(plainText, 'utf8');\n  var encrypted = Buffer.concat([firstBlock, cipher.final()]);\n  var tag = cipher.getAuthTag();\n  return {\n    iterations: iterations,\n    cipherText: encrypted.toString('hex'),\n    iv: iv.toString('hex'),\n    salt: salt.toString('hex'),\n    tag: tag.toString('hex'),\n    version: ENCRYPTION_VERSION\n  };\n};\n\nvar getTagBuffer = function getTagBuffer(tag) {\n  var TAG_BUFFER_SIZE = 16;\n  var tagBuffer = buffer_1.hexToBuffer(tag, 'Tag');\n\n  if (tagBuffer.length !== TAG_BUFFER_SIZE) {\n    throw new Error('Tag must be 16 bytes.');\n  }\n\n  return tagBuffer;\n};\n\nvar decryptAES256GCMWithPassword = function decryptAES256GCMWithPassword(encryptedPassphrase, password) {\n  var _encryptedPassphrase$ = encryptedPassphrase.iterations,\n      iterations = _encryptedPassphrase$ === void 0 ? PBKDF2_ITERATIONS : _encryptedPassphrase$,\n      cipherText = encryptedPassphrase.cipherText,\n      iv = encryptedPassphrase.iv,\n      salt = encryptedPassphrase.salt,\n      tag = encryptedPassphrase.tag;\n  var tagBuffer = getTagBuffer(tag);\n  var key = getKeyFromPassword(password, buffer_1.hexToBuffer(salt, 'Salt'), iterations);\n  var decipher = crypto.createDecipheriv('aes-256-gcm', key, buffer_1.hexToBuffer(iv, 'IV'));\n  decipher.setAuthTag(tagBuffer);\n  var firstBlock = decipher.update(buffer_1.hexToBuffer(cipherText, 'Cipher text'));\n  var decrypted = Buffer.concat([firstBlock, decipher.final()]);\n  return decrypted.toString();\n};\n\nexports.encryptPassphraseWithPassword = encryptAES256GCMWithPassword;\nexports.decryptPassphraseWithPassword = decryptAES256GCMWithPassword;","map":{"version":3,"sources":["../src/encrypt.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decryptPassphraseWithPassword = exports.encryptPassphraseWithPassword = exports.decryptMessageWithPassphrase = exports.encryptMessageWithPassphrase = void 0;\nconst crypto = require(\"crypto\");\nconst buffer_1 = require(\"./buffer\");\nconst convert_1 = require(\"./convert\");\nconst keys_1 = require(\"./keys\");\nconst nacl_1 = require(\"./nacl\");\nconst PBKDF2_ITERATIONS = 1e6;\nconst PBKDF2_KEYLEN = 32;\nconst PBKDF2_HASH_FUNCTION = 'sha256';\nconst ENCRYPTION_VERSION = '1';\nconst encryptMessageWithPassphrase = (message, passphrase, recipientPublicKey) => {\n    const { privateKey: senderPrivateKeyBytes } = keys_1.getPrivateAndPublicKeyFromPassphrase(passphrase);\n    const convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(senderPrivateKeyBytes));\n    const messageInBytes = Buffer.from(message, 'utf8');\n    const nonceSize = 24;\n    const nonce = nacl_1.getRandomBytes(nonceSize);\n    const publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(recipientPublicKey);\n    if (publicKeyUint8Array === null) {\n        throw new Error('given public key is not a valid Ed25519 public key');\n    }\n    const convertedPublicKey = Buffer.from(publicKeyUint8Array);\n    const cipherBytes = nacl_1.box(messageInBytes, nonce, convertedPublicKey, convertedPrivateKey);\n    const nonceHex = buffer_1.bufferToHex(nonce);\n    const encryptedMessage = buffer_1.bufferToHex(cipherBytes);\n    return {\n        nonce: nonceHex,\n        encryptedMessage,\n    };\n};\nexports.encryptMessageWithPassphrase = encryptMessageWithPassphrase;\nconst decryptMessageWithPassphrase = (cipherHex, nonce, passphrase, senderPublicKey) => {\n    const { privateKey: recipientPrivateKeyBytes } = keys_1.getPrivateAndPublicKeyFromPassphrase(passphrase);\n    const convertedPrivateKey = Buffer.from(convert_1.convertPrivateKeyEd2Curve(recipientPrivateKeyBytes));\n    const cipherBytes = buffer_1.hexToBuffer(cipherHex);\n    const nonceBytes = buffer_1.hexToBuffer(nonce);\n    const publicKeyUint8Array = convert_1.convertPublicKeyEd2Curve(senderPublicKey);\n    if (publicKeyUint8Array === null) {\n        throw new Error('given public key is not a valid Ed25519 public key');\n    }\n    const convertedPublicKey = Buffer.from(publicKeyUint8Array);\n    try {\n        const decoded = nacl_1.openBox(cipherBytes, nonceBytes, convertedPublicKey, convertedPrivateKey);\n        return Buffer.from(decoded).toString();\n    }\n    catch (error) {\n        if (error.message.match(/bad nonce size|\"n\" must be crypto_box_NONCEBYTES bytes long/)) {\n            throw new Error('Expected nonce to be 24 bytes.');\n        }\n        throw new Error('Something went wrong during decryption. Is this the full encrypted message?');\n    }\n};\nexports.decryptMessageWithPassphrase = decryptMessageWithPassphrase;\nconst getKeyFromPassword = (password, salt, iterations) => crypto.pbkdf2Sync(password, salt, iterations, PBKDF2_KEYLEN, PBKDF2_HASH_FUNCTION);\nconst encryptAES256GCMWithPassword = (plainText, password, iterations = PBKDF2_ITERATIONS) => {\n    const IV_BUFFER_SIZE = 12;\n    const SALT_BUFFER_SIZE = 16;\n    const iv = crypto.randomBytes(IV_BUFFER_SIZE);\n    const salt = crypto.randomBytes(SALT_BUFFER_SIZE);\n    const key = getKeyFromPassword(password, salt, iterations);\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\n    const firstBlock = cipher.update(plainText, 'utf8');\n    const encrypted = Buffer.concat([firstBlock, cipher.final()]);\n    const tag = cipher.getAuthTag();\n    return {\n        iterations,\n        cipherText: encrypted.toString('hex'),\n        iv: iv.toString('hex'),\n        salt: salt.toString('hex'),\n        tag: tag.toString('hex'),\n        version: ENCRYPTION_VERSION,\n    };\n};\nconst getTagBuffer = (tag) => {\n    const TAG_BUFFER_SIZE = 16;\n    const tagBuffer = buffer_1.hexToBuffer(tag, 'Tag');\n    if (tagBuffer.length !== TAG_BUFFER_SIZE) {\n        throw new Error('Tag must be 16 bytes.');\n    }\n    return tagBuffer;\n};\nconst decryptAES256GCMWithPassword = (encryptedPassphrase, password) => {\n    const { iterations = PBKDF2_ITERATIONS, cipherText, iv, salt, tag } = encryptedPassphrase;\n    const tagBuffer = getTagBuffer(tag);\n    const key = getKeyFromPassword(password, buffer_1.hexToBuffer(salt, 'Salt'), iterations);\n    const decipher = crypto.createDecipheriv('aes-256-gcm', key, buffer_1.hexToBuffer(iv, 'IV'));\n    decipher.setAuthTag(tagBuffer);\n    const firstBlock = decipher.update(buffer_1.hexToBuffer(cipherText, 'Cipher text'));\n    const decrypted = Buffer.concat([firstBlock, decipher.final()]);\n    return decrypted.toString();\n};\nexports.encryptPassphraseWithPassword = encryptAES256GCMWithPassword;\nexports.decryptPassphraseWithPassword = decryptAES256GCMWithPassword;\n//# sourceMappingURL=encrypt.js.map"]},"metadata":{},"sourceType":"script"}