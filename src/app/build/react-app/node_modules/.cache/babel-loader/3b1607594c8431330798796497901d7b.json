{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/home/lisk/doomonlisk/src/app/build/react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IPCClient = void 0;\n\nvar axon = require(\"pm2-axon\");\n\nvar pm2_axon_rpc_1 = require(\"pm2-axon-rpc\");\n\nvar ipc_socket_1 = require(\"./ipc_socket\");\n\nvar CONNECTION_TIME_OUT = 2000;\n\nvar IPCClient = /*#__PURE__*/function (_ipc_socket_1$IPCSock) {\n  _inherits(IPCClient, _ipc_socket_1$IPCSock);\n\n  var _super = _createSuper(IPCClient);\n\n  function IPCClient(options) {\n    var _this;\n\n    _classCallCheck(this, IPCClient);\n\n    _this = _super.call(this, options);\n    _this._actionRPCConnectingServerSocketPath = options.rpcServerSocketPath;\n    _this.pubSocket = axon.socket('push', {});\n    _this.subSocket = axon.socket('sub', {});\n    _this.rpcClient = new pm2_axon_rpc_1.Client(axon.socket('req'));\n    return _this;\n  }\n\n  _createClass(IPCClient, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _get(_getPrototypeOf(IPCClient.prototype), \"start\", this).call(this);\n\n              case 2:\n                _context.next = 4;\n                return new Promise(function (resolve, reject) {\n                  var timeout = setTimeout(function () {\n                    reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n                  }, CONNECTION_TIME_OUT);\n\n                  _this2.pubSocket.on('connect', function () {\n                    clearTimeout(timeout);\n                    resolve();\n                  });\n\n                  _this2.pubSocket.on('error', reject);\n\n                  _this2.pubSocket.connect(_this2._eventSubSocketPath);\n                }).finally(function () {\n                  _this2.pubSocket.removeAllListeners('connect');\n\n                  _this2.pubSocket.removeAllListeners('error');\n                });\n\n              case 4:\n                _context.next = 6;\n                return new Promise(function (resolve, reject) {\n                  var timeout = setTimeout(function () {\n                    reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n                  }, CONNECTION_TIME_OUT);\n\n                  _this2.subSocket.on('connect', function () {\n                    clearTimeout(timeout);\n                    resolve();\n                  });\n\n                  _this2.subSocket.on('error', reject);\n\n                  _this2.subSocket.connect(_this2._eventPubSocketPath);\n                }).finally(function () {\n                  _this2.subSocket.removeAllListeners('connect');\n\n                  _this2.subSocket.removeAllListeners('error');\n                });\n\n              case 6:\n                _context.next = 8;\n                return new Promise(function (resolve, reject) {\n                  var timeout = setTimeout(function () {\n                    reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n                  }, CONNECTION_TIME_OUT);\n\n                  _this2.rpcClient.sock.on('connect', function () {\n                    clearTimeout(timeout);\n                    resolve();\n                  });\n\n                  _this2.rpcClient.sock.on('error', reject);\n\n                  _this2.rpcClient.sock.connect(_this2._actionRPCConnectingServerSocketPath);\n                }).finally(function () {\n                  _this2.rpcClient.sock.removeAllListeners('connect');\n\n                  _this2.rpcClient.sock.removeAllListeners('error');\n                });\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      _get(_getPrototypeOf(IPCClient.prototype), \"stop\", this).call(this);\n\n      this.rpcClient.sock.close();\n    }\n  }]);\n\n  return IPCClient;\n}(ipc_socket_1.IPCSocket);\n\nexports.IPCClient = IPCClient;","map":{"version":3,"sources":["../../../src/controller/ipc/ipc_client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IPCClient = void 0;\nconst axon = require(\"pm2-axon\");\nconst pm2_axon_rpc_1 = require(\"pm2-axon-rpc\");\nconst ipc_socket_1 = require(\"./ipc_socket\");\nconst CONNECTION_TIME_OUT = 2000;\nclass IPCClient extends ipc_socket_1.IPCSocket {\n    constructor(options) {\n        super(options);\n        this._actionRPCConnectingServerSocketPath = options.rpcServerSocketPath;\n        this.pubSocket = axon.socket('push', {});\n        this.subSocket = axon.socket('sub', {});\n        this.rpcClient = new pm2_axon_rpc_1.Client(axon.socket('req'));\n    }\n    async start() {\n        await super.start();\n        await new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n            }, CONNECTION_TIME_OUT);\n            this.pubSocket.on('connect', () => {\n                clearTimeout(timeout);\n                resolve();\n            });\n            this.pubSocket.on('error', reject);\n            this.pubSocket.connect(this._eventSubSocketPath);\n        }).finally(() => {\n            this.pubSocket.removeAllListeners('connect');\n            this.pubSocket.removeAllListeners('error');\n        });\n        await new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n            }, CONNECTION_TIME_OUT);\n            this.subSocket.on('connect', () => {\n                clearTimeout(timeout);\n                resolve();\n            });\n            this.subSocket.on('error', reject);\n            this.subSocket.connect(this._eventPubSocketPath);\n        }).finally(() => {\n            this.subSocket.removeAllListeners('connect');\n            this.subSocket.removeAllListeners('error');\n        });\n        await new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => {\n                reject(new Error('IPC Socket client connection timeout. Please check if IPC server is running.'));\n            }, CONNECTION_TIME_OUT);\n            this.rpcClient.sock.on('connect', () => {\n                clearTimeout(timeout);\n                resolve();\n            });\n            this.rpcClient.sock.on('error', reject);\n            this.rpcClient.sock.connect(this._actionRPCConnectingServerSocketPath);\n        }).finally(() => {\n            this.rpcClient.sock.removeAllListeners('connect');\n            this.rpcClient.sock.removeAllListeners('error');\n        });\n    }\n    stop() {\n        super.stop();\n        this.rpcClient.sock.close();\n    }\n}\nexports.IPCClient = IPCClient;\n//# sourceMappingURL=ipc_client.js.map"]},"metadata":{},"sourceType":"script"}