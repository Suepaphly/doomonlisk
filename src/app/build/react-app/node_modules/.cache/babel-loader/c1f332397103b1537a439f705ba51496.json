{"ast":null,"code":"var jwt = require('jsonwebtoken');\n\nvar scErrors = require('sc-errors');\n\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\nvar AuthEngine = function AuthEngine() {};\n\nAuthEngine.prototype.verifyToken = function (signedToken, key, options, callback) {\n  options = options || {};\n  var jwtOptions = cloneObject(options);\n  delete jwtOptions.async;\n  delete jwtOptions.socket;\n\n  if (typeof signedToken === 'string' || signedToken == null) {\n    if (options.async) {\n      jwt.verify(signedToken || '', key, jwtOptions, callback);\n    } else {\n      var err = null;\n      var token;\n\n      try {\n        token = jwt.verify(signedToken || '', key, jwtOptions);\n      } catch (error) {\n        err = error;\n      }\n\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, token);\n      }\n    }\n  } else {\n    var err = new InvalidArgumentsError('Invalid token format - Token must be a string');\n    callback(err);\n  }\n};\n\nAuthEngine.prototype.signToken = function (token, key, options, callback) {\n  options = options || {};\n  var jwtOptions = cloneObject(options);\n  delete jwtOptions.async;\n\n  if (options.async) {\n    jwt.sign(token, key, jwtOptions, callback);\n  } else {\n    var signedToken;\n\n    try {\n      signedToken = jwt.sign(token, key, jwtOptions);\n    } catch (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, signedToken);\n  }\n};\n\nfunction cloneObject(object) {\n  var clone = {};\n  Object.keys(object || {}).forEach(function (key) {\n    clone[key] = object[key];\n  });\n  return clone;\n}\n\nmodule.exports.AuthEngine = AuthEngine;","map":{"version":3,"sources":["/home/lisk/doomonlisk/node_modules/sc-auth/index.js"],"names":["jwt","require","scErrors","InvalidArgumentsError","AuthEngine","prototype","verifyToken","signedToken","key","options","callback","jwtOptions","cloneObject","async","socket","verify","err","token","error","signToken","sign","object","clone","Object","keys","forEach","module","exports"],"mappings":"AAAA,IAAIA,GAAG,GAAGC,OAAO,CAAC,cAAD,CAAjB;;AAEA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,WAAD,CAAtB;;AACA,IAAIE,qBAAqB,GAAGD,QAAQ,CAACC,qBAArC;;AAEA,IAAIC,UAAU,GAAG,SAAbA,UAAa,GAAY,CAAE,CAA/B;;AAEAA,UAAU,CAACC,SAAX,CAAqBC,WAArB,GAAmC,UAAUC,WAAV,EAAuBC,GAAvB,EAA4BC,OAA5B,EAAqCC,QAArC,EAA+C;AAChFD,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAIE,UAAU,GAAGC,WAAW,CAACH,OAAD,CAA5B;AACA,SAAOE,UAAU,CAACE,KAAlB;AACA,SAAOF,UAAU,CAACG,MAAlB;;AACA,MAAI,OAAOP,WAAP,KAAuB,QAAvB,IAAmCA,WAAW,IAAI,IAAtD,EAA4D;AAC1D,QAAIE,OAAO,CAACI,KAAZ,EAAmB;AACjBb,MAAAA,GAAG,CAACe,MAAJ,CAAWR,WAAW,IAAI,EAA1B,EAA8BC,GAA9B,EAAmCG,UAAnC,EAA+CD,QAA/C;AACD,KAFD,MAEO;AACL,UAAIM,GAAG,GAAG,IAAV;AACA,UAAIC,KAAJ;;AACA,UAAI;AACFA,QAAAA,KAAK,GAAGjB,GAAG,CAACe,MAAJ,CAAWR,WAAW,IAAI,EAA1B,EAA8BC,GAA9B,EAAmCG,UAAnC,CAAR;AACD,OAFD,CAEE,OAAOO,KAAP,EAAc;AACdF,QAAAA,GAAG,GAAGE,KAAN;AACD;;AACD,UAAIF,GAAJ,EAAS;AACPN,QAAAA,QAAQ,CAACM,GAAD,CAAR;AACD,OAFD,MAEO;AACLN,QAAAA,QAAQ,CAAC,IAAD,EAAOO,KAAP,CAAR;AACD;AACF;AACF,GAjBD,MAiBO;AACL,QAAID,GAAG,GAAG,IAAIb,qBAAJ,CAA0B,+CAA1B,CAAV;AACAO,IAAAA,QAAQ,CAACM,GAAD,CAAR;AACD;AACF,CA1BD;;AA4BAZ,UAAU,CAACC,SAAX,CAAqBc,SAArB,GAAiC,UAAUF,KAAV,EAAiBT,GAAjB,EAAsBC,OAAtB,EAA+BC,QAA/B,EAAyC;AACxED,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAIE,UAAU,GAAGC,WAAW,CAACH,OAAD,CAA5B;AACA,SAAOE,UAAU,CAACE,KAAlB;;AACA,MAAIJ,OAAO,CAACI,KAAZ,EAAmB;AACjBb,IAAAA,GAAG,CAACoB,IAAJ,CAASH,KAAT,EAAgBT,GAAhB,EAAqBG,UAArB,EAAiCD,QAAjC;AACD,GAFD,MAEO;AACL,QAAIH,WAAJ;;AACA,QAAI;AACFA,MAAAA,WAAW,GAAGP,GAAG,CAACoB,IAAJ,CAASH,KAAT,EAAgBT,GAAhB,EAAqBG,UAArB,CAAd;AACD,KAFD,CAEE,OAAOK,GAAP,EAAY;AACZN,MAAAA,QAAQ,CAACM,GAAD,CAAR;AACA;AACD;;AACDN,IAAAA,QAAQ,CAAC,IAAD,EAAOH,WAAP,CAAR;AACD;AACF,CAhBD;;AAkBA,SAASK,WAAT,CAAqBS,MAArB,EAA6B;AAC3B,MAAIC,KAAK,GAAG,EAAZ;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAYH,MAAM,IAAI,EAAtB,EAA0BI,OAA1B,CAAkC,UAAUjB,GAAV,EAAe;AAC/Cc,IAAAA,KAAK,CAACd,GAAD,CAAL,GAAaa,MAAM,CAACb,GAAD,CAAnB;AACD,GAFD;AAGA,SAAOc,KAAP;AACD;;AAEDI,MAAM,CAACC,OAAP,CAAevB,UAAf,GAA4BA,UAA5B","sourcesContent":["var jwt = require('jsonwebtoken');\n\nvar scErrors = require('sc-errors');\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\nvar AuthEngine = function () {};\n\nAuthEngine.prototype.verifyToken = function (signedToken, key, options, callback) {\n  options = options || {};\n  var jwtOptions = cloneObject(options);\n  delete jwtOptions.async;\n  delete jwtOptions.socket;\n  if (typeof signedToken === 'string' || signedToken == null) {\n    if (options.async) {\n      jwt.verify(signedToken || '', key, jwtOptions, callback);\n    } else {\n      var err = null;\n      var token;\n      try {\n        token = jwt.verify(signedToken || '', key, jwtOptions);\n      } catch (error) {\n        err = error;\n      }\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, token);\n      }\n    }\n  } else {\n    var err = new InvalidArgumentsError('Invalid token format - Token must be a string');\n    callback(err);\n  }\n};\n\nAuthEngine.prototype.signToken = function (token, key, options, callback) {\n  options = options || {};\n  var jwtOptions = cloneObject(options);\n  delete jwtOptions.async;\n  if (options.async) {\n    jwt.sign(token, key, jwtOptions, callback);\n  } else {\n    var signedToken;\n    try {\n      signedToken = jwt.sign(token, key, jwtOptions);\n    } catch (err) {\n      callback(err);\n      return;\n    }\n    callback(null, signedToken);\n  }\n};\n\nfunction cloneObject(object) {\n  var clone = {};\n  Object.keys(object || {}).forEach(function (key) {\n    clone[key] = object[key];\n  });\n  return clone;\n}\n\nmodule.exports.AuthEngine = AuthEngine;\n"]},"metadata":{},"sourceType":"script"}